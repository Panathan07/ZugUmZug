{"version":3,"file":"index.production.js","sources":["../../../../node_modules/.pnpm/tiny-invariant@1.3.1/node_modules/tiny-invariant/dist/esm/tiny-invariant.js","../../../../node_modules/.pnpm/tiny-warning@1.0.3/node_modules/tiny-warning/dist/tiny-warning.esm.js","../../../../node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/shim/with-selector.js","../../../../node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.min.js","../../../../node_modules/.pnpm/@tanstack+react-store@0.2.1_react-dom@18.2.0_react@18.2.0/node_modules/@tanstack/react-store/build/modern/index.js","../../../react-router/build/esm/index.js","../../src/useLocalStorage.ts","../../src/theme.tsx","../../src/utils.ts","../../src/useMediaQuery.ts","../../src/styledComponents.ts","../../src/Explorer.tsx","../../src/devtools.tsx"],"sourcesContent":["var isProduction = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new Error(prefix);\n    }\n    var provided = typeof message === 'function' ? message() : message;\n    var value = provided ? \"\".concat(prefix, \": \").concat(provided) : prefix;\n    throw new Error(value);\n}\n\nexport { invariant as default };\n","var isProduction = process.env.NODE_ENV === 'production';\nfunction warning(condition, message) {\n  if (!isProduction) {\n    if (condition) {\n      return;\n    }\n\n    var text = \"Warning: \" + message;\n\n    if (typeof console !== 'undefined') {\n      console.warn(text);\n    }\n\n    try {\n      throw Error(text);\n    } catch (x) {}\n  }\n}\n\nexport default warning;\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.production.min.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.development.js');\n}\n","/**\n * @license React\n * use-sync-external-store-shim/with-selector.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var h=require(\"react\"),n=require(\"use-sync-external-store/shim\");function p(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var q=\"function\"===typeof Object.is?Object.is:p,r=n.useSyncExternalStore,t=h.useRef,u=h.useEffect,v=h.useMemo,w=h.useDebugValue;\nexports.useSyncExternalStoreWithSelector=function(a,b,e,l,g){var c=t(null);if(null===c.current){var f={hasValue:!1,value:null};c.current=f}else f=c.current;c=v(function(){function a(a){if(!c){c=!0;d=a;a=l(a);if(void 0!==g&&f.hasValue){var b=f.value;if(g(b,a))return k=b}return k=a}b=k;if(q(d,a))return b;var e=l(a);if(void 0!==g&&g(b,e))return b;d=a;return k=e}var c=!1,d,k,m=void 0===e?null:e;return[function(){return a(b())},null===m?void 0:function(){return a(m())}]},[b,e,l,g]);var d=r(a,c[0],c[1]);\nu(function(){f.hasValue=!0;f.value=d},[d]);w(d);return d};\n","// src/index.ts\nimport { useSyncExternalStoreWithSelector } from \"use-sync-external-store/shim/with-selector.js\";\nexport * from \"@tanstack/store\";\nfunction useStore(store, selector = (d) => d) {\n  const slice = useSyncExternalStoreWithSelector(\n    store.subscribe,\n    () => store.state,\n    () => store.state,\n    selector,\n    shallow\n  );\n  return slice;\n}\nfunction shallow(objA, objB) {\n  if (Object.is(objA, objB)) {\n    return true;\n  }\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n    return false;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  for (let i = 0; i < keysA.length; i++) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n  return true;\n}\nexport {\n  shallow,\n  useStore\n};\n//# sourceMappingURL=index.js.map","/**\n * @tanstack/react-router/src/index.tsx\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { createBrowserHistory, createMemoryHistory } from '@tanstack/history';\nexport * from '@tanstack/history';\nimport invariant from 'tiny-invariant';\nexport { default as invariant } from 'tiny-invariant';\nimport warning from 'tiny-warning';\nexport { default as warning } from 'tiny-warning';\nimport * as React from 'react';\nimport { useStore } from '@tanstack/react-store';\nimport { Store } from '@tanstack/store';\n\nfunction CatchBoundary(props) {\n  const errorComponent = props.errorComponent ?? ErrorComponent;\n  return /*#__PURE__*/React.createElement(CatchBoundaryImpl, {\n    getResetKey: props.getResetKey,\n    onCatch: props.onCatch,\n    children: ({\n      error\n    }) => {\n      if (error) {\n        return /*#__PURE__*/React.createElement(errorComponent, {\n          error\n        });\n      }\n      return props.children;\n    }\n  });\n}\nclass CatchBoundaryImpl extends React.Component {\n  state = {\n    error: null\n  };\n  static getDerivedStateFromProps(props) {\n    return {\n      resetKey: props.getResetKey()\n    };\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      error\n    };\n  }\n  componentDidUpdate(prevProps, prevState) {\n    if (prevState.error && prevState.resetKey !== this.state.resetKey) {\n      this.setState({\n        error: null\n      });\n    }\n  }\n  componentDidCatch(error) {\n    console.error(error);\n    this.props.onCatch?.(error);\n  }\n  render() {\n    return this.props.children(this.state);\n  }\n}\nfunction ErrorComponent({\n  error\n}) {\n  const [show, setShow] = React.useState(process.env.NODE_ENV !== 'production');\n  return /*#__PURE__*/React.createElement(\"div\", {\n    style: {\n      padding: '.5rem',\n      maxWidth: '100%'\n    }\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    style: {\n      display: 'flex',\n      alignItems: 'center',\n      gap: '.5rem'\n    }\n  }, /*#__PURE__*/React.createElement(\"strong\", {\n    style: {\n      fontSize: '1rem'\n    }\n  }, \"Something went wrong!\"), /*#__PURE__*/React.createElement(\"button\", {\n    style: {\n      appearance: 'none',\n      fontSize: '.6em',\n      border: '1px solid currentColor',\n      padding: '.1rem .2rem',\n      fontWeight: 'bold',\n      borderRadius: '.25rem'\n    },\n    onClick: () => setShow(d => !d)\n  }, show ? 'Hide Error' : 'Show Error')), /*#__PURE__*/React.createElement(\"div\", {\n    style: {\n      height: '.25rem'\n    }\n  }), show ? /*#__PURE__*/React.createElement(\"div\", null, /*#__PURE__*/React.createElement(\"pre\", {\n    style: {\n      fontSize: '.7em',\n      border: '1px solid red',\n      borderRadius: '.25rem',\n      padding: '.3rem',\n      color: 'red',\n      overflow: 'auto'\n    }\n  }, error.message ? /*#__PURE__*/React.createElement(\"code\", null, error.message) : null)) : null);\n}\n\n// export type Expand<T> = T\n\n// type Compute<T> = { [K in keyof T]: T[K] } | never\n\n// type AllKeys<T> = T extends any ? keyof T : never\n\n// export type MergeUnion<T, Keys extends keyof T = keyof T> = Compute<\n//   {\n//     [K in Keys]: T[Keys]\n//   } & {\n//     [K in AllKeys<T>]?: T extends any\n//       ? K extends keyof T\n//         ? T[K]\n//         : never\n//       : never\n//   }\n// >\n\n// // Sample types to merge\n// type TypeA = {\n//   shared: string\n//   onlyInA: string\n//   nested: {\n//     shared: string\n//     aProp: string\n//   }\n//   array: string[]\n// }\n\n// type TypeB = {\n//   shared: number\n//   onlyInB: number\n//   nested: {\n//     shared: number\n//     bProp: number\n//   }\n//   array: number[]\n// }\n\n// type TypeC = {\n//   shared: boolean\n//   onlyInC: boolean\n//   nested: {\n//     shared: boolean\n//     cProp: boolean\n//   }\n//   array: boolean[]\n// }\n\n// type Test = Expand<Assign<TypeA, TypeB>>\n\n// // Using DeepMerge to merge TypeA and TypeB\n// type MergedType = Expand<AssignAll<[TypeA, TypeB, TypeC]>>\n\n// from https://github.com/type-challenges/type-challenges/issues/737\n\n//\n\nconst isServer = typeof document === 'undefined';\nfunction last(arr) {\n  return arr[arr.length - 1];\n}\nfunction isFunction(d) {\n  return typeof d === 'function';\n}\nfunction functionalUpdate(updater, previous) {\n  if (isFunction(updater)) {\n    return updater(previous);\n  }\n  return updater;\n}\nfunction pick(parent, keys) {\n  return keys.reduce((obj, key) => {\n    obj[key] = parent[key];\n    return obj;\n  }, {});\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between immutable JSON values for example.\n * Do not use this with signals\n */\nfunction replaceEqualDeep(prev, _next) {\n  if (prev === _next) {\n    return prev;\n  }\n  const next = _next;\n  const array = Array.isArray(prev) && Array.isArray(next);\n  if (array || isPlainObject(prev) && isPlainObject(next)) {\n    const prevSize = array ? prev.length : Object.keys(prev).length;\n    const nextItems = array ? next : Object.keys(next);\n    const nextSize = nextItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n    for (let i = 0; i < nextSize; i++) {\n      const key = array ? i : nextItems[i];\n      copy[key] = replaceEqualDeep(prev[key], next[key]);\n      if (copy[key] === prev[key]) {\n        equalItems++;\n      }\n    }\n    return prevSize === nextSize && equalItems === prevSize ? prev : copy;\n  }\n  return next;\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor;\n  if (typeof ctor === 'undefined') {\n    return true;\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype;\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n}\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\nfunction deepEqual(a, b, partial = false) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (isPlainObject(a) && isPlainObject(b)) {\n    const aKeys = Object.keys(a);\n    const bKeys = Object.keys(b);\n    if (!partial && aKeys.length !== bKeys.length) {\n      return false;\n    }\n    return !bKeys.some(key => !(key in a) || !deepEqual(a[key], b[key], partial));\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return !a.some((item, index) => !deepEqual(item, b[index], partial));\n  }\n  return false;\n}\nfunction useStableCallback(fn) {\n  const fnRef = React.useRef(fn);\n  fnRef.current = fn;\n  const ref = React.useRef((...args) => fnRef.current(...args));\n  return ref.current;\n}\nfunction shallow(objA, objB) {\n  if (Object.is(objA, objB)) {\n    return true;\n  }\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n    return false;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  for (let i = 0; i < keysA.length; i++) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction useRouteContext(opts) {\n  return useMatch({\n    ...opts,\n    select: match => opts?.select ? opts.select(match.context) : match.context\n  });\n}\nconst useLayoutEffect$1 = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\nfunction escapeJSON(jsonString) {\n  return jsonString.replace(/\\\\/g, '\\\\\\\\') // Escape backslashes\n  .replace(/'/g, \"\\\\'\") // Escape single quotes\n  .replace(/\"/g, '\\\\\"'); // Escape double quotes\n}\n\nconst matchContext = /*#__PURE__*/React.createContext(undefined);\nfunction Matches() {\n  const router = useRouter();\n  const matchId = useRouterState({\n    select: s => {\n      return getRenderedMatches(s)[0]?.id;\n    }\n  });\n  return /*#__PURE__*/React.createElement(matchContext.Provider, {\n    value: matchId\n  }, /*#__PURE__*/React.createElement(CatchBoundary, {\n    getResetKey: () => router.state.resolvedLocation.state?.key,\n    errorComponent: ErrorComponent,\n    onCatch: () => {\n      warning(false, `Error in router! Consider setting an 'errorComponent' in your RootRoute! ðŸ‘`);\n    }\n  }, matchId ? /*#__PURE__*/React.createElement(Match, {\n    matchId: matchId\n  }) : null));\n}\nfunction SafeFragment(props) {\n  return /*#__PURE__*/React.createElement(React.Fragment, null, props.children);\n}\nfunction Match({\n  matchId\n}) {\n  const router = useRouter();\n  const routeId = useRouterState({\n    select: s => getRenderedMatches(s).find(d => d.id === matchId)?.routeId\n  });\n  invariant(routeId, `Could not find routeId for matchId \"${matchId}\". Please file an issue!`);\n  const route = router.routesById[routeId];\n  const PendingComponent = route.options.pendingComponent ?? router.options.defaultPendingComponent;\n  const pendingElement = PendingComponent ? /*#__PURE__*/React.createElement(PendingComponent, null) : null;\n  const routeErrorComponent = route.options.errorComponent ?? router.options.defaultErrorComponent ?? ErrorComponent;\n  const ResolvedSuspenseBoundary = route.options.wrapInSuspense ?? PendingComponent ?? route.options.component?.preload ?? route.options.pendingComponent?.preload ?? route.options.errorComponent?.preload ? React.Suspense : SafeFragment;\n  const ResolvedCatchBoundary = routeErrorComponent ? CatchBoundary : SafeFragment;\n  return /*#__PURE__*/React.createElement(matchContext.Provider, {\n    value: matchId\n  }, /*#__PURE__*/React.createElement(ResolvedSuspenseBoundary, {\n    fallback: pendingElement\n  }, /*#__PURE__*/React.createElement(ResolvedCatchBoundary, {\n    getResetKey: () => router.state.resolvedLocation.state?.key,\n    errorComponent: routeErrorComponent,\n    onCatch: () => {\n      warning(false, `Error in route match: ${matchId}`);\n    }\n  }, /*#__PURE__*/React.createElement(MatchInner, {\n    matchId: matchId,\n    pendingElement: pendingElement\n  }))));\n}\nfunction MatchInner({\n  matchId,\n  pendingElement\n}) {\n  const router = useRouter();\n  const routeId = useRouterState({\n    select: s => getRenderedMatches(s).find(d => d.id === matchId)?.routeId\n  });\n  const route = router.routesById[routeId];\n  const match = useRouterState({\n    select: s => pick(getRenderedMatches(s).find(d => d.id === matchId), ['status', 'error', 'showPending', 'loadPromise'])\n  });\n  if (match.status === 'error') {\n    throw match.error;\n  }\n  if (match.status === 'pending') {\n    if (match.showPending) {\n      return pendingElement;\n    }\n    throw match.loadPromise;\n  }\n  if (match.status === 'success') {\n    let Comp = route.options.component ?? router.options.defaultComponent;\n    if (Comp) {\n      return /*#__PURE__*/React.createElement(Comp, null);\n    }\n    return /*#__PURE__*/React.createElement(Outlet, null);\n  }\n  invariant(false, 'Idle routeMatch status encountered during rendering! You should never see this. File an issue!');\n}\nconst Outlet = /*#__PURE__*/React.memo(function Outlet() {\n  const matchId = React.useContext(matchContext);\n  const childMatchId = useRouterState({\n    select: s => {\n      const matches = getRenderedMatches(s);\n      const index = matches.findIndex(d => d.id === matchId);\n      return matches[index + 1]?.id;\n    }\n  });\n  if (!childMatchId) {\n    return null;\n  }\n  return /*#__PURE__*/React.createElement(Match, {\n    matchId: childMatchId\n  });\n});\nfunction useMatchRoute() {\n  useRouterState({\n    select: s => [s.location, s.resolvedLocation]\n  });\n  const {\n    matchRoute\n  } = useRouter();\n  return React.useCallback(opts => {\n    const {\n      pending,\n      caseSensitive,\n      ...rest\n    } = opts;\n    return matchRoute(rest, {\n      pending,\n      caseSensitive\n    });\n  }, []);\n}\nfunction MatchRoute(props) {\n  const matchRoute = useMatchRoute();\n  const params = matchRoute(props);\n  if (typeof props.children === 'function') {\n    return props.children(params);\n  }\n  return !!params ? props.children : null;\n}\nfunction getRenderedMatches(state) {\n  return state.pendingMatches?.some(d => d.showPending) ? state.pendingMatches : state.matches;\n}\nfunction useMatch(opts) {\n  const router = useRouter();\n  const nearestMatchId = React.useContext(matchContext);\n  const nearestMatchRouteId = getRenderedMatches(router.state).find(d => d.id === nearestMatchId)?.routeId;\n  const matchRouteId = (() => {\n    const matches = getRenderedMatches(router.state);\n    const match = opts?.from ? matches.find(d => d.routeId === opts?.from) : matches.find(d => d.id === nearestMatchId);\n    return match.routeId;\n  })();\n  if (opts?.strict ?? true) {\n    invariant(nearestMatchRouteId == matchRouteId, `useMatch(\"${matchRouteId}\") is being called in a component that is meant to render the '${nearestMatchRouteId}' route. Did you mean to 'useMatch(\"${matchRouteId}\", { strict: false })' or 'useRoute(\"${matchRouteId}\")' instead?`);\n  }\n  const matchSelection = useRouterState({\n    select: state => {\n      const match = getRenderedMatches(state).find(d => d.id === nearestMatchId);\n      invariant(match, `Could not find ${opts?.from ? `an active match from \"${opts.from}\"` : 'a nearest match!'}`);\n      return opts?.select ? opts.select(match) : match;\n    }\n  });\n  return matchSelection;\n}\nfunction useMatches(opts) {\n  return useRouterState({\n    select: state => {\n      let matches = getRenderedMatches(state);\n      return opts?.select ? opts.select(matches) : matches;\n    }\n  });\n}\nfunction useParentMatches(opts) {\n  const contextMatchId = React.useContext(matchContext);\n  return useMatches({\n    select: matches => {\n      matches = matches.slice(matches.findIndex(d => d.id === contextMatchId));\n      return opts?.select ? opts.select(matches) : matches;\n    }\n  });\n}\nfunction useLoaderDeps(opts) {\n  return useMatch({\n    ...opts,\n    select: s => {\n      return typeof opts.select === 'function' ? opts.select(s?.loaderDeps) : s?.loaderDeps;\n    }\n  });\n}\nfunction useLoaderData(opts) {\n  return useMatch({\n    ...opts,\n    select: s => {\n      return typeof opts.select === 'function' ? opts.select(s?.loaderData) : s?.loaderData;\n    }\n  });\n}\n\nlet routerContext = /*#__PURE__*/React.createContext(null);\nif (typeof document !== 'undefined') {\n  if (window.__TSR_ROUTER_CONTEXT__) {\n    routerContext = window.__TSR_ROUTER_CONTEXT__;\n  } else {\n    window.__TSR_ROUTER_CONTEXT__ = routerContext;\n  }\n}\nfunction RouterProvider({\n  router,\n  ...rest\n}) {\n  // Allow the router to update options on the router instance\n  router.update({\n    ...router.options,\n    ...rest,\n    context: {\n      ...router.options.context,\n      ...rest?.context\n    }\n  });\n  const matches = router.options.InnerWrap ? /*#__PURE__*/React.createElement(router.options.InnerWrap, null, /*#__PURE__*/React.createElement(Matches, null)) : /*#__PURE__*/React.createElement(Matches, null);\n  const provider = /*#__PURE__*/React.createElement(routerContext.Provider, {\n    value: router\n  }, matches, /*#__PURE__*/React.createElement(Transitioner, null));\n  if (router.options.Wrap) {\n    return /*#__PURE__*/React.createElement(router.options.Wrap, null, provider);\n  }\n  return provider;\n}\nfunction Transitioner() {\n  const router = useRouter();\n  const routerState = useRouterState({\n    select: s => pick(s, ['isLoading', 'location', 'resolvedLocation', 'isTransitioning'])\n  });\n  const [isTransitioning, startReactTransition] = React.useTransition();\n  router.startReactTransition = startReactTransition;\n  React.useEffect(() => {\n    if (isTransitioning) {\n      router.__store.setState(s => ({\n        ...s,\n        isTransitioning\n      }));\n    }\n  }, [isTransitioning]);\n  const tryLoad = () => {\n    const apply = cb => {\n      if (!routerState.isTransitioning) {\n        startReactTransition(() => cb());\n      } else {\n        cb();\n      }\n    };\n    apply(() => {\n      try {\n        router.load();\n      } catch (err) {\n        console.error(err);\n      }\n    });\n  };\n  useLayoutEffect$1(() => {\n    const unsub = router.history.subscribe(() => {\n      router.latestLocation = router.parseLocation(router.latestLocation);\n      if (routerState.location !== router.latestLocation) {\n        tryLoad();\n      }\n    });\n    const nextLocation = router.buildLocation({\n      search: true,\n      params: true,\n      hash: true,\n      state: true\n    });\n    if (routerState.location.href !== nextLocation.href) {\n      router.commitLocation({\n        ...nextLocation,\n        replace: true\n      });\n    }\n    return () => {\n      unsub();\n    };\n  }, [router.history]);\n  useLayoutEffect$1(() => {\n    if (routerState.isTransitioning && !isTransitioning && !routerState.isLoading && routerState.resolvedLocation !== routerState.location) {\n      router.emit({\n        type: 'onResolved',\n        fromLocation: routerState.resolvedLocation,\n        toLocation: routerState.location,\n        pathChanged: routerState.location.href !== routerState.resolvedLocation?.href\n      });\n      if (document.querySelector) {\n        if (routerState.location.hash !== '') {\n          const el = document.getElementById(routerState.location.hash);\n          if (el) {\n            el.scrollIntoView();\n          }\n        }\n      }\n      router.__store.setState(s => ({\n        ...s,\n        isTransitioning: false,\n        resolvedLocation: s.location\n      }));\n    }\n  }, [routerState.isTransitioning, isTransitioning, routerState.isLoading, routerState.resolvedLocation, routerState.location]);\n  useLayoutEffect$1(() => {\n    if (!window.__TSR_DEHYDRATED__) {\n      tryLoad();\n    }\n  }, []);\n  return null;\n}\nfunction getRouteMatch(state, id) {\n  return [...state.cachedMatches, ...(state.pendingMatches ?? []), ...state.matches].find(d => d.id === id);\n}\nfunction useRouterState(opts) {\n  const router = useRouter();\n  return useStore(router.__store, opts?.select);\n}\nfunction useRouter() {\n  const resolvedContext = typeof document !== 'undefined' ? window.__TSR_ROUTER_CONTEXT__ || routerContext : routerContext;\n  const value = React.useContext(resolvedContext);\n  warning(value, 'useRouter must be used inside a <RouterProvider> component!');\n  return value;\n}\n\nfunction defer(_promise) {\n  const promise = _promise;\n  if (!promise.__deferredState) {\n    promise.__deferredState = {\n      uid: Math.random().toString(36).slice(2),\n      status: 'pending'\n    };\n    const state = promise.__deferredState;\n    promise.then(data => {\n      state.status = 'success';\n      state.data = data;\n    }).catch(error => {\n      state.status = 'error';\n      state.error = error;\n    });\n  }\n  return promise;\n}\nfunction isDehydratedDeferred(obj) {\n  return typeof obj === 'object' && obj !== null && !(obj instanceof Promise) && !obj.then && '__deferredState' in obj;\n}\n\nfunction useAwaited({\n  promise\n}) {\n  const router = useRouter();\n  let state = promise.__deferredState;\n  const key = `__TSR__DEFERRED__${state.uid}`;\n  if (isDehydratedDeferred(promise)) {\n    state = router.hydrateData(key);\n    promise = Promise.resolve(state.data);\n    promise.__deferredState = state;\n  }\n  if (state.status === 'pending') {\n    throw new Promise(r => setTimeout(r, 1)).then(() => promise);\n  }\n  if (state.status === 'error') {\n    throw state.error;\n  }\n  router.dehydrateData(key, state);\n  return [state.data];\n}\nfunction Await(props) {\n  const awaited = useAwaited(props);\n  return props.children(...awaited);\n}\n\nfunction joinPaths(paths) {\n  return cleanPath(paths.filter(Boolean).join('/'));\n}\nfunction cleanPath(path) {\n  // remove double slashes\n  return path.replace(/\\/{2,}/g, '/');\n}\nfunction trimPathLeft(path) {\n  return path === '/' ? path : path.replace(/^\\/{1,}/, '');\n}\nfunction trimPathRight(path) {\n  return path === '/' ? path : path.replace(/\\/{1,}$/, '');\n}\nfunction trimPath(path) {\n  return trimPathRight(trimPathLeft(path));\n}\nfunction resolvePath(basepath, base, to) {\n  base = base.replace(new RegExp(`^${basepath}`), '/');\n  to = to.replace(new RegExp(`^${basepath}`), '/');\n  let baseSegments = parsePathname(base);\n  const toSegments = parsePathname(to);\n  toSegments.forEach((toSegment, index) => {\n    if (toSegment.value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment];\n      } else if (index === toSegments.length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment);\n      } else ;\n    } else if (toSegment.value === '..') {\n      // Extra trailing slash? pop it off\n      if (baseSegments.length > 1 && last(baseSegments)?.value === '/') {\n        baseSegments.pop();\n      }\n      baseSegments.pop();\n    } else if (toSegment.value === '.') {\n      return;\n    } else {\n      baseSegments.push(toSegment);\n    }\n  });\n  const joined = joinPaths([basepath, ...baseSegments.map(d => d.value)]);\n  return cleanPath(joined);\n}\nfunction parsePathname(pathname) {\n  if (!pathname) {\n    return [];\n  }\n  pathname = cleanPath(pathname);\n  const segments = [];\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1);\n    segments.push({\n      type: 'pathname',\n      value: '/'\n    });\n  }\n  if (!pathname) {\n    return segments;\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean);\n  segments.push(...split.map(part => {\n    if (part === '$' || part === '*') {\n      return {\n        type: 'wildcard',\n        value: part\n      };\n    }\n    if (part.charAt(0) === '$') {\n      return {\n        type: 'param',\n        value: part\n      };\n    }\n    return {\n      type: 'pathname',\n      value: part\n    };\n  }));\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1);\n    segments.push({\n      type: 'pathname',\n      value: '/'\n    });\n  }\n  return segments;\n}\nfunction interpolatePath(path, params, leaveWildcards = false) {\n  const interpolatedPathSegments = parsePathname(path);\n  return joinPaths(interpolatedPathSegments.map(segment => {\n    if (segment.type === 'wildcard') {\n      const value = params[segment.value];\n      if (leaveWildcards) return `${segment.value}${value ?? ''}`;\n      return value;\n    }\n    if (segment.type === 'param') {\n      return params[segment.value.substring(1)] ?? 'undefined';\n    }\n    return segment.value;\n  }));\n}\nfunction matchPathname(basepath, currentPathname, matchLocation) {\n  const pathParams = matchByPath(basepath, currentPathname, matchLocation);\n  // const searchMatched = matchBySearch(location.search, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return;\n  }\n  return pathParams ?? {};\n}\nfunction removeBasepath(basepath, pathname) {\n  return basepath != '/' ? pathname.substring(basepath.length) : pathname;\n}\nfunction matchByPath(basepath, from, matchLocation) {\n  // Remove the base path from the pathname\n  from = removeBasepath(basepath, from);\n  // Default to to $ (wildcard)\n  const to = `${matchLocation.to ?? '$'}`;\n  // Parse the from and to\n  const baseSegments = parsePathname(from);\n  const routeSegments = parsePathname(to);\n  if (!from.startsWith('/')) {\n    baseSegments.unshift({\n      type: 'pathname',\n      value: '/'\n    });\n  }\n  if (!to.startsWith('/')) {\n    routeSegments.unshift({\n      type: 'pathname',\n      value: '/'\n    });\n  }\n  const params = {};\n  let isMatch = (() => {\n    for (let i = 0; i < Math.max(baseSegments.length, routeSegments.length); i++) {\n      const baseSegment = baseSegments[i];\n      const routeSegment = routeSegments[i];\n      const isLastBaseSegment = i >= baseSegments.length - 1;\n      const isLastRouteSegment = i >= routeSegments.length - 1;\n      if (routeSegment) {\n        if (routeSegment.type === 'wildcard') {\n          if (baseSegment?.value) {\n            params['*'] = joinPaths(baseSegments.slice(i).map(d => d.value));\n            return true;\n          }\n          return false;\n        }\n        if (routeSegment.type === 'pathname') {\n          if (routeSegment.value === '/' && !baseSegment?.value) {\n            return true;\n          }\n          if (baseSegment) {\n            if (matchLocation.caseSensitive) {\n              if (routeSegment.value !== baseSegment.value) {\n                return false;\n              }\n            } else if (routeSegment.value.toLowerCase() !== baseSegment.value.toLowerCase()) {\n              return false;\n            }\n          }\n        }\n        if (!baseSegment) {\n          return false;\n        }\n        if (routeSegment.type === 'param') {\n          if (baseSegment?.value === '/') {\n            return false;\n          }\n          if (baseSegment.value.charAt(0) !== '$') {\n            params[routeSegment.value.substring(1)] = baseSegment.value;\n          }\n        }\n      }\n      if (!isLastBaseSegment && isLastRouteSegment) {\n        params['**'] = joinPaths(baseSegments.slice(i + 1).map(d => d.value));\n        return !!matchLocation.fuzzy && routeSegment?.value !== '/';\n      }\n    }\n    return true;\n  })();\n  return isMatch ? params : undefined;\n}\n\nfunction useParams(opts) {\n  return useRouterState({\n    select: state => {\n      const params = last(state.matches)?.params;\n      return opts?.select ? opts.select(params) : params;\n    }\n  });\n}\n\nfunction useSearch(opts) {\n  return useMatch({\n    ...opts,\n    select: match => {\n      return opts?.select ? opts.select(match.search) : match.search;\n    }\n  });\n}\n\nconst rootRouteId = '__root__';\n\n// The parse type here allows a zod schema to be passed directly to the validator\n\nclass RouteApi {\n  constructor({\n    id\n  }) {\n    this.id = id;\n  }\n  useMatch = opts => {\n    return useMatch({\n      ...opts,\n      from: this.id\n    });\n  };\n  useRouteContext = opts => {\n    return useMatch({\n      ...opts,\n      from: this.id,\n      select: d => opts?.select ? opts.select(d.context) : d.context\n    });\n  };\n  useSearch = opts => {\n    return useSearch({\n      ...opts,\n      from: this.id\n    });\n  };\n  useParams = opts => {\n    return useParams({\n      ...opts,\n      from: this.id\n    });\n  };\n  useLoaderDeps = opts => {\n    return useLoaderDeps({\n      ...opts,\n      from: this.id\n    });\n  };\n  useLoaderData = opts => {\n    return useLoaderData({\n      ...opts,\n      from: this.id\n    });\n  };\n}\nclass Route {\n  // Set up in this.init()\n\n  // customId!: TCustomId\n\n  // Optional\n\n  constructor(options) {\n    this.options = options || {};\n    this.isRoot = !options?.getParentRoute;\n    invariant(!(options?.id && options?.path), `Route cannot have both an 'id' and a 'path' option.`);\n    this.$$typeof = Symbol.for('react.memo');\n  }\n  init = opts => {\n    this.originalIndex = opts.originalIndex;\n    const options = this.options;\n    const isRoot = !options?.path && !options?.id;\n    this.parentRoute = this.options?.getParentRoute?.();\n    if (isRoot) {\n      this.path = rootRouteId;\n    } else {\n      invariant(this.parentRoute, `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`);\n    }\n    let path = isRoot ? rootRouteId : options.path;\n\n    // If the path is anything other than an index path, trim it up\n    if (path && path !== '/') {\n      path = trimPath(path);\n    }\n    const customId = options?.id || path;\n\n    // Strip the parentId prefix from the first level of children\n    let id = isRoot ? rootRouteId : joinPaths([this.parentRoute.id === rootRouteId ? '' : this.parentRoute.id, customId]);\n    if (path === rootRouteId) {\n      path = '/';\n    }\n    if (id !== rootRouteId) {\n      id = joinPaths(['/', id]);\n    }\n    const fullPath = id === rootRouteId ? '/' : joinPaths([this.parentRoute.fullPath, path]);\n    this.path = path;\n    this.id = id;\n    // this.customId = customId as TCustomId\n    this.fullPath = fullPath;\n    this.to = fullPath;\n  };\n  addChildren = children => {\n    this.children = children;\n    return this;\n  };\n  update = options => {\n    Object.assign(this.options, options);\n    return this;\n  };\n  useMatch = opts => {\n    return useMatch({\n      ...opts,\n      from: this.id\n    });\n  };\n  useRouteContext = opts => {\n    return useMatch({\n      ...opts,\n      from: this.id,\n      select: d => opts?.select ? opts.select(d.context) : d.context\n    });\n  };\n  useSearch = opts => {\n    return useSearch({\n      ...opts,\n      from: this.id\n    });\n  };\n  useParams = opts => {\n    return useParams({\n      ...opts,\n      from: this.id\n    });\n  };\n  useLoaderDeps = opts => {\n    return useLoaderDeps({\n      ...opts,\n      from: this.id\n    });\n  };\n  useLoaderData = opts => {\n    return useLoaderData({\n      ...opts,\n      from: this.id\n    });\n  };\n}\nfunction rootRouteWithContext() {\n  return options => {\n    return new RootRoute(options);\n  };\n}\nclass RootRoute extends Route {\n  constructor(options) {\n    super(options);\n  }\n}\nfunction createRouteMask(opts) {\n  return opts;\n}\n\n//\n\nclass NotFoundRoute extends Route {\n  constructor(options) {\n    super({\n      ...options,\n      id: '404'\n    });\n  }\n}\n\nclass FileRoute {\n  constructor(path) {\n    this.path = path;\n  }\n  createRoute = options => {\n    const route = new Route(options);\n    route.isRoot = false;\n    return route;\n  };\n}\n\nfunction lazyRouteComponent(importer, exportName) {\n  let loadPromise;\n  const load = () => {\n    if (!loadPromise) {\n      loadPromise = importer();\n    }\n    return loadPromise;\n  };\n  const lazyComp = /*#__PURE__*/React.lazy(async () => {\n    const moduleExports = await load();\n    const comp = moduleExports[exportName ?? 'default'];\n    return {\n      default: comp\n    };\n  });\n  lazyComp.preload = load;\n  return lazyComp;\n}\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nconst preloadWarning = 'Error preloading route! â˜ï¸';\nfunction useLinkProps(options) {\n  const router = useRouter();\n  const matchPathname = useMatch({\n    strict: false,\n    select: s => s.pathname\n  });\n  const {\n    // custom props\n    children,\n    target,\n    activeProps = () => ({\n      className: 'active'\n    }),\n    inactiveProps = () => ({}),\n    activeOptions,\n    disabled,\n    hash,\n    search,\n    params,\n    to,\n    state,\n    mask,\n    preload: userPreload,\n    preloadDelay: userPreloadDelay,\n    replace,\n    startTransition,\n    resetScroll,\n    // element props\n    style,\n    className,\n    onClick,\n    onFocus,\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart,\n    ...rest\n  } = options;\n\n  // If this link simply reloads the current route,\n  // make sure it has a new key so it will trigger a data refresh\n\n  // If this `to` is a valid external URL, return\n  // null for LinkUtils\n\n  const dest = {\n    from: options.to ? matchPathname : undefined,\n    ...options\n  };\n  let type = 'internal';\n  try {\n    new URL(`${to}`);\n    type = 'external';\n  } catch {}\n  if (type === 'external') {\n    return {\n      href: to\n    };\n  }\n  const next = router.buildLocation(dest);\n  const preload = userPreload ?? router.options.defaultPreload;\n  const preloadDelay = userPreloadDelay ?? router.options.defaultPreloadDelay ?? 0;\n  const isActive = useRouterState({\n    select: s => {\n      // Compare path/hash for matches\n      const currentPathSplit = s.location.pathname.split('/');\n      const nextPathSplit = next.pathname.split('/');\n      const pathIsFuzzyEqual = nextPathSplit.every((d, i) => d === currentPathSplit[i]);\n      // Combine the matches based on user router.options\n      const pathTest = activeOptions?.exact ? s.location.pathname === next.pathname : pathIsFuzzyEqual;\n      const hashTest = activeOptions?.includeHash ? s.location.hash === next.hash : true;\n      const searchTest = activeOptions?.includeSearch ?? true ? deepEqual(s.location.search, next.search, !activeOptions?.exact) : true;\n\n      // The final \"active\" test\n      return pathTest && hashTest && searchTest;\n    }\n  });\n\n  // The click handler\n  const handleClick = e => {\n    if (!disabled && !isCtrlEvent(e) && !e.defaultPrevented && (!target || target === '_self') && e.button === 0) {\n      e.preventDefault();\n\n      // All is well? Navigate!\n      router.commitLocation({\n        ...next,\n        replace,\n        resetScroll,\n        startTransition\n      });\n    }\n  };\n\n  // The click handler\n  const handleFocus = e => {\n    if (preload) {\n      router.preloadRoute(dest).catch(err => {\n        console.warn(err);\n        console.warn(preloadWarning);\n      });\n    }\n  };\n  const handleTouchStart = e => {\n    if (preload) {\n      router.preloadRoute(dest).catch(err => {\n        console.warn(err);\n        console.warn(preloadWarning);\n      });\n    }\n  };\n  const handleEnter = e => {\n    const target = e.target || {};\n    if (preload) {\n      if (target.preloadTimeout) {\n        return;\n      }\n      target.preloadTimeout = setTimeout(() => {\n        target.preloadTimeout = null;\n        router.preloadRoute(dest).catch(err => {\n          console.warn(err);\n          console.warn(preloadWarning);\n        });\n      }, preloadDelay);\n    }\n  };\n  const handleLeave = e => {\n    const target = e.target || {};\n    if (target.preloadTimeout) {\n      clearTimeout(target.preloadTimeout);\n      target.preloadTimeout = null;\n    }\n  };\n  const composeHandlers = handlers => e => {\n    if (e.persist) e.persist();\n    handlers.filter(Boolean).forEach(handler => {\n      if (e.defaultPrevented) return;\n      handler(e);\n    });\n  };\n\n  // Get the active props\n  const resolvedActiveProps = isActive ? functionalUpdate(activeProps, {}) ?? {} : {};\n\n  // Get the inactive props\n  const resolvedInactiveProps = isActive ? {} : functionalUpdate(inactiveProps, {}) ?? {};\n  return {\n    ...resolvedActiveProps,\n    ...resolvedInactiveProps,\n    ...rest,\n    href: disabled ? undefined : next.maskedLocation ? next.maskedLocation.href : next.href,\n    onClick: composeHandlers([onClick, handleClick]),\n    onFocus: composeHandlers([onFocus, handleFocus]),\n    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),\n    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),\n    onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),\n    target,\n    style: {\n      ...style,\n      ...resolvedActiveProps.style,\n      ...resolvedInactiveProps.style\n    },\n    className: [className, resolvedActiveProps.className, resolvedInactiveProps.className].filter(Boolean).join(' ') || undefined,\n    ...(disabled ? {\n      role: 'link',\n      'aria-disabled': true\n    } : undefined),\n    ['data-status']: isActive ? 'active' : undefined\n  };\n}\nconst Link = /*#__PURE__*/React.forwardRef((props, ref) => {\n  const linkProps = useLinkProps(props);\n  return /*#__PURE__*/React.createElement(\"a\", _extends({\n    ref: ref\n  }, linkProps, {\n    children: typeof props.children === 'function' ? props.children({\n      isActive: linkProps['data-status'] === 'active'\n    }) : props.children\n  }));\n});\nfunction isCtrlEvent(e) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n}\n\n// @ts-nocheck\n\n// qss has been slightly modified and inlined here for our use cases (and compression's sake). We've included it as a hard dependency for MIT license attribution.\n\nfunction encode(obj, pfx) {\n  var k,\n    i,\n    tmp,\n    str = '';\n  for (k in obj) {\n    if ((tmp = obj[k]) !== void 0) {\n      if (Array.isArray(tmp)) {\n        for (i = 0; i < tmp.length; i++) {\n          str && (str += '&');\n          str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp[i]);\n        }\n      } else {\n        str && (str += '&');\n        str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp);\n      }\n    }\n  }\n  return (pfx || '') + str;\n}\nfunction toValue(mix) {\n  if (!mix) return '';\n  var str = decodeURIComponent(mix);\n  if (str === 'false') return false;\n  if (str === 'true') return true;\n  return +str * 0 === 0 && +str + '' === str ? +str : str;\n}\nfunction decode(str) {\n  var tmp,\n    k,\n    out = {},\n    arr = str.split('&');\n  while (tmp = arr.shift()) {\n    tmp = tmp.split('=');\n    k = tmp.shift();\n    if (out[k] !== void 0) {\n      out[k] = [].concat(out[k], toValue(tmp.shift()));\n    } else {\n      out[k] = toValue(tmp.shift());\n    }\n  }\n  return out;\n}\n\n// Detect if we're in the DOM\n\nfunction redirect(opts) {\n  opts.isRedirect = true;\n  if (opts.throw) {\n    throw opts;\n  }\n  return opts;\n}\nfunction isRedirect(obj) {\n  return !!obj?.isRedirect;\n}\n\nconst defaultParseSearch = parseSearchWith(JSON.parse);\nconst defaultStringifySearch = stringifySearchWith(JSON.stringify, JSON.parse);\nfunction parseSearchWith(parser) {\n  return searchStr => {\n    if (searchStr.substring(0, 1) === '?') {\n      searchStr = searchStr.substring(1);\n    }\n    let query = decode(searchStr);\n\n    // Try to parse any query params that might be json\n    for (let key in query) {\n      const value = query[key];\n      if (typeof value === 'string') {\n        try {\n          query[key] = parser(value);\n        } catch (err) {\n          //\n        }\n      }\n    }\n    return query;\n  };\n}\nfunction stringifySearchWith(stringify, parser) {\n  function stringifyValue(val) {\n    if (typeof val === 'object' && val !== null) {\n      try {\n        return stringify(val);\n      } catch (err) {\n        // silent\n      }\n    } else if (typeof val === 'string' && typeof parser === 'function') {\n      try {\n        // Check if it's a valid parseable string.\n        // If it is, then stringify it again.\n        parser(val);\n        return stringify(val);\n      } catch (err) {\n        // silent\n      }\n    }\n    return val;\n  }\n  return search => {\n    search = {\n      ...search\n    };\n    if (search) {\n      Object.keys(search).forEach(key => {\n        const val = search[key];\n        if (typeof val === 'undefined' || val === undefined) {\n          delete search[key];\n        } else {\n          search[key] = stringifyValue(val);\n        }\n      });\n    }\n    const searchStr = encode(search).toString();\n    return searchStr ? `?${searchStr}` : '';\n  };\n}\n\n// import warning from 'tiny-warning'\n\n//\n\nconst componentTypes = ['component', 'errorComponent', 'pendingComponent'];\nclass Router {\n  // Option-independent properties\n  tempLocationKey = `${Math.round(Math.random() * 10000000)}`;\n  resetNextScroll = true;\n  navigateTimeout = null;\n  latestLoadPromise = Promise.resolve();\n  subscribers = new Set();\n  injectedHtml = [];\n\n  // Must build in constructor\n\n  constructor(options) {\n    this.update({\n      defaultPreloadDelay: 50,\n      defaultPendingMs: 1000,\n      defaultPendingMinMs: 500,\n      context: undefined,\n      ...options,\n      stringifySearch: options?.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options?.parseSearch ?? defaultParseSearch\n    });\n  }\n\n  // These are default implementations that can optionally be overridden\n  // by the router provider once rendered. We provide these so that the\n  // router can be used in a non-react environment if necessary\n  startReactTransition = fn => fn();\n  update = newOptions => {\n    this.options = {\n      ...this.options,\n      ...newOptions\n    };\n    this.basepath = `/${trimPath(newOptions.basepath ?? '') ?? ''}`;\n    if (!this.history || this.options.history && this.options.history !== this.history) {\n      this.history = this.options.history ?? (typeof document !== 'undefined' ? createBrowserHistory() : createMemoryHistory());\n      this.latestLocation = this.parseLocation();\n    }\n    if (this.options.routeTree !== this.routeTree) {\n      this.routeTree = this.options.routeTree;\n      this.buildRouteTree();\n    }\n    if (!this.__store) {\n      this.__store = new Store(getInitialRouterState(this.latestLocation), {\n        onUpdate: () => {\n          this.__store.state = {\n            ...this.state,\n            status: this.state.isTransitioning || this.state.isLoading ? 'pending' : 'idle'\n          };\n        }\n      });\n    }\n  };\n  get state() {\n    return this.__store.state;\n  }\n  buildRouteTree = () => {\n    this.routesById = {};\n    this.routesByPath = {};\n    const notFoundRoute = this.options.notFoundRoute;\n    if (notFoundRoute) {\n      notFoundRoute.init({\n        originalIndex: 99999999999\n      });\n      this.routesById[notFoundRoute.id] = notFoundRoute;\n    }\n    const recurseRoutes = childRoutes => {\n      childRoutes.forEach((childRoute, i) => {\n        childRoute.init({\n          originalIndex: i\n        });\n        const existingRoute = this.routesById[childRoute.id];\n        invariant(!existingRoute, `Duplicate routes found with id: ${String(childRoute.id)}`);\n        this.routesById[childRoute.id] = childRoute;\n        if (!childRoute.isRoot && childRoute.path) {\n          const trimmedFullPath = trimPathRight(childRoute.fullPath);\n          if (!this.routesByPath[trimmedFullPath] || childRoute.fullPath.endsWith('/')) {\n            this.routesByPath[trimmedFullPath] = childRoute;\n          }\n        }\n        const children = childRoute.children;\n        if (children?.length) {\n          recurseRoutes(children);\n        }\n      });\n    };\n    recurseRoutes([this.routeTree]);\n    const scoredRoutes = [];\n    Object.values(this.routesById).forEach((d, i) => {\n      if (d.isRoot || !d.path) {\n        return;\n      }\n      const trimmed = trimPathLeft(d.fullPath);\n      const parsed = parsePathname(trimmed);\n      while (parsed.length > 1 && parsed[0]?.value === '/') {\n        parsed.shift();\n      }\n      const scores = parsed.map(d => {\n        if (d.value === '/') {\n          return 0.75;\n        }\n        if (d.type === 'param') {\n          return 0.5;\n        }\n        if (d.type === 'wildcard') {\n          return 0.25;\n        }\n        return 1;\n      });\n      scoredRoutes.push({\n        child: d,\n        trimmed,\n        parsed,\n        index: i,\n        scores\n      });\n    });\n    this.flatRoutes = scoredRoutes.sort((a, b) => {\n      const minLength = Math.min(a.scores.length, b.scores.length);\n\n      // Sort by min available score\n      for (let i = 0; i < minLength; i++) {\n        if (a.scores[i] !== b.scores[i]) {\n          return b.scores[i] - a.scores[i];\n        }\n      }\n\n      // Sort by length of score\n      if (a.scores.length !== b.scores.length) {\n        return b.scores.length - a.scores.length;\n      }\n\n      // Sort by min available parsed value\n      for (let i = 0; i < minLength; i++) {\n        if (a.parsed[i].value !== b.parsed[i].value) {\n          return a.parsed[i].value > b.parsed[i].value ? 1 : -1;\n        }\n      }\n\n      // Sort by original index\n      return a.index - b.index;\n    }).map((d, i) => {\n      d.child.rank = i;\n      return d.child;\n    });\n  };\n  subscribe = (eventType, fn) => {\n    const listener = {\n      eventType,\n      fn\n    };\n    this.subscribers.add(listener);\n    return () => {\n      this.subscribers.delete(listener);\n    };\n  };\n  emit = routerEvent => {\n    this.subscribers.forEach(listener => {\n      if (listener.eventType === routerEvent.type) {\n        listener.fn(routerEvent);\n      }\n    });\n  };\n  checkLatest = promise => {\n    return this.latestLoadPromise !== promise ? this.latestLoadPromise : undefined;\n  };\n  parseLocation = previousLocation => {\n    const parse = ({\n      pathname,\n      search,\n      hash,\n      state\n    }) => {\n      const parsedSearch = this.options.parseSearch(search);\n      return {\n        pathname: pathname,\n        searchStr: search,\n        search: replaceEqualDeep(previousLocation?.search, parsedSearch),\n        hash: hash.split('#').reverse()[0] ?? '',\n        href: `${pathname}${search}${hash}`,\n        state: replaceEqualDeep(previousLocation?.state, state)\n      };\n    };\n    const location = parse(this.history.location);\n    let {\n      __tempLocation,\n      __tempKey\n    } = location.state;\n    if (__tempLocation && (!__tempKey || __tempKey === this.tempLocationKey)) {\n      // Sync up the location keys\n      const parsedTempLocation = parse(__tempLocation);\n      parsedTempLocation.state.key = location.state.key;\n      delete parsedTempLocation.state.__tempLocation;\n      return {\n        ...parsedTempLocation,\n        maskedLocation: location\n      };\n    }\n    return location;\n  };\n  resolvePathWithBase = (from, path) => {\n    return resolvePath(this.basepath, from, cleanPath(path));\n  };\n  get looseRoutesById() {\n    return this.routesById;\n  }\n  matchRoutes = (pathname, locationSearch, opts) => {\n    let routeParams = {};\n    let foundRoute = this.flatRoutes.find(route => {\n      const matchedParams = matchPathname(this.basepath, trimPathRight(pathname), {\n        to: route.fullPath,\n        caseSensitive: route.options.caseSensitive ?? this.options.caseSensitive,\n        fuzzy: true\n      });\n      if (matchedParams) {\n        routeParams = matchedParams;\n        return true;\n      }\n      return false;\n    });\n    let routeCursor = foundRoute || this.routesById['__root__'];\n    let matchedRoutes = [routeCursor];\n\n    // Check to see if the route needs a 404 entry\n    if (\n    // If we found a route, and it's not an index route and we have left over path\n    (foundRoute ? foundRoute.path !== '/' && routeParams['**'] :\n    // Or if we didn't find a route and we have left over path\n    trimPathRight(pathname)) &&\n    // And we have a 404 route configured\n    this.options.notFoundRoute) {\n      matchedRoutes.push(this.options.notFoundRoute);\n    }\n    while (routeCursor?.parentRoute) {\n      routeCursor = routeCursor.parentRoute;\n      if (routeCursor) matchedRoutes.unshift(routeCursor);\n    }\n\n    // Existing matches are matches that are already loaded along with\n    // pending matches that are still loading\n\n    const parseErrors = matchedRoutes.map(route => {\n      let parsedParamsError;\n      if (route.options.parseParams) {\n        try {\n          const parsedParams = route.options.parseParams(routeParams);\n          // Add the parsed params to the accumulated params bag\n          Object.assign(routeParams, parsedParams);\n        } catch (err) {\n          parsedParamsError = new PathParamError(err.message, {\n            cause: err\n          });\n          if (opts?.throwOnError) {\n            throw parsedParamsError;\n          }\n          return parsedParamsError;\n        }\n      }\n      return;\n    });\n    const matches = [];\n    matchedRoutes.forEach((route, index) => {\n      // Take each matched route and resolve + validate its search params\n      // This has to happen serially because each route's search params\n      // can depend on the parent route's search params\n      // It must also happen before we create the match so that we can\n      // pass the search params to the route's potential key function\n      // which is used to uniquely identify the route match in state\n\n      const parentMatch = matches[index - 1];\n      const [preMatchSearch, searchError] = (() => {\n        // Validate the search params and stabilize them\n        const parentSearch = parentMatch?.search ?? locationSearch;\n        try {\n          const validator = typeof route.options.validateSearch === 'object' ? route.options.validateSearch.parse : route.options.validateSearch;\n          let search = validator?.(parentSearch) ?? {};\n          return [{\n            ...parentSearch,\n            ...search\n          }, undefined];\n        } catch (err) {\n          const searchError = new SearchParamError(err.message, {\n            cause: err\n          });\n          if (opts?.throwOnError) {\n            throw searchError;\n          }\n          return [parentSearch, searchError];\n        }\n      })();\n\n      // This is where we need to call route.options.loaderDeps() to get any additional\n      // deps that the route's loader function might need to run. We need to do this\n      // before we create the match so that we can pass the deps to the route's\n      // potential key function which is used to uniquely identify the route match in state\n\n      const loaderDeps = route.options.loaderDeps?.({\n        search: preMatchSearch\n      }) ?? '';\n      const loaderDepsHash = loaderDeps ? JSON.stringify(loaderDeps) : '';\n      const interpolatedPath = interpolatePath(route.fullPath, routeParams);\n      const matchId = interpolatePath(route.id, routeParams, true) + loaderDepsHash;\n\n      // Waste not, want not. If we already have a match for this route,\n      // reuse it. This is important for layout routes, which might stick\n      // around between navigation actions that only change leaf routes.\n      const existingMatch = getRouteMatch(this.state, matchId);\n      const cause = this.state.matches.find(d => d.id === matchId) ? 'stay' : 'enter';\n\n      // Create a fresh route match\n      const hasLoaders = !!(route.options.loader || componentTypes.some(d => route.options[d]?.preload));\n      const match = existingMatch ? {\n        ...existingMatch,\n        cause\n      } : {\n        id: matchId,\n        routeId: route.id,\n        params: routeParams,\n        pathname: joinPaths([this.basepath, interpolatedPath]),\n        updatedAt: Date.now(),\n        search: {},\n        searchError: undefined,\n        status: hasLoaders ? 'pending' : 'success',\n        showPending: false,\n        isFetching: false,\n        error: undefined,\n        paramsError: parseErrors[index],\n        loadPromise: Promise.resolve(),\n        routeContext: undefined,\n        context: undefined,\n        abortController: new AbortController(),\n        fetchCount: 0,\n        cause,\n        loaderDeps,\n        invalid: false,\n        preload: false\n      };\n\n      // Regardless of whether we're reusing an existing match or creating\n      // a new one, we need to update the match's search params\n      match.search = replaceEqualDeep(match.search, preMatchSearch);\n      // And also update the searchError if there is one\n      match.searchError = searchError;\n      matches.push(match);\n    });\n    return matches;\n  };\n  cancelMatch = id => {\n    getRouteMatch(this.state, id)?.abortController?.abort();\n  };\n  cancelMatches = () => {\n    this.state.pendingMatches?.forEach(match => {\n      this.cancelMatch(match.id);\n    });\n  };\n  buildLocation = opts => {\n    const build = (dest = {}, matches) => {\n      const from = this.latestLocation;\n      const fromSearch = (this.state.pendingMatches || this.state.matches).at(-1)?.search || from.search;\n      const fromPathname = dest.from ?? from.pathname;\n      let pathname = this.resolvePathWithBase(fromPathname, `${dest.to ?? ''}`);\n      const fromMatches = this.matchRoutes(fromPathname, fromSearch);\n      const stayingMatches = matches?.filter(d => fromMatches?.find(e => e.routeId === d.routeId));\n      const prevParams = {\n        ...last(fromMatches)?.params\n      };\n      let nextParams = (dest.params ?? true) === true ? prevParams : functionalUpdate(dest.params, prevParams);\n      if (nextParams) {\n        matches?.map(d => this.looseRoutesById[d.routeId].options.stringifyParams).filter(Boolean).forEach(fn => {\n          nextParams = {\n            ...nextParams,\n            ...fn(nextParams)\n          };\n        });\n      }\n      pathname = interpolatePath(pathname, nextParams ?? {});\n      const preSearchFilters = stayingMatches?.map(match => this.looseRoutesById[match.routeId].options.preSearchFilters ?? []).flat().filter(Boolean) ?? [];\n      const postSearchFilters = stayingMatches?.map(match => this.looseRoutesById[match.routeId].options.postSearchFilters ?? []).flat().filter(Boolean) ?? [];\n\n      // Pre filters first\n      const preFilteredSearch = preSearchFilters?.length ? preSearchFilters?.reduce((prev, next) => next(prev), fromSearch) : fromSearch;\n\n      // Then the link/navigate function\n      const destSearch = dest.search === true ? preFilteredSearch // Preserve resolvedFrom true\n      : dest.search ? functionalUpdate(dest.search, preFilteredSearch) ?? {} // Updater\n      : preSearchFilters?.length ? preFilteredSearch // Preserve resolvedFrom filters\n      : {};\n\n      // Then post filters\n      const postFilteredSearch = postSearchFilters?.length ? postSearchFilters.reduce((prev, next) => next(prev), destSearch) : destSearch;\n      const search = replaceEqualDeep(fromSearch, postFilteredSearch);\n      const searchStr = this.options.stringifySearch(search);\n      const hash = dest.hash === true ? from.hash : dest.hash ? functionalUpdate(dest.hash, from.hash) : from.hash;\n      const hashStr = hash ? `#${hash}` : '';\n      let nextState = dest.state === true ? from.state : dest.state ? functionalUpdate(dest.state, from.state) : from.state;\n      nextState = replaceEqualDeep(from.state, nextState);\n      return {\n        pathname,\n        search,\n        searchStr,\n        state: nextState,\n        hash,\n        href: `${pathname}${searchStr}${hashStr}`,\n        unmaskOnReload: dest.unmaskOnReload\n      };\n    };\n    const buildWithMatches = (dest = {}, maskedDest) => {\n      let next = build(dest);\n      let maskedNext = maskedDest ? build(maskedDest) : undefined;\n      if (!maskedNext) {\n        let params = {};\n        let foundMask = this.options.routeMasks?.find(d => {\n          const match = matchPathname(this.basepath, next.pathname, {\n            to: d.from,\n            caseSensitive: false,\n            fuzzy: false\n          });\n          if (match) {\n            params = match;\n            return true;\n          }\n          return false;\n        });\n        if (foundMask) {\n          foundMask = {\n            ...foundMask,\n            from: interpolatePath(foundMask.from, params)\n          };\n          maskedDest = foundMask;\n          maskedNext = build(maskedDest);\n        }\n      }\n      const nextMatches = this.matchRoutes(next.pathname, next.search);\n      const maskedMatches = maskedNext ? this.matchRoutes(maskedNext.pathname, maskedNext.search) : undefined;\n      const maskedFinal = maskedNext ? build(maskedDest, maskedMatches) : undefined;\n      const final = build(dest, nextMatches);\n      if (maskedFinal) {\n        final.maskedLocation = maskedFinal;\n      }\n      return final;\n    };\n    if (opts.mask) {\n      return buildWithMatches(opts, {\n        ...pick(opts, ['from']),\n        ...opts.mask\n      });\n    }\n    return buildWithMatches(opts);\n  };\n  commitLocation = async ({\n    startTransition,\n    ...next\n  }) => {\n    if (this.navigateTimeout) clearTimeout(this.navigateTimeout);\n    const isSameUrl = this.latestLocation.href === next.href;\n\n    // If the next urls are the same and we're not replacing,\n    // do nothing\n    if (!isSameUrl || !next.replace) {\n      let {\n        maskedLocation,\n        ...nextHistory\n      } = next;\n      if (maskedLocation) {\n        nextHistory = {\n          ...maskedLocation,\n          state: {\n            ...maskedLocation.state,\n            __tempKey: undefined,\n            __tempLocation: {\n              ...nextHistory,\n              search: nextHistory.searchStr,\n              state: {\n                ...nextHistory.state,\n                __tempKey: undefined,\n                __tempLocation: undefined,\n                key: undefined\n              }\n            }\n          }\n        };\n        if (nextHistory.unmaskOnReload ?? this.options.unmaskOnReload ?? false) {\n          nextHistory.state.__tempKey = this.tempLocationKey;\n        }\n      }\n      const apply = () => {\n        this.history[next.replace ? 'replace' : 'push'](nextHistory.href, nextHistory.state);\n      };\n      if (startTransition ?? true) {\n        this.startReactTransition(apply);\n      } else {\n        apply();\n      }\n    }\n    this.resetNextScroll = next.resetScroll ?? true;\n    return this.latestLoadPromise;\n  };\n  buildAndCommitLocation = ({\n    replace,\n    resetScroll,\n    startTransition,\n    ...rest\n  } = {}) => {\n    const location = this.buildLocation(rest);\n    return this.commitLocation({\n      ...location,\n      startTransition,\n      replace,\n      resetScroll\n    });\n  };\n  navigate = ({\n    from,\n    to = '',\n    ...rest\n  }) => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n    const toString = String(to);\n    const fromString = typeof from === 'undefined' ? from : String(from);\n    let isExternal;\n    try {\n      new URL(`${toString}`);\n      isExternal = true;\n    } catch (e) {}\n    invariant(!isExternal, 'Attempting to navigate to external url with this.navigate!');\n    return this.buildAndCommitLocation({\n      ...rest,\n      from: fromString,\n      to: toString\n    });\n  };\n  loadMatches = async ({\n    checkLatest,\n    matches,\n    preload\n  }) => {\n    let latestPromise;\n    let firstBadMatchIndex;\n    const updateMatch = match => {\n      // const isPreload = this.state.cachedMatches.find((d) => d.id === match.id)\n      const isPending = this.state.pendingMatches?.find(d => d.id === match.id);\n      const isMatched = this.state.matches.find(d => d.id === match.id);\n      const matchesKey = isPending ? 'pendingMatches' : isMatched ? 'matches' : 'cachedMatches';\n      this.__store.setState(s => ({\n        ...s,\n        [matchesKey]: s[matchesKey]?.map(d => d.id === match.id ? match : d)\n      }));\n    };\n\n    // Check each match middleware to see if the route can be accessed\n    try {\n      for (let [index, match] of matches.entries()) {\n        const parentMatch = matches[index - 1];\n        const route = this.looseRoutesById[match.routeId];\n        const abortController = new AbortController();\n        const handleErrorAndRedirect = (err, code) => {\n          err.routerCode = code;\n          firstBadMatchIndex = firstBadMatchIndex ?? index;\n          if (isRedirect(err)) {\n            throw err;\n          }\n          try {\n            route.options.onError?.(err);\n          } catch (errorHandlerErr) {\n            err = errorHandlerErr;\n            if (isRedirect(errorHandlerErr)) {\n              throw errorHandlerErr;\n            }\n          }\n          matches[index] = match = {\n            ...match,\n            error: err,\n            status: 'error',\n            updatedAt: Date.now(),\n            abortController: new AbortController()\n          };\n        };\n        try {\n          if (match.paramsError) {\n            handleErrorAndRedirect(match.paramsError, 'PARSE_PARAMS');\n          }\n          if (match.searchError) {\n            handleErrorAndRedirect(match.searchError, 'VALIDATE_SEARCH');\n          }\n          const parentContext = parentMatch?.context ?? this.options.context ?? {};\n          const beforeLoadContext = (await route.options.beforeLoad?.({\n            search: match.search,\n            abortController,\n            params: match.params,\n            preload: !!preload,\n            context: parentContext,\n            location: this.state.location,\n            // TOOD: just expose state and router, etc\n            navigate: opts => this.navigate({\n              ...opts,\n              from: match.pathname\n            }),\n            buildLocation: this.buildLocation,\n            cause: preload ? 'preload' : match.cause\n          })) ?? {};\n          if (isRedirect(beforeLoadContext)) {\n            throw beforeLoadContext;\n          }\n          const context = {\n            ...parentContext,\n            ...beforeLoadContext\n          };\n          matches[index] = match = {\n            ...match,\n            routeContext: replaceEqualDeep(match.routeContext, beforeLoadContext),\n            context: replaceEqualDeep(match.context, context),\n            abortController\n          };\n        } catch (err) {\n          handleErrorAndRedirect(err, 'BEFORE_LOAD');\n          break;\n        }\n      }\n    } catch (err) {\n      if (isRedirect(err)) {\n        if (!preload) this.navigate(err);\n        return matches;\n      }\n      throw err;\n    }\n    const validResolvedMatches = matches.slice(0, firstBadMatchIndex);\n    const matchPromises = [];\n    validResolvedMatches.forEach((match, index) => {\n      matchPromises.push(new Promise(async resolve => {\n        const parentMatchPromise = matchPromises[index - 1];\n        const route = this.looseRoutesById[match.routeId];\n        const handleErrorAndRedirect = err => {\n          if (isRedirect(err)) {\n            if (!preload) {\n              this.navigate(err);\n            }\n            return true;\n          }\n          return false;\n        };\n        let loadPromise;\n        matches[index] = match = {\n          ...match,\n          showPending: false\n        };\n        let didShowPending = false;\n        const pendingMs = route.options.pendingMs ?? this.options.defaultPendingMs;\n        const pendingMinMs = route.options.pendingMinMs ?? this.options.defaultPendingMinMs;\n        const shouldPending = !preload && pendingMs && (route.options.pendingComponent ?? this.options.defaultPendingComponent);\n        const loaderContext = {\n          params: match.params,\n          deps: match.loaderDeps,\n          preload: !!preload,\n          parentMatchPromise,\n          abortController: match.abortController,\n          context: match.context,\n          location: this.state.location,\n          navigate: opts => this.navigate({\n            ...opts,\n            from: match.pathname\n          }),\n          cause: preload ? 'preload' : match.cause\n        };\n        const fetch = async () => {\n          if (match.isFetching) {\n            loadPromise = getRouteMatch(this.state, match.id)?.loadPromise;\n          } else {\n            // If the user doesn't want the route to reload, just\n            // resolve with the existing loader data\n\n            if (match.fetchCount && match.status === 'success') {\n              resolve();\n            }\n\n            // Otherwise, load the route\n            matches[index] = match = {\n              ...match,\n              isFetching: true,\n              fetchCount: match.fetchCount + 1\n            };\n            const componentsPromise = Promise.all(componentTypes.map(async type => {\n              const component = route.options[type];\n              if (component?.preload) {\n                await component.preload();\n              }\n            }));\n            const loaderPromise = route.options.loader?.(loaderContext);\n            loadPromise = Promise.all([componentsPromise, loaderPromise]).then(d => d[1]);\n          }\n          matches[index] = match = {\n            ...match,\n            loadPromise\n          };\n          updateMatch(match);\n          try {\n            const loaderData = await loadPromise;\n            if (latestPromise = checkLatest()) return await latestPromise;\n            if (isRedirect(loaderData)) {\n              if (handleErrorAndRedirect(loaderData)) return;\n            }\n            if (didShowPending && pendingMinMs) {\n              await new Promise(r => setTimeout(r, pendingMinMs));\n            }\n            if (latestPromise = checkLatest()) return await latestPromise;\n            matches[index] = match = {\n              ...match,\n              error: undefined,\n              status: 'success',\n              isFetching: false,\n              updatedAt: Date.now(),\n              loaderData,\n              loadPromise: undefined\n            };\n          } catch (error) {\n            if (latestPromise = checkLatest()) return await latestPromise;\n            if (handleErrorAndRedirect(error)) return;\n            try {\n              route.options.onError?.(error);\n            } catch (onErrorError) {\n              error = onErrorError;\n              if (handleErrorAndRedirect(onErrorError)) return;\n            }\n            matches[index] = match = {\n              ...match,\n              error,\n              status: 'error',\n              isFetching: false\n            };\n          }\n          updateMatch(match);\n        };\n\n        // This is where all of the stale-while-revalidate magic happens\n        const age = Date.now() - match.updatedAt;\n        let staleAge = preload ? route.options.preloadStaleTime ?? this.options.defaultPreloadStaleTime ?? 30_000 // 30 seconds for preloads by default\n        : route.options.staleTime ?? this.options.defaultStaleTime ?? 0;\n\n        // Default to reloading the route all the time\n        let shouldReload;\n        const shouldReloadOption = route.options.shouldReload;\n\n        // Allow shouldReload to get the last say,\n        // if provided.\n        shouldReload = typeof shouldReloadOption === 'function' ? shouldReloadOption(loaderContext) : shouldReloadOption;\n        matches[index] = match = {\n          ...match,\n          preload: !!preload && !this.state.matches.find(d => d.id === match.id)\n        };\n        if (match.status !== 'success') {\n          // If we need to potentially show the pending component,\n          // start a timer to show it after the pendingMs\n          if (shouldPending) {\n            new Promise(r => setTimeout(r, pendingMs)).then(async () => {\n              if (latestPromise = checkLatest()) return latestPromise;\n              didShowPending = true;\n              matches[index] = match = {\n                ...match,\n                showPending: true\n              };\n              updateMatch(match);\n              resolve();\n            });\n          }\n\n          // Critical Fetching, we need to await\n          await fetch();\n        } else if (match.invalid || (shouldReload ?? age > staleAge)) {\n          // Background Fetching, no need to wait\n          fetch();\n        }\n        resolve();\n      }));\n    });\n    await Promise.all(matchPromises);\n    return matches;\n  };\n  invalidate = () => {\n    const invalidate = d => ({\n      ...d,\n      invalid: true\n    });\n    this.__store.setState(s => ({\n      ...s,\n      matches: s.matches.map(invalidate),\n      cachedMatches: s.cachedMatches.map(invalidate),\n      pendingMatches: s.pendingMatches?.map(invalidate)\n    }));\n    this.load();\n  };\n  load = async () => {\n    const promise = new Promise(async (resolve, reject) => {\n      const next = this.latestLocation;\n      const prevLocation = this.state.resolvedLocation;\n      const pathDidChange = prevLocation.href !== next.href;\n      let latestPromise;\n\n      // Cancel any pending matches\n      this.cancelMatches();\n      this.emit({\n        type: 'onBeforeLoad',\n        fromLocation: prevLocation,\n        toLocation: next,\n        pathChanged: pathDidChange\n      });\n      let pendingMatches;\n      const previousMatches = this.state.matches;\n      this.__store.batch(() => {\n        this.cleanCache();\n\n        // Match the routes\n        pendingMatches = this.matchRoutes(next.pathname, next.search, {\n          debug: true\n        });\n\n        // Ingest the new matches\n        // If a cached moved to pendingMatches, remove it from cachedMatches\n        this.__store.setState(s => ({\n          ...s,\n          isLoading: true,\n          location: next,\n          pendingMatches,\n          cachedMatches: s.cachedMatches.filter(d => {\n            return !pendingMatches.find(e => e.id === d.id);\n          })\n        }));\n      });\n      try {\n        try {\n          // Load the matches\n          await this.loadMatches({\n            matches: pendingMatches,\n            checkLatest: () => this.checkLatest(promise)\n          });\n        } catch (err) {\n          // swallow this error, since we'll display the\n          // errors on the route components\n        }\n\n        // Only apply the latest transition\n        if (latestPromise = this.checkLatest(promise)) {\n          return latestPromise;\n        }\n        const exitingMatches = previousMatches.filter(match => !pendingMatches.find(d => d.id === match.id));\n        const enteringMatches = pendingMatches.filter(match => !previousMatches.find(d => d.id === match.id));\n        const stayingMatches = previousMatches.filter(match => pendingMatches.find(d => d.id === match.id));\n\n        // Commit the pending matches. If a previous match was\n        // removed, place it in the cachedMatches\n        this.__store.batch(() => {\n          this.__store.setState(s => ({\n            ...s,\n            isLoading: false,\n            matches: s.pendingMatches,\n            pendingMatches: undefined,\n            cachedMatches: [...s.cachedMatches, ...exitingMatches.filter(d => d.status !== 'error')]\n          }));\n          this.cleanCache();\n        })\n\n        //\n        ;\n        [[exitingMatches, 'onLeave'], [enteringMatches, 'onEnter'], [stayingMatches, 'onStay']].forEach(([matches, hook]) => {\n          matches.forEach(match => {\n            this.looseRoutesById[match.routeId].options[hook]?.(match);\n          });\n        });\n        this.emit({\n          type: 'onLoad',\n          fromLocation: prevLocation,\n          toLocation: next,\n          pathChanged: pathDidChange\n        });\n        resolve();\n      } catch (err) {\n        // Only apply the latest transition\n        if (latestPromise = this.checkLatest(promise)) {\n          return latestPromise;\n        }\n        reject(err);\n      }\n    });\n    this.latestLoadPromise = promise;\n    return this.latestLoadPromise;\n  };\n  cleanCache = () => {\n    // This is where all of the garbage collection magic happens\n    this.__store.setState(s => {\n      return {\n        ...s,\n        cachedMatches: s.cachedMatches.filter(d => {\n          const route = this.looseRoutesById[d.routeId];\n          if (!route.options.loader) {\n            return false;\n          }\n\n          // If the route was preloaded, use the preloadGcTime\n          // otherwise, use the gcTime\n          const gcTime = (d.preload ? route.options.preloadGcTime ?? this.options.defaultPreloadGcTime : route.options.gcTime ?? this.options.defaultGcTime) ?? 5 * 60 * 1000;\n          return d.status !== 'error' && Date.now() - d.updatedAt < gcTime;\n        })\n      };\n    });\n  };\n  preloadRoute = async (navigateOpts = this.state.location) => {\n    let next = this.buildLocation(navigateOpts);\n    let matches = this.matchRoutes(next.pathname, next.search, {\n      throwOnError: true\n    });\n    const loadedMatchIds = Object.fromEntries([...this.state.matches, ...(this.state.pendingMatches ?? []), ...this.state.cachedMatches]?.map(d => [d.id, true]));\n    this.__store.batch(() => {\n      matches.forEach(match => {\n        if (!loadedMatchIds[match.id]) {\n          this.__store.setState(s => ({\n            ...s,\n            cachedMatches: [...s.cachedMatches, match]\n          }));\n        }\n      });\n    });\n    matches = await this.loadMatches({\n      matches,\n      preload: true,\n      checkLatest: () => undefined\n    });\n    return matches;\n  };\n  matchRoute = (location, opts) => {\n    location = {\n      ...location,\n      to: location.to ? this.resolvePathWithBase(location.from || '', location.to) : undefined\n    };\n    const next = this.buildLocation(location);\n    if (opts?.pending && this.state.status !== 'pending') {\n      return false;\n    }\n    const baseLocation = opts?.pending ? this.latestLocation : this.state.resolvedLocation;\n    if (!baseLocation) {\n      return false;\n    }\n    const match = matchPathname(this.basepath, baseLocation.pathname, {\n      ...opts,\n      to: next.pathname\n    });\n    if (!match) {\n      return false;\n    }\n    if (match && (opts?.includeSearch ?? true)) {\n      return deepEqual(baseLocation.search, next.search, true) ? match : false;\n    }\n    return match;\n  };\n  injectHtml = async html => {\n    this.injectedHtml.push(html);\n  };\n  dehydrateData = (key, getData) => {\n    if (typeof document === 'undefined') {\n      const strKey = typeof key === 'string' ? key : JSON.stringify(key);\n      this.injectHtml(async () => {\n        const id = `__TSR_DEHYDRATED__${strKey}`;\n        const data = typeof getData === 'function' ? await getData() : getData;\n        return `<script id='${id}' suppressHydrationWarning>window[\"__TSR_DEHYDRATED__${escapeJSON(strKey)}\"] = ${JSON.stringify(data)}\n          ;(() => {\n            var el = document.getElementById('${id}')\n            el.parentElement.removeChild(el)\n          })()\n          </script>`;\n      });\n      return () => this.hydrateData(key);\n    }\n    return () => undefined;\n  };\n  hydrateData = key => {\n    if (typeof document !== 'undefined') {\n      const strKey = typeof key === 'string' ? key : JSON.stringify(key);\n      return window[`__TSR_DEHYDRATED__${strKey}`];\n    }\n    return undefined;\n  };\n  dehydrate = () => {\n    return {\n      state: {\n        dehydratedMatches: this.state.matches.map(d => pick(d, ['id', 'status', 'updatedAt', 'loaderData']))\n      }\n    };\n  };\n  hydrate = async __do_not_use_server_ctx => {\n    let _ctx = __do_not_use_server_ctx;\n    // Client hydrates from window\n    if (typeof document !== 'undefined') {\n      _ctx = window.__TSR_DEHYDRATED__;\n    }\n    invariant(_ctx, 'Expected to find a __TSR_DEHYDRATED__ property on window... but we did not. Did you forget to render <DehydrateRouter /> in your app?');\n    const ctx = _ctx;\n    this.dehydratedData = ctx.payload;\n    this.options.hydrate?.(ctx.payload);\n    const dehydratedState = ctx.router.state;\n    let matches = this.matchRoutes(this.state.location.pathname, this.state.location.search).map(match => {\n      const dehydratedMatch = dehydratedState.dehydratedMatches.find(d => d.id === match.id);\n      invariant(dehydratedMatch, `Could not find a client-side match for dehydrated match with id: ${match.id}!`);\n      if (dehydratedMatch) {\n        return {\n          ...match,\n          ...dehydratedMatch\n        };\n      }\n      return match;\n    });\n    this.__store.setState(s => {\n      return {\n        ...s,\n        matches: matches\n      };\n    });\n  };\n\n  // resolveMatchPromise = (matchId: string, key: string, value: any) => {\n  //   state.matches\n  //     .find((d) => d.id === matchId)\n  //     ?.__promisesByKey[key]?.resolve(value)\n  // }\n}\n\n// A function that takes an import() argument which is a function and returns a new function that will\n// proxy arguments from the caller to the imported function, retaining all type\n// information along the way\nfunction lazyFn(fn, key) {\n  return async (...args) => {\n    const imported = await fn();\n    return imported[key || 'default'](...args);\n  };\n}\nclass SearchParamError extends Error {}\nclass PathParamError extends Error {}\nfunction getInitialRouterState(location) {\n  return {\n    isLoading: false,\n    isTransitioning: false,\n    status: 'idle',\n    resolvedLocation: {\n      ...location\n    },\n    location,\n    matches: [],\n    pendingMatches: [],\n    cachedMatches: [],\n    lastUpdated: Date.now()\n  };\n}\n\nconst useLayoutEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\nconst windowKey = 'window';\nconst delimiter = '___';\nlet weakScrolledElements = new WeakSet();\nconst sessionsStorage = typeof window !== 'undefined' && window.sessionStorage;\nlet cache = sessionsStorage ? (() => {\n  const storageKey = 'tsr-scroll-restoration-v2';\n  const state = JSON.parse(window.sessionStorage.getItem(storageKey) || 'null') || {\n    cached: {},\n    next: {}\n  };\n  return {\n    state,\n    set: updater => {\n      cache.state = functionalUpdate(updater, cache.state);\n      window.sessionStorage.setItem(storageKey, JSON.stringify(cache.state));\n    }\n  };\n})() : undefined;\nconst defaultGetKey = location => location.state.key;\nfunction useScrollRestoration(options) {\n  const router = useRouter();\n  useLayoutEffect(() => {\n    const getKey = options?.getKey || defaultGetKey;\n    const {\n      history\n    } = window;\n    if (history.scrollRestoration) {\n      history.scrollRestoration = 'manual';\n    }\n    const onScroll = event => {\n      if (weakScrolledElements.has(event.target)) return;\n      weakScrolledElements.add(event.target);\n      let elementSelector = '';\n      if (event.target === document || event.target === window) {\n        elementSelector = windowKey;\n      } else {\n        const attrId = event.target.getAttribute('data-scroll-restoration-id');\n        if (attrId) {\n          elementSelector = `[data-scroll-restoration-id=\"${attrId}\"]`;\n        } else {\n          elementSelector = getCssSelector(event.target);\n        }\n      }\n      if (!cache.state.next[elementSelector]) {\n        cache.set(c => ({\n          ...c,\n          next: {\n            ...c.next,\n            [elementSelector]: {\n              scrollX: NaN,\n              scrollY: NaN\n            }\n          }\n        }));\n      }\n    };\n    if (typeof document !== 'undefined') {\n      document.addEventListener('scroll', onScroll, true);\n    }\n    const unsubOnBeforeLoad = router.subscribe('onBeforeLoad', event => {\n      if (event.pathChanged) {\n        const restoreKey = getKey(event.fromLocation);\n        for (const elementSelector in cache.state.next) {\n          const entry = cache.state.next[elementSelector];\n          if (elementSelector === windowKey) {\n            entry.scrollX = window.scrollX || 0;\n            entry.scrollY = window.scrollY || 0;\n          } else if (elementSelector) {\n            const element = document.querySelector(elementSelector);\n            entry.scrollX = element?.scrollLeft || 0;\n            entry.scrollY = element?.scrollTop || 0;\n          }\n          cache.set(c => {\n            const next = {\n              ...c.next\n            };\n            delete next[elementSelector];\n            return {\n              ...c,\n              next,\n              cached: {\n                ...c.cached,\n                [[restoreKey, elementSelector].join(delimiter)]: entry\n              }\n            };\n          });\n        }\n      }\n    });\n    const unsubOnResolved = router.subscribe('onResolved', event => {\n      if (event.pathChanged) {\n        if (!router.resetNextScroll) {\n          return;\n        }\n        router.resetNextScroll = true;\n        const getKey = options?.getKey || defaultGetKey;\n        const restoreKey = getKey(event.toLocation);\n        let windowRestored = false;\n        for (const cacheKey in cache.state.cached) {\n          const entry = cache.state.cached[cacheKey];\n          const [key, elementSelector] = cacheKey.split(delimiter);\n          if (key === restoreKey) {\n            if (elementSelector === windowKey) {\n              windowRestored = true;\n              window.scrollTo(entry.scrollX, entry.scrollY);\n            } else if (elementSelector) {\n              const element = document.querySelector(elementSelector);\n              if (element) {\n                element.scrollLeft = entry.scrollX;\n                element.scrollTop = entry.scrollY;\n              }\n            }\n          }\n        }\n        if (!windowRestored) {\n          window.scrollTo(0, 0);\n        }\n        cache.set(c => ({\n          ...c,\n          next: {}\n        }));\n        weakScrolledElements = new WeakSet();\n      }\n    });\n    return () => {\n      document.removeEventListener('scroll', onScroll);\n      unsubOnBeforeLoad();\n      unsubOnResolved();\n    };\n  }, []);\n}\nfunction ScrollRestoration(props) {\n  useScrollRestoration(props);\n  return null;\n}\nfunction useElementScrollRestoration(options) {\n  const router = useRouter();\n  const getKey = options?.getKey || defaultGetKey;\n  let elementSelector = '';\n  if (options.id) {\n    elementSelector = `[data-scroll-restoration-id=\"${options.id}\"]`;\n  } else {\n    const element = options.getElement?.();\n    if (!element) {\n      return;\n    }\n    elementSelector = getCssSelector(element);\n  }\n  const restoreKey = getKey(router.latestLocation);\n  const cacheKey = [restoreKey, elementSelector].join(delimiter);\n  return cache.state.cached[cacheKey];\n}\nfunction getCssSelector(el) {\n  let path = [],\n    parent;\n  while (parent = el.parentNode) {\n    path.unshift(`${el.tagName}:nth-child(${[].indexOf.call(parent.children, el) + 1})`);\n    el = parent;\n  }\n  return `${path.join(' > ')}`.toLowerCase();\n}\n\nfunction useBlocker(blockerFn, condition = true) {\n  const {\n    history\n  } = useRouter();\n  React.useEffect(() => {\n    if (!condition) return;\n    return history.block(blockerFn);\n  });\n}\nfunction Block({\n  blocker,\n  condition,\n  children\n}) {\n  useBlocker(blocker, condition);\n  return children ?? null;\n}\n\nfunction useNavigate(defaultOpts) {\n  const {\n    navigate\n  } = useRouter();\n  const matchPathname = useMatch({\n    strict: false,\n    select: s => s.pathname\n  });\n  return React.useCallback(opts => {\n    return navigate({\n      from: opts?.to ? matchPathname : undefined,\n      ...defaultOpts,\n      ...opts\n    });\n  }, []);\n}\n\n// NOTE: I don't know of anyone using this. It's undocumented, so let's wait until someone needs it\n// export function typedNavigate<\n//   TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n//   TDefaultFrom extends RoutePaths<TRouteTree> = '/',\n// >(navigate: (opts: NavigateOptions<any>) => Promise<void>) {\n//   return navigate as <\n//     TFrom extends RoutePaths<TRouteTree> = TDefaultFrom,\n//     TTo extends string = '',\n//     TMaskFrom extends RoutePaths<TRouteTree> = '/',\n//     TMaskTo extends string = '',\n//   >(\n//     opts?: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n//   ) => Promise<void>\n// } //\n\nfunction Navigate(props) {\n  const {\n    navigate\n  } = useRouter();\n  const match = useMatch({\n    strict: false\n  });\n  React.useEffect(() => {\n    navigate({\n      from: props.to ? match.pathname : undefined,\n      ...props\n    });\n  }, []);\n  return null;\n}\n\nexport { Await, Block, CatchBoundary, CatchBoundaryImpl, ErrorComponent, FileRoute, Link, Match, MatchRoute, Matches, Navigate, NotFoundRoute, Outlet, PathParamError, RootRoute, Route, RouteApi, Router, RouterProvider, ScrollRestoration, SearchParamError, cleanPath, componentTypes, createRouteMask, decode, deepEqual, defaultParseSearch, defaultStringifySearch, defer, encode, escapeJSON, functionalUpdate, getInitialRouterState, getRouteMatch, interpolatePath, isDehydratedDeferred, isPlainObject, isRedirect, isServer, joinPaths, last, lazyFn, lazyRouteComponent, matchByPath, matchContext, matchPathname, parsePathname, parseSearchWith, pick, redirect, removeBasepath, replaceEqualDeep, resolvePath, rootRouteId, rootRouteWithContext, routerContext, shallow, stringifySearchWith, trimPath, trimPathLeft, trimPathRight, useAwaited, useBlocker, useElementScrollRestoration, useLayoutEffect$1 as useLayoutEffect, useLinkProps, useLoaderData, useLoaderDeps, useMatch, useMatchRoute, useMatches, useNavigate, useParams, useParentMatches, useRouteContext, useRouter, useRouterState, useScrollRestoration, useSearch, useStableCallback };\n//# sourceMappingURL=index.js.map\n","import React from 'react'\n\nconst getItem = (key: string): unknown => {\n  try {\n    const itemValue = localStorage.getItem(key)\n    if (typeof itemValue === 'string') {\n      return JSON.parse(itemValue)\n    }\n    return undefined\n  } catch {\n    return undefined\n  }\n}\n\nexport default function useLocalStorage<T>(\n  key: string,\n  defaultValue: T | undefined,\n): [T | undefined, (newVal: T | ((prevVal: T) => T)) => void] {\n  const [value, setValue] = React.useState<T>()\n\n  React.useEffect(() => {\n    const initialValue = getItem(key) as T | undefined\n\n    if (typeof initialValue === 'undefined' || initialValue === null) {\n      setValue(\n        typeof defaultValue === 'function' ? defaultValue() : defaultValue,\n      )\n    } else {\n      setValue(initialValue)\n    }\n  }, [defaultValue, key])\n\n  const setter = React.useCallback(\n    (updater: any) => {\n      setValue((old) => {\n        let newVal = updater\n\n        if (typeof updater == 'function') {\n          newVal = updater(old)\n        }\n        try {\n          localStorage.setItem(key, JSON.stringify(newVal))\n        } catch {}\n\n        return newVal\n      })\n    },\n    [key],\n  )\n\n  return [value, setter]\n}\n","import React from 'react'\n\nexport const defaultTheme = {\n  background: '#222222',\n  backgroundAlt: '#292929',\n  foreground: 'white',\n  gray: '#444',\n  grayAlt: '#444',\n  inputBackgroundColor: '#fff',\n  inputTextColor: '#000',\n  success: '#80cb00',\n  danger: '#ff0085',\n  active: '#0099ff',\n  warning: '#ffb200',\n} as const\n\nexport type Theme = typeof defaultTheme\ninterface ProviderProps {\n  theme: Theme\n  children?: React.ReactNode\n}\n\nconst ThemeContext = React.createContext(defaultTheme)\n\nexport function ThemeProvider({ theme, ...rest }: ProviderProps) {\n  return <ThemeContext.Provider value={theme} {...rest} />\n}\n\nexport function useTheme() {\n  return React.useContext(ThemeContext)\n}\n","import React from 'react'\nimport { AnyRootRoute, AnyRoute, AnyRouteMatch } from '@tanstack/react-router'\n\nimport { Theme, useTheme } from './theme'\nimport useMediaQuery from './useMediaQuery'\n\nexport const isServer = typeof window === 'undefined'\n\ntype StyledComponent<T> = T extends 'button'\n  ? React.DetailedHTMLProps<\n      React.ButtonHTMLAttributes<HTMLButtonElement>,\n      HTMLButtonElement\n    >\n  : T extends 'input'\n  ? React.DetailedHTMLProps<\n      React.InputHTMLAttributes<HTMLInputElement>,\n      HTMLInputElement\n    >\n  : T extends 'select'\n  ? React.DetailedHTMLProps<\n      React.SelectHTMLAttributes<HTMLSelectElement>,\n      HTMLSelectElement\n    >\n  : T extends keyof HTMLElementTagNameMap\n  ? React.HTMLAttributes<HTMLElementTagNameMap[T]>\n  : never\n\nexport function getStatusColor(match: AnyRouteMatch, theme: Theme) {\n  return match.status === 'pending' || match.isFetching\n    ? theme.active\n    : match.status === 'error'\n    ? theme.danger\n    : match.status === 'success'\n    ? theme.success\n    : theme.gray\n}\n\nexport function getRouteStatusColor(\n  matches: AnyRouteMatch[],\n  route: AnyRoute | AnyRootRoute,\n  theme: Theme,\n) {\n  const found = matches.find((d) => d.routeId === route.id)\n  if (!found) return theme.gray\n  return getStatusColor(found, theme)\n}\n\ntype Styles =\n  | React.CSSProperties\n  | ((props: Record<string, any>, theme: Theme) => React.CSSProperties)\n\nexport function styled<T extends keyof HTMLElementTagNameMap>(\n  type: T,\n  newStyles: Styles,\n  queries: Record<string, Styles> = {},\n) {\n  return React.forwardRef<HTMLElementTagNameMap[T], StyledComponent<T>>(\n    ({ style, ...rest }, ref) => {\n      const theme = useTheme()\n\n      const mediaStyles = Object.entries(queries).reduce(\n        (current, [key, value]) => {\n          // eslint-disable-next-line react-hooks/rules-of-hooks\n          return useMediaQuery(key)\n            ? {\n                ...current,\n                ...(typeof value === 'function' ? value(rest, theme) : value),\n              }\n            : current\n        },\n        {},\n      )\n\n      return React.createElement(type, {\n        ...rest,\n        style: {\n          ...(typeof newStyles === 'function'\n            ? newStyles(rest, theme)\n            : newStyles),\n          ...style,\n          ...mediaStyles,\n        },\n        ref,\n      })\n    },\n  )\n}\n\nexport function useIsMounted() {\n  const mountedRef = React.useRef(false)\n  const isMounted = React.useCallback(() => mountedRef.current, [])\n\n  React[isServer ? 'useEffect' : 'useLayoutEffect'](() => {\n    mountedRef.current = true\n    return () => {\n      mountedRef.current = false\n    }\n  }, [])\n\n  return isMounted\n}\n\n/**\n * Displays a string regardless the type of the data\n * @param {unknown} value Value to be stringified\n */\nexport const displayValue = (value: unknown) => {\n  const name = Object.getOwnPropertyNames(Object(value))\n  const newValue = typeof value === 'bigint' ? `${value.toString()}n` : value\n\n  return JSON.stringify(newValue, name)\n}\n\n/**\n * This hook is a safe useState version which schedules state updates in microtasks\n * to prevent updating a component state while React is rendering different components\n * or when the component is not mounted anymore.\n */\nexport function useSafeState<T>(initialState: T): [T, (value: T) => void] {\n  const isMounted = useIsMounted()\n  const [state, setState] = React.useState(initialState)\n\n  const safeSetState = React.useCallback(\n    (value: T) => {\n      scheduleMicrotask(() => {\n        if (isMounted()) {\n          setState(value)\n        }\n      })\n    },\n    [isMounted],\n  )\n\n  return [state, safeSetState]\n}\n\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\nfunction scheduleMicrotask(callback: () => void) {\n  Promise.resolve()\n    .then(callback)\n    .catch((error) =>\n      setTimeout(() => {\n        throw error\n      }),\n    )\n}\n\nexport function multiSortBy<T>(\n  arr: T[],\n  accessors: ((item: T) => any)[] = [(d) => d],\n): T[] {\n  return arr\n    .map((d, i) => [d, i] as const)\n    .sort(([a, ai], [b, bi]) => {\n      for (const accessor of accessors) {\n        const ao = accessor(a)\n        const bo = accessor(b)\n\n        if (typeof ao === 'undefined') {\n          if (typeof bo === 'undefined') {\n            continue\n          }\n          return 1\n        }\n\n        if (ao === bo) {\n          continue\n        }\n\n        return ao > bo ? 1 : -1\n      }\n\n      return ai - bi\n    })\n    .map(([d]) => d)\n}\n","import React from 'react'\n\nexport default function useMediaQuery(query: string): boolean | undefined {\n  // Keep track of the preference in state, start with the current match\n  const [isMatch, setIsMatch] = React.useState(() => {\n    if (typeof window !== 'undefined') {\n      return window.matchMedia && window.matchMedia(query).matches\n    }\n    return\n  })\n\n  // Watch for changes\n  React.useEffect(() => {\n    if (typeof window !== 'undefined') {\n      if (!window.matchMedia) {\n        return\n      }\n\n      // Create a matcher\n      const matcher = window.matchMedia(query)\n\n      // Create our handler\n      const onChange = ({ matches }: { matches: boolean }) =>\n        setIsMatch(matches)\n\n      // Listen for changes\n      matcher.addListener(onChange)\n\n      return () => {\n        // Stop listening for changes\n        matcher.removeListener(onChange)\n      }\n    }\n\n    return\n  }, [isMatch, query, setIsMatch])\n\n  return isMatch\n}\n","import { styled } from './utils'\n\nexport const Panel = styled(\n  'div',\n  (_props, theme) => ({\n    fontSize: 'clamp(12px, 1.5vw, 14px)',\n    fontFamily: `sans-serif`,\n    display: 'flex',\n    backgroundColor: theme.background,\n    color: theme.foreground,\n  }),\n  {\n    '(max-width: 700px)': {\n      flexDirection: 'column',\n    },\n    '(max-width: 600px)': {\n      fontSize: '.9em',\n      // flexDirection: 'column',\n    },\n  },\n)\n\nexport const ActivePanel = styled(\n  'div',\n  () => ({\n    flex: '1 1 500px',\n    display: 'flex',\n    flexDirection: 'column',\n    overflow: 'auto',\n    height: '100%',\n  }),\n  {\n    '(max-width: 700px)': (_props, theme) => ({\n      borderTop: `2px solid ${theme.gray}`,\n    }),\n  },\n)\n\nexport const Button = styled('button', (props, theme) => ({\n  appearance: 'none',\n  fontSize: '.9em',\n  fontWeight: 'bold',\n  background: theme.gray,\n  border: '0',\n  borderRadius: '.3em',\n  color: 'white',\n  padding: '.5em',\n  opacity: props.disabled ? '.5' : undefined,\n  cursor: 'pointer',\n}))\n\n// export const QueryKeys = styled('span', {\n//   display: 'inline-block',\n//   fontSize: '0.9em',\n// })\n\n// export const QueryKey = styled('span', {\n//   display: 'inline-flex',\n//   alignItems: 'center',\n//   padding: '.2em .4em',\n//   fontWeight: 'bold',\n//   textShadow: '0 0 10px black',\n//   borderRadius: '.2em',\n// })\n\nexport const Code = styled('code', {\n  fontSize: '.9em',\n})\n\nexport const Input = styled('input', (_props, theme) => ({\n  backgroundColor: theme.inputBackgroundColor,\n  border: 0,\n  borderRadius: '.2em',\n  color: theme.inputTextColor,\n  fontSize: '.9em',\n  lineHeight: `1.3`,\n  padding: '.3em .4em',\n}))\n\nexport const Select = styled(\n  'select',\n  (_props, theme) => ({\n    display: `inline-block`,\n    fontSize: `.9em`,\n    fontFamily: `sans-serif`,\n    fontWeight: 'normal',\n    lineHeight: `1.3`,\n    padding: `.3em 1.5em .3em .5em`,\n    height: 'auto',\n    border: 0,\n    borderRadius: `.2em`,\n    appearance: `none`,\n    WebkitAppearance: 'none',\n    backgroundColor: theme.inputBackgroundColor,\n    backgroundImage: `url(\"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='100' height='100' fill='%23444444'><polygon points='0,25 100,25 50,75'/></svg>\")`,\n    backgroundRepeat: `no-repeat`,\n    backgroundPosition: `right .55em center`,\n    backgroundSize: `.65em auto, 100%`,\n    color: theme.inputTextColor,\n  }),\n  {\n    '(max-width: 500px)': {\n      display: 'none',\n    },\n  },\n)\n","import * as React from 'react'\n\nimport { displayValue, styled } from './utils'\n\nexport const Entry = styled('div', {\n  fontFamily: 'Menlo, monospace',\n  fontSize: '.7rem',\n  lineHeight: '1.7',\n  outline: 'none',\n  wordBreak: 'break-word',\n})\n\nexport const Label = styled('span', {\n  color: 'white',\n})\n\nexport const LabelButton = styled('button', {\n  cursor: 'pointer',\n  color: 'white',\n})\n\nexport const ExpandButton = styled('button', {\n  cursor: 'pointer',\n  color: 'inherit',\n  font: 'inherit',\n  outline: 'inherit',\n  background: 'transparent',\n  border: 'none',\n  padding: 0,\n})\n\nexport const Value = styled('span', (_props, theme) => ({\n  color: theme.danger,\n}))\n\nexport const SubEntries = styled('div', {\n  marginLeft: '.1em',\n  paddingLeft: '1em',\n  borderLeft: '2px solid rgba(0,0,0,.15)',\n})\n\nexport const Info = styled('span', {\n  color: 'grey',\n  fontSize: '.7em',\n})\n\ntype ExpanderProps = {\n  expanded: boolean\n  style?: React.CSSProperties\n}\n\nexport const Expander = ({ expanded, style = {} }: ExpanderProps) => (\n  <span\n    style={{\n      display: 'inline-block',\n      transition: 'all .1s ease',\n      transform: `rotate(${expanded ? 90 : 0}deg) ${style.transform || ''}`,\n      ...style,\n    }}\n  >\n    â–¶\n  </span>\n)\n\ntype Entry = {\n  label: string\n}\n\ntype RendererProps = {\n  handleEntry: HandleEntryFn\n  label?: React.ReactNode\n  value: unknown\n  subEntries: Entry[]\n  subEntryPages: Entry[][]\n  type: string\n  expanded: boolean\n  toggleExpanded: () => void\n  pageSize: number\n  renderer?: Renderer\n  filterSubEntries?: (subEntries: Property[]) => Property[]\n}\n\n/**\n * Chunk elements in the array by size\n *\n * when the array cannot be chunked evenly by size, the last chunk will be\n * filled with the remaining elements\n *\n * @example\n * chunkArray(['a','b', 'c', 'd', 'e'], 2) // returns [['a','b'], ['c', 'd'], ['e']]\n */\nexport function chunkArray<T>(array: T[], size: number): T[][] {\n  if (size < 1) return []\n  let i = 0\n  const result: T[][] = []\n  while (i < array.length) {\n    result.push(array.slice(i, i + size))\n    i = i + size\n  }\n  return result\n}\n\ntype Renderer = (props: RendererProps) => JSX.Element\n\nexport const DefaultRenderer: Renderer = ({\n  handleEntry,\n  label,\n  value,\n  subEntries = [],\n  subEntryPages = [],\n  type,\n  expanded = false,\n  toggleExpanded,\n  pageSize,\n  renderer,\n}) => {\n  const [expandedPages, setExpandedPages] = React.useState<number[]>([])\n  const [valueSnapshot, setValueSnapshot] = React.useState(undefined)\n\n  const refreshValueSnapshot = () => {\n    setValueSnapshot((value as () => any)())\n  }\n\n  return (\n    <Entry>\n      {subEntryPages.length ? (\n        <>\n          <ExpandButton onClick={() => toggleExpanded()}>\n            <Expander expanded={expanded} /> {label}{' '}\n            <Info>\n              {String(type).toLowerCase() === 'iterable' ? '(Iterable) ' : ''}\n              {subEntries.length} {subEntries.length > 1 ? `items` : `item`}\n            </Info>\n          </ExpandButton>\n          {expanded ? (\n            subEntryPages.length === 1 ? (\n              <SubEntries>\n                {subEntries.map((entry, index) => handleEntry(entry))}\n              </SubEntries>\n            ) : (\n              <SubEntries>\n                {subEntryPages.map((entries, index) => (\n                  <div key={index}>\n                    <Entry>\n                      <LabelButton\n                        onClick={() =>\n                          setExpandedPages((old) =>\n                            old.includes(index)\n                              ? old.filter((d) => d !== index)\n                              : [...old, index],\n                          )\n                        }\n                      >\n                        <Expander expanded={expanded} /> [{index * pageSize} ...{' '}\n                        {index * pageSize + pageSize - 1}]\n                      </LabelButton>\n                      {expandedPages.includes(index) ? (\n                        <SubEntries>\n                          {entries.map((entry) => handleEntry(entry))}\n                        </SubEntries>\n                      ) : null}\n                    </Entry>\n                  </div>\n                ))}\n              </SubEntries>\n            )\n          ) : null}\n        </>\n      ) : type === 'function' ? (\n        <>\n          <Explorer\n            renderer={renderer}\n            label={\n              <button\n                onClick={refreshValueSnapshot}\n                style={{\n                  appearance: 'none',\n                  border: '0',\n                  background: 'transparent',\n                }}\n              >\n                <Label>{label}</Label> ðŸ”„{' '}\n              </button>\n            }\n            value={valueSnapshot}\n            defaultExpanded={{}}\n          />\n        </>\n      ) : (\n        <>\n          <Label>{label}:</Label> <Value>{displayValue(value)}</Value>\n        </>\n      )}\n    </Entry>\n  )\n}\n\ntype HandleEntryFn = (entry: Entry) => JSX.Element\n\ntype ExplorerProps = Partial<RendererProps> & {\n  renderer?: Renderer\n  defaultExpanded?: true | Record<string, boolean>\n}\n\ntype Property = {\n  defaultExpanded?: boolean | Record<string, boolean>\n  label: string\n  value: unknown\n}\n\nfunction isIterable(x: any): x is Iterable<unknown> {\n  return Symbol.iterator in x\n}\n\nexport default function Explorer({\n  value,\n  defaultExpanded,\n  renderer = DefaultRenderer,\n  pageSize = 100,\n  filterSubEntries,\n  ...rest\n}: ExplorerProps) {\n  const [expanded, setExpanded] = React.useState(Boolean(defaultExpanded))\n  const toggleExpanded = React.useCallback(() => setExpanded((old) => !old), [])\n\n  let type: string = typeof value\n  let subEntries: Property[] = []\n\n  const makeProperty = (sub: { label: string; value: unknown }): Property => {\n    const subDefaultExpanded =\n      defaultExpanded === true\n        ? { [sub.label]: true }\n        : defaultExpanded?.[sub.label]\n    return {\n      ...sub,\n      defaultExpanded: subDefaultExpanded,\n    }\n  }\n\n  if (Array.isArray(value)) {\n    type = 'array'\n    subEntries = value.map((d, i) =>\n      makeProperty({\n        label: i.toString(),\n        value: d,\n      }),\n    )\n  } else if (\n    value !== null &&\n    typeof value === 'object' &&\n    isIterable(value) &&\n    typeof value[Symbol.iterator] === 'function'\n  ) {\n    type = 'Iterable'\n    subEntries = Array.from(value, (val, i) =>\n      makeProperty({\n        label: i.toString(),\n        value: val,\n      }),\n    )\n  } else if (typeof value === 'object' && value !== null) {\n    type = 'object'\n    subEntries = Object.entries(value).map(([key, val]) =>\n      makeProperty({\n        label: key,\n        value: val,\n      }),\n    )\n  }\n\n  subEntries = filterSubEntries ? filterSubEntries(subEntries) : subEntries\n\n  const subEntryPages = chunkArray(subEntries, pageSize)\n\n  return renderer({\n    handleEntry: (entry) => (\n      <Explorer\n        key={entry.label}\n        value={value}\n        renderer={renderer}\n        filterSubEntries={filterSubEntries}\n        {...rest}\n        {...entry}\n      />\n    ),\n    type,\n    subEntries,\n    subEntryPages,\n    value,\n    expanded,\n    toggleExpanded,\n    pageSize,\n    ...rest,\n  })\n}\n","import React from 'react'\nimport {\n  invariant,\n  AnyRouter,\n  Route,\n  AnyRoute,\n  AnyRootRoute,\n  trimPath,\n  useRouter,\n  useRouterState,\n  AnyRouteMatch,\n} from '@tanstack/react-router'\n\nimport useLocalStorage from './useLocalStorage'\nimport {\n  getRouteStatusColor,\n  getStatusColor,\n  multiSortBy,\n  useIsMounted,\n  useSafeState,\n} from './utils'\nimport { Panel, Button, Code, ActivePanel } from './styledComponents'\nimport { ThemeProvider, defaultTheme as theme } from './theme'\n// import { getQueryStatusLabel, getQueryStatusColor } from './utils'\nimport Explorer from './Explorer'\n\nexport type PartialKeys<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>\n\ninterface DevtoolsOptions {\n  /**\n   * Set this true if you want the dev tools to default to being open\n   */\n  initialIsOpen?: boolean\n  /**\n   * Use this to add props to the panel. For example, you can add className, style (merge and override default style), etc.\n   */\n  panelProps?: React.DetailedHTMLProps<\n    React.HTMLAttributes<HTMLDivElement>,\n    HTMLDivElement\n  >\n  /**\n   * Use this to add props to the close button. For example, you can add className, style (merge and override default style), onClick (extend default handler), etc.\n   */\n  closeButtonProps?: React.DetailedHTMLProps<\n    React.ButtonHTMLAttributes<HTMLButtonElement>,\n    HTMLButtonElement\n  >\n  /**\n   * Use this to add props to the toggle button. For example, you can add className, style (merge and override default style), onClick (extend default handler), etc.\n   */\n  toggleButtonProps?: React.DetailedHTMLProps<\n    React.ButtonHTMLAttributes<HTMLButtonElement>,\n    HTMLButtonElement\n  >\n  /**\n   * The position of the TanStack Router logo to open and close the devtools panel.\n   * Defaults to 'bottom-left'.\n   */\n  position?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right'\n  /**\n   * Use this to render the devtools inside a different type of container element for a11y purposes.\n   * Any string which corresponds to a valid intrinsic JSX element is allowed.\n   * Defaults to 'footer'.\n   */\n  containerElement?: string | any\n  /**\n   * A boolean variable indicating if the \"lite\" version of the library is being used\n   */\n  router?: AnyRouter\n}\n\ninterface DevtoolsPanelOptions {\n  /**\n   * The standard React style object used to style a component with inline styles\n   */\n  style?: React.CSSProperties\n  /**\n   * The standard React className property used to style a component with classes\n   */\n  className?: string\n  /**\n   * A boolean variable indicating whether the panel is open or closed\n   */\n  isOpen?: boolean\n  /**\n   * A function that toggles the open and close state of the panel\n   */\n  setIsOpen: (isOpen: boolean) => void\n  /**\n   * Handles the opening and closing the devtools panel\n   */\n  handleDragStart: (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => void\n  /**\n   * A boolean variable indicating if the \"lite\" version of the library is being used\n   */\n  router?: AnyRouter\n}\n\nconst isServer = typeof window === 'undefined'\n\nfunction Logo(props: React.HTMLProps<HTMLDivElement>) {\n  return (\n    <div\n      {...props}\n      style={{\n        ...(props.style ?? {}),\n        display: 'flex',\n        alignItems: 'center',\n        flexDirection: 'column',\n        fontSize: '0.8rem',\n        fontWeight: 'bolder',\n        lineHeight: '1',\n      }}\n    >\n      <div\n        style={{\n          letterSpacing: '-0.05rem',\n        }}\n      >\n        TANSTACK\n      </div>\n      <div\n        style={{\n          backgroundImage:\n            'linear-gradient(to right, var(--tw-gradient-stops))',\n          // @ts-ignore\n          '--tw-gradient-from': '#84cc16',\n          '--tw-gradient-stops':\n            'var(--tw-gradient-from), var(--tw-gradient-to)',\n          '--tw-gradient-to': '#10b981',\n          WebkitBackgroundClip: 'text',\n          color: 'transparent',\n          letterSpacing: '0.1rem',\n          marginRight: '-0.2rem',\n        }}\n      >\n        ROUTER\n      </div>\n    </div>\n  )\n}\n\nexport function TanStackRouterDevtools({\n  initialIsOpen,\n  panelProps = {},\n  closeButtonProps = {},\n  toggleButtonProps = {},\n  position = 'bottom-left',\n  containerElement: Container = 'footer',\n  router,\n}: DevtoolsOptions): React.ReactElement | null {\n  const rootRef = React.useRef<HTMLDivElement>(null)\n  const panelRef = React.useRef<HTMLDivElement>(null)\n  const [isOpen, setIsOpen] = useLocalStorage(\n    'tanstackRouterDevtoolsOpen',\n    initialIsOpen,\n  )\n  const [devtoolsHeight, setDevtoolsHeight] = useLocalStorage<number | null>(\n    'tanstackRouterDevtoolsHeight',\n    null,\n  )\n  const [isResolvedOpen, setIsResolvedOpen] = useSafeState(false)\n  const [isResizing, setIsResizing] = useSafeState(false)\n  const isMounted = useIsMounted()\n\n  const handleDragStart = (\n    panelElement: HTMLDivElement | null,\n    startEvent: React.MouseEvent<HTMLDivElement, MouseEvent>,\n  ) => {\n    if (startEvent.button !== 0) return // Only allow left click for drag\n\n    setIsResizing(true)\n\n    const dragInfo = {\n      originalHeight: panelElement?.getBoundingClientRect().height ?? 0,\n      pageY: startEvent.pageY,\n    }\n\n    const run = (moveEvent: MouseEvent) => {\n      const delta = dragInfo.pageY - moveEvent.pageY\n      const newHeight = dragInfo?.originalHeight + delta\n\n      setDevtoolsHeight(newHeight)\n\n      if (newHeight < 70) {\n        setIsOpen(false)\n      } else {\n        setIsOpen(true)\n      }\n    }\n\n    const unsub = () => {\n      setIsResizing(false)\n      document.removeEventListener('mousemove', run)\n      document.removeEventListener('mouseUp', unsub)\n    }\n\n    document.addEventListener('mousemove', run)\n    document.addEventListener('mouseup', unsub)\n  }\n\n  React.useEffect(() => {\n    setIsResolvedOpen(isOpen ?? false)\n  }, [isOpen, isResolvedOpen, setIsResolvedOpen])\n\n  // Toggle panel visibility before/after transition (depending on direction).\n  // Prevents focusing in a closed panel.\n  React.useEffect(() => {\n    const ref = panelRef.current\n\n    if (ref) {\n      const handlePanelTransitionStart = () => {\n        if (ref && isResolvedOpen) {\n          ref.style.visibility = 'visible'\n        }\n      }\n\n      const handlePanelTransitionEnd = () => {\n        if (ref && !isResolvedOpen) {\n          ref.style.visibility = 'hidden'\n        }\n      }\n\n      ref.addEventListener('transitionstart', handlePanelTransitionStart)\n      ref.addEventListener('transitionend', handlePanelTransitionEnd)\n\n      return () => {\n        ref.removeEventListener('transitionstart', handlePanelTransitionStart)\n        ref.removeEventListener('transitionend', handlePanelTransitionEnd)\n      }\n    }\n\n    return\n  }, [isResolvedOpen])\n\n  React[isServer ? 'useEffect' : 'useLayoutEffect'](() => {\n    if (isResolvedOpen) {\n      const previousValue = rootRef.current?.parentElement?.style.paddingBottom\n\n      const run = () => {\n        const containerHeight = panelRef.current?.getBoundingClientRect().height\n        if (rootRef.current?.parentElement) {\n          rootRef.current.parentElement.style.paddingBottom = `${containerHeight}px`\n        }\n      }\n\n      run()\n\n      if (typeof window !== 'undefined') {\n        window.addEventListener('resize', run)\n\n        return () => {\n          window.removeEventListener('resize', run)\n          if (\n            rootRef.current?.parentElement &&\n            typeof previousValue === 'string'\n          ) {\n            rootRef.current.parentElement.style.paddingBottom = previousValue\n          }\n        }\n      }\n    }\n    return\n  }, [isResolvedOpen])\n\n  const { style: panelStyle = {}, ...otherPanelProps } = panelProps\n\n  const {\n    style: closeButtonStyle = {},\n    onClick: onCloseClick,\n    ...otherCloseButtonProps\n  } = closeButtonProps\n\n  const {\n    style: toggleButtonStyle = {},\n    onClick: onToggleClick,\n    ...otherToggleButtonProps\n  } = toggleButtonProps\n\n  // Do not render on the server\n  if (!isMounted()) return null\n\n  return (\n    <Container ref={rootRef} className=\"TanStackRouterDevtools\">\n      <ThemeProvider theme={theme}>\n        <TanStackRouterDevtoolsPanel\n          ref={panelRef as any}\n          {...otherPanelProps}\n          router={router}\n          style={{\n            position: 'fixed',\n            bottom: '0',\n            right: '0',\n            zIndex: 99999,\n            width: '100%',\n            height: devtoolsHeight ?? 500,\n            maxHeight: '90%',\n            boxShadow: '0 0 20px rgba(0,0,0,.3)',\n            borderTop: `1px solid ${theme.gray}`,\n            transformOrigin: 'top',\n            // visibility will be toggled after transitions, but set initial state here\n            visibility: isOpen ? 'visible' : 'hidden',\n            ...panelStyle,\n            ...(isResizing\n              ? {\n                  transition: `none`,\n                }\n              : { transition: `all .2s ease` }),\n            ...(isResolvedOpen\n              ? {\n                  opacity: 1,\n                  pointerEvents: 'all',\n                  transform: `translateY(0) scale(1)`,\n                }\n              : {\n                  opacity: 0,\n                  pointerEvents: 'none',\n                  transform: `translateY(15px) scale(1.02)`,\n                }),\n          }}\n          isOpen={isResolvedOpen}\n          setIsOpen={setIsOpen}\n          handleDragStart={(e) => handleDragStart(panelRef.current, e)}\n        />\n        {isResolvedOpen ? (\n          <Button\n            type=\"button\"\n            aria-label=\"Close TanStack Router Devtools\"\n            {...(otherCloseButtonProps as any)}\n            onClick={(e) => {\n              setIsOpen(false)\n              onCloseClick && onCloseClick(e)\n            }}\n            style={{\n              position: 'fixed',\n              zIndex: 99999,\n              margin: '.5em',\n              bottom: 0,\n              ...(position === 'top-right'\n                ? {\n                    right: '0',\n                  }\n                : position === 'top-left'\n                  ? {\n                      left: '0',\n                    }\n                  : position === 'bottom-right'\n                    ? {\n                        right: '0',\n                      }\n                    : {\n                        left: '0',\n                      }),\n              ...closeButtonStyle,\n            }}\n          >\n            Close\n          </Button>\n        ) : null}\n      </ThemeProvider>\n      {!isResolvedOpen ? (\n        <button\n          type=\"button\"\n          {...otherToggleButtonProps}\n          aria-label=\"Open TanStack Router Devtools\"\n          onClick={(e) => {\n            setIsOpen(true)\n            onToggleClick && onToggleClick(e)\n          }}\n          style={{\n            appearance: 'none',\n            background: 'none',\n            border: 0,\n            padding: 0,\n            position: 'fixed',\n            zIndex: 99999,\n            display: 'inline-flex',\n            fontSize: '1.5em',\n            margin: '.5em',\n            cursor: 'pointer',\n            width: 'fit-content',\n            ...(position === 'top-right'\n              ? {\n                  top: '0',\n                  right: '0',\n                }\n              : position === 'top-left'\n                ? {\n                    top: '0',\n                    left: '0',\n                  }\n                : position === 'bottom-right'\n                  ? {\n                      bottom: '0',\n                      right: '0',\n                    }\n                  : {\n                      bottom: '0',\n                      left: '0',\n                    }),\n            ...toggleButtonStyle,\n          }}\n        >\n          <Logo aria-hidden />\n        </button>\n      ) : null}\n    </Container>\n  )\n}\n\nfunction RouteComp({\n  route,\n  isRoot,\n  activeId,\n  setActiveId,\n}: {\n  route: AnyRootRoute | AnyRoute\n  isRoot?: boolean\n  activeId: string | undefined\n  setActiveId: (id: string) => void\n}) {\n  const routerState = useRouterState()\n  const matches =\n    routerState.status === 'pending'\n      ? routerState.pendingMatches ?? []\n      : routerState.matches\n\n  const match = routerState.matches.find((d) => d.routeId === route.id)\n\n  return (\n    <div>\n      <div\n        role=\"button\"\n        aria-label={`Open match details for ${route.id}`}\n        onClick={() => {\n          if (match) {\n            setActiveId(activeId === route.id ? '' : route.id)\n          }\n        }}\n        style={{\n          display: 'flex',\n          borderBottom: `solid 1px ${theme.grayAlt}`,\n          cursor: match ? 'pointer' : 'default',\n          alignItems: 'center',\n          background:\n            route.id === activeId ? 'rgba(255,255,255,.1)' : undefined,\n          padding: '.25rem .5rem',\n          gap: '.5rem',\n        }}\n      >\n        {isRoot ? null : (\n          <div\n            style={{\n              flex: '0 0 auto',\n              width: '.7rem',\n              height: '.7rem',\n              alignItems: 'center',\n              justifyContent: 'center',\n              fontWeight: 'bold',\n              borderRadius: '100%',\n              transition: 'all .2s ease-out',\n              background: getRouteStatusColor(matches, route, theme),\n              opacity: match ? 1 : 0.3,\n            }}\n          />\n        )}\n        <div\n          style={{\n            flex: '1 0 auto',\n            display: 'flex',\n            justifyContent: 'space-between',\n            alignItems: 'center',\n            padding: isRoot ? '0 .25rem' : 0,\n            opacity: match ? 1 : 0.7,\n            fontSize: '0.7rem',\n          }}\n        >\n          <Code>{route.path || trimPath(route.id)} </Code>\n          <div\n            style={{\n              display: 'flex',\n              alignItems: 'center',\n              gap: '.5rem',\n            }}\n          >\n            {match ? <Code style={{ opacity: 0.3 }}>{match.id}</Code> : null}\n            <AgeTicker match={match} />\n          </div>\n        </div>\n      </div>\n      {(route.children as Route[])?.length ? (\n        <div\n          style={{\n            marginLeft: isRoot ? 0 : '1rem',\n            borderLeft: isRoot ? '' : `solid 1px ${theme.grayAlt}`,\n          }}\n        >\n          {[...(route.children as Route[])]\n            .sort((a, b) => {\n              return a.rank - b.rank\n            })\n            .map((r) => (\n              <RouteComp\n                key={r.id}\n                route={r}\n                activeId={activeId}\n                setActiveId={setActiveId}\n              />\n            ))}\n        </div>\n      ) : null}\n    </div>\n  )\n}\n\nexport const TanStackRouterDevtoolsPanel = React.forwardRef<\n  HTMLDivElement,\n  DevtoolsPanelOptions\n>(function TanStackRouterDevtoolsPanel(props, ref): React.ReactElement {\n  const {\n    isOpen = true,\n    setIsOpen,\n    handleDragStart,\n    router: userRouter,\n    ...panelProps\n  } = props\n\n  const router = useRouter()\n  const routerState = useRouterState()\n\n  const matches = [\n    ...(routerState.pendingMatches ?? []),\n    ...routerState.matches,\n    ...routerState.cachedMatches,\n  ]\n\n  invariant(\n    router,\n    'No router was found for the TanStack Router Devtools. Please place the devtools in the <RouterProvider> component tree or pass the router instance to the devtools manually.',\n  )\n\n  // useStore(router.__store)\n\n  const [showMatches, setShowMatches] = useLocalStorage(\n    'tanstackRouterDevtoolsShowMatches',\n    true,\n  )\n\n  const [activeId, setActiveId] = useLocalStorage(\n    'tanstackRouterDevtoolsActiveRouteId',\n    '',\n  )\n\n  const activeMatch = React.useMemo(\n    () => matches.find((d) => d.routeId === activeId || d.id === activeId),\n    [matches, activeId],\n  )\n\n  const hasSearch = Object.keys(routerState.location.search || {}).length\n\n  const explorerState = {\n    ...router,\n    state: router.state,\n  }\n\n  return (\n    <ThemeProvider theme={theme}>\n      <Panel ref={ref} className=\"TanStackRouterDevtoolsPanel\" {...panelProps}>\n        <style\n          dangerouslySetInnerHTML={{\n            __html: `\n\n            .TanStackRouterDevtoolsPanel * {\n              scrollbar-color: ${theme.backgroundAlt} ${theme.gray};\n            }\n\n            .TanStackRouterDevtoolsPanel *::-webkit-scrollbar, .TanStackRouterDevtoolsPanel scrollbar {\n              width: 1em;\n              height: 1em;\n            }\n\n            .TanStackRouterDevtoolsPanel *::-webkit-scrollbar-track, .TanStackRouterDevtoolsPanel scrollbar-track {\n              background: ${theme.backgroundAlt};\n            }\n\n            .TanStackRouterDevtoolsPanel *::-webkit-scrollbar-thumb, .TanStackRouterDevtoolsPanel scrollbar-thumb {\n              background: ${theme.gray};\n              border-radius: .5em;\n              border: 3px solid ${theme.backgroundAlt};\n            }\n\n            .TanStackRouterDevtoolsPanel table {\n              width: 100%;\n            }\n\n            .TanStackRouterDevtoolsPanel table tr {\n              border-bottom: 2px dotted rgba(255, 255, 255, .2);\n            }\n\n            .TanStackRouterDevtoolsPanel table tr:last-child {\n              border-bottom: none\n            }\n\n            .TanStackRouterDevtoolsPanel table td {\n              padding: .25rem .5rem;\n              border-right: 2px dotted rgba(255, 255, 255, .05);\n            }\n\n            .TanStackRouterDevtoolsPanel table td:last-child {\n              border-right: none\n            }\n\n          `,\n          }}\n        />\n        <div\n          style={{\n            position: 'absolute',\n            left: 0,\n            top: 0,\n            width: '100%',\n            height: '4px',\n            marginBottom: '-4px',\n            cursor: 'row-resize',\n            zIndex: 100000,\n          }}\n          onMouseDown={handleDragStart}\n        ></div>\n        <div\n          style={{\n            flex: '1 1 500px',\n            minHeight: '40%',\n            maxHeight: '100%',\n            overflow: 'auto',\n            borderRight: `1px solid ${theme.grayAlt}`,\n            display: 'flex',\n            flexDirection: 'column',\n          }}\n        >\n          <div\n            style={{\n              display: 'flex',\n              justifyContent: 'start',\n              gap: '1rem',\n              padding: '1rem',\n              alignItems: 'center',\n              background: theme.backgroundAlt,\n            }}\n          >\n            <Logo aria-hidden />\n            <div\n              style={{\n                fontSize: 'clamp(.8rem, 2vw, 1.3rem)',\n                fontWeight: 'bold',\n              }}\n            >\n              <span\n                style={{\n                  fontWeight: 100,\n                }}\n              >\n                Devtools\n              </span>\n            </div>\n          </div>\n          <div\n            style={{\n              overflowY: 'auto',\n              flex: '1',\n            }}\n          >\n            <div\n              style={{\n                padding: '.5em',\n              }}\n            >\n              <Explorer\n                label=\"Router\"\n                value={Object.fromEntries(\n                  multiSortBy(\n                    Object.keys(explorerState),\n                    (\n                      [\n                        'state',\n                        'routesById',\n                        'routesByPath',\n                        'flatRoutes',\n                        'options',\n                      ] as const\n                    ).map((d) => (dd) => dd !== d),\n                  )\n                    .map((key) => [key, (explorerState as any)[key]])\n                    .filter(\n                      (d) =>\n                        typeof d[1] !== 'function' &&\n                        ![\n                          '__store',\n                          'basepath',\n                          'injectedHtml',\n                          'subscribers',\n                          'latestLoadPromise',\n                          'navigateTimeout',\n                          'resetNextScroll',\n                          'tempLocationKey',\n                          'latestLocation',\n                          'routeTree',\n                          'history',\n                        ].includes(d[0]),\n                    ),\n                )}\n                defaultExpanded={{\n                  state: {} as any,\n                  context: {} as any,\n                  options: {} as any,\n                }}\n                filterSubEntries={(subEntries) => {\n                  return subEntries.filter((d) => typeof d.value !== 'function')\n                }}\n              />\n            </div>\n          </div>\n        </div>\n        <div\n          style={{\n            flex: '1 1 500px',\n            minHeight: '40%',\n            maxHeight: '100%',\n            overflow: 'auto',\n            borderRight: `1px solid ${theme.grayAlt}`,\n            display: 'flex',\n            flexDirection: 'column',\n          }}\n        >\n          <div\n            style={{\n              flex: '1 1 auto',\n              overflowY: 'auto',\n            }}\n          >\n            <div\n              style={{\n                padding: '.5em',\n                background: theme.backgroundAlt,\n                position: 'sticky',\n                top: 0,\n                zIndex: 1,\n                display: 'flex',\n                alignItems: 'center',\n                gap: '.5rem',\n                fontWeight: 'bold',\n              }}\n            >\n              Pathname{' '}\n              {routerState.location.maskedLocation ? (\n                <div\n                  style={{\n                    padding: '.1rem .5rem',\n                    background: theme.warning,\n                    color: 'black',\n                    borderRadius: '.5rem',\n                  }}\n                >\n                  Masked\n                </div>\n              ) : null}\n            </div>\n            <div\n              style={{\n                padding: '.5rem',\n                display: 'flex',\n                gap: '.5rem',\n                alignItems: 'center',\n              }}\n            >\n              <code\n                style={{\n                  opacity: 0.6,\n                }}\n              >\n                {routerState.location.pathname}\n              </code>\n              {routerState.location.maskedLocation ? (\n                <code\n                  style={{\n                    color: theme.warning,\n                    fontWeight: 'bold',\n                  }}\n                >\n                  {routerState.location.maskedLocation.pathname}\n                </code>\n              ) : null}\n            </div>\n            <div\n              style={{\n                padding: '.5em',\n                background: theme.backgroundAlt,\n                position: 'sticky',\n                top: 0,\n                zIndex: 1,\n                display: 'flex',\n                alignItems: 'center',\n                justifyContent: 'space-between',\n                gap: '.5rem',\n                fontWeight: 'bold',\n              }}\n            >\n              <div\n                style={{\n                  display: 'flex',\n                  alignItems: 'center',\n                  gap: '.5rem',\n                }}\n              >\n                <button\n                  type=\"button\"\n                  onClick={() => {\n                    setShowMatches(false)\n                  }}\n                  disabled={!showMatches}\n                  style={{\n                    appearance: 'none',\n                    opacity: showMatches ? 0.5 : 1,\n                    border: 0,\n                    background: 'transparent',\n                    color: 'inherit',\n                    cursor: 'pointer',\n                  }}\n                >\n                  Routes\n                </button>\n                /\n                <button\n                  type=\"button\"\n                  onClick={() => {\n                    setShowMatches(true)\n                  }}\n                  disabled={showMatches}\n                  style={{\n                    appearance: 'none',\n                    opacity: !showMatches ? 0.5 : 1,\n                    border: 0,\n                    background: 'transparent',\n                    color: 'inherit',\n                    cursor: 'pointer',\n                  }}\n                >\n                  Matches\n                </button>\n              </div>\n              <div\n                style={{\n                  opacity: 0.3,\n                  fontSize: '0.7rem',\n                  fontWeight: 'normal',\n                }}\n              >\n                age / staleTime / gcTime\n              </div>\n            </div>\n            {!showMatches ? (\n              <RouteComp\n                route={router.routeTree}\n                isRoot\n                activeId={activeId}\n                setActiveId={setActiveId}\n              />\n            ) : (\n              <div>\n                {(routerState.status === 'pending'\n                  ? routerState.pendingMatches ?? []\n                  : routerState.matches\n                ).map((match, i) => {\n                  return (\n                    <div\n                      key={match.id || i}\n                      role=\"button\"\n                      aria-label={`Open match details for ${match.id}`}\n                      onClick={() =>\n                        setActiveId(activeId === match.id ? '' : match.id)\n                      }\n                      style={{\n                        display: 'flex',\n                        borderBottom: `solid 1px ${theme.grayAlt}`,\n                        cursor: 'pointer',\n                        alignItems: 'center',\n                        background:\n                          match === activeMatch\n                            ? 'rgba(255,255,255,.1)'\n                            : undefined,\n                      }}\n                    >\n                      <div\n                        style={{\n                          flex: '0 0 auto',\n                          width: '1.3rem',\n                          height: '1.3rem',\n                          marginLeft: '.25rem',\n                          background: getStatusColor(match, theme),\n                          alignItems: 'center',\n                          justifyContent: 'center',\n                          fontWeight: 'bold',\n                          borderRadius: '.25rem',\n                          transition: 'all .2s ease-out',\n                        }}\n                      />\n\n                      <Code\n                        style={{\n                          padding: '.5em',\n                          fontSize: '0.7rem',\n                        }}\n                      >\n                        {`${match.id}`}\n                      </Code>\n                      <AgeTicker match={match} />\n                    </div>\n                  )\n                })}\n              </div>\n            )}\n          </div>\n          {routerState.cachedMatches?.length ? (\n            <div\n              style={{\n                flex: '1 1 auto',\n                overflowY: 'auto',\n                maxHeight: '50%',\n              }}\n            >\n              <div\n                style={{\n                  padding: '.5em',\n                  background: theme.backgroundAlt,\n                  position: 'sticky',\n                  top: 0,\n                  zIndex: 1,\n                  display: 'flex',\n                  alignItems: 'center',\n                  justifyContent: 'space-between',\n                  gap: '.5rem',\n                  fontWeight: 'bold',\n                }}\n              >\n                <div>Cached Matches</div>\n                <div\n                  style={{\n                    opacity: 0.3,\n                    fontSize: '0.7rem',\n                    fontWeight: 'normal',\n                  }}\n                >\n                  age / staleTime / gcTime\n                </div>\n              </div>\n              <div>\n                {routerState.cachedMatches.map((match) => {\n                  return (\n                    <div\n                      key={match.id}\n                      role=\"button\"\n                      aria-label={`Open match details for ${match.id}`}\n                      onClick={() =>\n                        setActiveId(activeId === match.id ? '' : match.id)\n                      }\n                      style={{\n                        display: 'flex',\n                        borderBottom: `solid 1px ${theme.grayAlt}`,\n                        cursor: 'pointer',\n                        alignItems: 'center',\n                        background:\n                          match === activeMatch\n                            ? 'rgba(255,255,255,.1)'\n                            : undefined,\n                        fontSize: '0.7rem',\n                      }}\n                    >\n                      <div\n                        style={{\n                          flex: '0 0 auto',\n                          width: '.75rem',\n                          height: '.75rem',\n                          marginLeft: '.25rem',\n                          background: getStatusColor(match, theme),\n                          alignItems: 'center',\n                          justifyContent: 'center',\n                          fontWeight: 'bold',\n                          borderRadius: '100%',\n                          transition: 'all 1s ease-out',\n                        }}\n                      />\n\n                      <Code\n                        style={{\n                          padding: '.5em',\n                        }}\n                      >\n                        {`${match.id}`}\n                      </Code>\n\n                      <div style={{ marginLeft: 'auto' }}>\n                        <AgeTicker match={match} />\n                      </div>\n                    </div>\n                  )\n                })}\n              </div>\n            </div>\n          ) : null}\n        </div>\n        {activeMatch ? (\n          <ActivePanel>\n            <div\n              style={{\n                padding: '.5em',\n                background: theme.backgroundAlt,\n                position: 'sticky',\n                top: 0,\n                bottom: 0,\n                zIndex: 1,\n              }}\n            >\n              Match Details\n            </div>\n            <div>\n              <table\n                style={{\n                  fontSize: '0.8rem',\n                }}\n              >\n                <tbody>\n                  <tr>\n                    <td style={{ opacity: '.5' }}>ID</td>\n                    <td>\n                      <Code\n                        style={{\n                          lineHeight: '1.8em',\n                        }}\n                      >\n                        {JSON.stringify(activeMatch.id, null, 2)}\n                      </Code>\n                    </td>\n                  </tr>\n                  <tr>\n                    <td style={{ opacity: '.5' }}>Status</td>\n                    <td>\n                      {routerState.pendingMatches?.find(\n                        (d) => d.id === activeMatch.id,\n                      )\n                        ? 'Pending'\n                        : routerState.matches?.find(\n                              (d) => d.id === activeMatch.id,\n                            )\n                          ? 'Active'\n                          : 'Cached'}{' '}\n                      - {activeMatch.status}\n                    </td>\n                  </tr>\n                  {/* <tr>\n                    <td style={{ opacity: '.5' }}>Invalid</td>\n                    <td>{activeMatch.getIsInvalid().toString()}</td>\n                  </tr> */}\n                  <tr>\n                    <td style={{ opacity: '.5' }}>Last Updated</td>\n                    <td>\n                      {activeMatch.updatedAt\n                        ? new Date(\n                            activeMatch.updatedAt as number,\n                          ).toLocaleTimeString()\n                        : 'N/A'}\n                    </td>\n                  </tr>\n                </tbody>\n              </table>\n            </div>\n            {/* <div\n              style={{\n                background: theme.backgroundAlt,\n                padding: '.5em',\n                position: 'sticky',\n                top: 0,\n                bottom: 0,\n                zIndex: 1,\n              }}\n            >\n              Actions\n            </div>\n            <div\n              style={{\n                padding: '0.5em',\n              }}\n            >\n              <Button\n                type=\"button\"\n                onClick={() => activeMatch.__store.setState(d => ({...d, status: 'pending'}))}\n                style={{\n                  background: theme.gray,\n                }}\n              >\n                Reload\n              </Button>\n            </div> */}\n            {activeMatch.loaderData ? (\n              <>\n                <div\n                  style={{\n                    background: theme.backgroundAlt,\n                    padding: '.5em',\n                    position: 'sticky',\n                    top: 0,\n                    bottom: 0,\n                    zIndex: 1,\n                  }}\n                >\n                  Loader Data\n                </div>\n                <div\n                  style={{\n                    padding: '.5em',\n                  }}\n                >\n                  <Explorer\n                    label=\"loaderData\"\n                    value={activeMatch.loaderData}\n                    defaultExpanded={{}}\n                  />\n                </div>\n              </>\n            ) : null}\n            <div\n              style={{\n                background: theme.backgroundAlt,\n                padding: '.5em',\n                position: 'sticky',\n                top: 0,\n                bottom: 0,\n                zIndex: 1,\n              }}\n            >\n              Explorer\n            </div>\n            <div\n              style={{\n                padding: '.5em',\n              }}\n            >\n              <Explorer\n                label=\"Match\"\n                value={activeMatch}\n                defaultExpanded={{}}\n              />\n            </div>\n          </ActivePanel>\n        ) : null}\n        {hasSearch ? (\n          <div\n            style={{\n              flex: '1 1 500px',\n              minHeight: '40%',\n              maxHeight: '100%',\n              overflow: 'auto',\n              borderRight: `1px solid ${theme.grayAlt}`,\n              display: 'flex',\n              flexDirection: 'column',\n            }}\n          >\n            <div\n              style={{\n                padding: '.5em',\n                background: theme.backgroundAlt,\n                position: 'sticky',\n                top: 0,\n                bottom: 0,\n                zIndex: 1,\n                fontWeight: 'bold',\n              }}\n            >\n              Search Params\n            </div>\n            <div\n              style={{\n                padding: '.5em',\n              }}\n            >\n              <Explorer\n                value={routerState.location.search || {}}\n                defaultExpanded={Object.keys(\n                  (routerState.location.search as {}) || {},\n                ).reduce((obj: any, next) => {\n                  obj[next] = {}\n                  return obj\n                }, {})}\n              />\n            </div>\n          </div>\n        ) : null}\n      </Panel>\n    </ThemeProvider>\n  )\n})\n\nfunction AgeTicker({ match }: { match?: AnyRouteMatch }) {\n  const router = useRouter()\n\n  const rerender = React.useReducer(\n    () => ({}),\n    () => ({}),\n  )[1]\n\n  React.useEffect(() => {\n    const interval = setInterval(() => {\n      rerender()\n    }, 1000)\n\n    return () => {\n      clearInterval(interval)\n    }\n  }, [])\n\n  if (!match) {\n    return null\n  }\n\n  const route = router.looseRoutesById[match?.routeId]!\n\n  if (!route.options.loader) {\n    return null\n  }\n\n  const age = Date.now() - match?.updatedAt\n  const staleTime =\n    route.options.staleTime ?? router.options.defaultStaleTime ?? 0\n  const gcTime =\n    route.options.gcTime ?? router.options.defaultGcTime ?? 30 * 60 * 1000\n\n  return (\n    <div\n      style={{\n        display: 'inline-flex',\n        alignItems: 'center',\n        gap: '.25rem',\n        color: age > staleTime ? theme.warning : undefined,\n      }}\n    >\n      <div style={{}}>{formatTime(age)}</div>\n      <div>/</div>\n      <div>{formatTime(staleTime)}</div>\n      <div>/</div>\n      <div>{formatTime(gcTime)}</div>\n    </div>\n  )\n}\n\nfunction formatTime(ms: number) {\n  const units = ['s', 'min', 'h', 'd']\n  const values = [ms / 1000, ms / 60000, ms / 3600000, ms / 86400000]\n\n  let chosenUnitIndex = 0\n  for (let i = 1; i < values.length; i++) {\n    if (values[i]! < 1) break\n    chosenUnitIndex = i\n  }\n\n  const formatter = new Intl.NumberFormat(navigator.language, {\n    compactDisplay: 'short',\n    notation: 'compact',\n    maximumFractionDigits: 0,\n  })\n\n  return formatter.format(values[chosenUnitIndex]!) + units[chosenUnitIndex]\n}\n"],"names":["prefix","isProduction","withSelectorModule","exports","h","require$$0","n","require$$1","q","Object","is","a","b","r","useSyncExternalStore","t","useRef","u","useEffect","v","useMemo","w","useDebugValue","withSelector_production_min","useSyncExternalStoreWithSelector","e","l","g","c","current","f","hasValue","value","d","k","m","shallow","objA","objB","keysA","keys","length","i","prototype","hasOwnProperty","call","routerContext","React","createContext","useRouterState","opts","store","selector","subscribe","state","useStore","useRouter","__store","select","resolvedContext","document","window","__TSR_ROUTER_CONTEXT__","useContext","condition","message","text","console","warn","Error","x","warning","cache","sessionStorage","storageKey","JSON","parse","getItem","cached","next","set","updater","previous","functionalUpdate","setItem","stringify","undefined","key","itemValue","localStorage","useLocalStorage","defaultValue","setValue","useState","initialValue","useCallback","old","newVal","defaultTheme","background","backgroundAlt","foreground","gray","grayAlt","inputBackgroundColor","inputTextColor","success","danger","active","ThemeContext","ThemeProvider","theme","rest","createElement","Provider","_extends","isServer","getStatusColor","match","status","isFetching","getRouteStatusColor","matches","route","found","find","routeId","id","styled","type","newStyles","queries","forwardRef","style","ref","mediaStyles","entries","reduce","query","isMatch","setIsMatch","matchMedia","matcher","onChange","addListener","removeListener","useMediaQuery","useIsMounted","mountedRef","isMounted","useSafeState","initialState","setState","callback","Promise","resolve","then","catch","error","setTimeout","multiSortBy","arr","accessors","map","sort","ai","bi","accessor","ao","bo","Panel","_props","fontSize","fontFamily","display","backgroundColor","color","flexDirection","ActivePanel","flex","overflow","height","(max-width: 700px)","borderTop","Button","props","appearance","fontWeight","border","borderRadius","padding","opacity","disabled","cursor","Code","Entry","lineHeight","outline","wordBreak","Label","LabelButton","ExpandButton","font","Value","SubEntries","marginLeft","paddingLeft","borderLeft","Info","Expander","expanded","transition","transform","DefaultRenderer","handleEntry","label","subEntries","subEntryPages","toggleExpanded","pageSize","renderer","expandedPages","setExpandedPages","valueSnapshot","setValueSnapshot","Fragment","onClick","String","toLowerCase","entry","index","includes","filter","Explorer","refreshValueSnapshot","defaultExpanded","name","getOwnPropertyNames","newValue","toString","displayValue","filterSubEntries","setExpanded","Boolean","makeProperty","sub","subDefaultExpanded","Array","isArray","Symbol","iterator","from","val","array","size","result","push","slice","chunkArray","Logo","alignItems","letterSpacing","backgroundImage","WebkitBackgroundClip","marginRight","RouteComp","isRoot","activeId","setActiveId","routerState","pendingMatches","role","borderBottom","gap","width","justifyContent","path","replace","trimPathRight","trimPathLeft","AgeTicker","children","rank","TanStackRouterDevtoolsPanel","isOpen","setIsOpen","handleDragStart","router","userRouter","panelProps","cachedMatches","invariant","showMatches","setShowMatches","activeMatch","hasSearch","location","search","explorerState","className","dangerouslySetInnerHTML","__html","position","left","top","marginBottom","zIndex","onMouseDown","minHeight","maxHeight","borderRight","overflowY","fromEntries","dd","context","options","maskedLocation","pathname","routeTree","bottom","updatedAt","Date","toLocaleTimeString","loaderData","obj","rerender","useReducer","interval","setInterval","clearInterval","looseRoutesById","loader","age","now","staleTime","defaultStaleTime","gcTime","defaultGcTime","formatTime","ms","values","chosenUnitIndex","Intl","NumberFormat","navigator","language","compactDisplay","notation","maximumFractionDigits","format","initialIsOpen","closeButtonProps","toggleButtonProps","containerElement","Container","rootRef","panelRef","devtoolsHeight","setDevtoolsHeight","isResolvedOpen","setIsResolvedOpen","isResizing","setIsResizing","handlePanelTransitionStart","visibility","handlePanelTransitionEnd","addEventListener","removeEventListener","previousValue","parentElement","paddingBottom","run","containerHeight","getBoundingClientRect","panelStyle","otherPanelProps","closeButtonStyle","onCloseClick","otherCloseButtonProps","toggleButtonStyle","onToggleClick","otherToggleButtonProps","right","boxShadow","transformOrigin","pointerEvents","panelElement","startEvent","button","dragInfo","pageY","moveEvent","delta","newHeight","unsub","margin"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}