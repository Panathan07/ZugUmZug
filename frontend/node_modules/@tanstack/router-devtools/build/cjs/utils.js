/**
 * @tanstack/router-devtools/src/index.tsx
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

var React = require('react');
var theme = require('./theme.js');
var useMediaQuery = require('./useMediaQuery.js');

const isServer = typeof window === 'undefined';
function getStatusColor(match, theme) {
  return match.status === 'pending' || match.isFetching ? theme.active : match.status === 'error' ? theme.danger : match.status === 'success' ? theme.success : theme.gray;
}
function getRouteStatusColor(matches, route, theme) {
  const found = matches.find(d => d.routeId === route.id);
  if (!found) return theme.gray;
  return getStatusColor(found, theme);
}
function styled(type, newStyles, queries = {}) {
  return /*#__PURE__*/React.forwardRef(({
    style,
    ...rest
  }, ref) => {
    const theme$1 = theme.useTheme();
    const mediaStyles = Object.entries(queries).reduce((current, [key, value]) => {
      // eslint-disable-next-line react-hooks/rules-of-hooks
      return useMediaQuery.default(key) ? {
        ...current,
        ...(typeof value === 'function' ? value(rest, theme$1) : value)
      } : current;
    }, {});
    return /*#__PURE__*/React.createElement(type, {
      ...rest,
      style: {
        ...(typeof newStyles === 'function' ? newStyles(rest, theme$1) : newStyles),
        ...style,
        ...mediaStyles
      },
      ref
    });
  });
}
function useIsMounted() {
  const mountedRef = React.useRef(false);
  const isMounted = React.useCallback(() => mountedRef.current, []);
  React[isServer ? 'useEffect' : 'useLayoutEffect'](() => {
    mountedRef.current = true;
    return () => {
      mountedRef.current = false;
    };
  }, []);
  return isMounted;
}

/**
 * Displays a string regardless the type of the data
 * @param {unknown} value Value to be stringified
 */
const displayValue = value => {
  const name = Object.getOwnPropertyNames(Object(value));
  const newValue = typeof value === 'bigint' ? `${value.toString()}n` : value;
  return JSON.stringify(newValue, name);
};

/**
 * This hook is a safe useState version which schedules state updates in microtasks
 * to prevent updating a component state while React is rendering different components
 * or when the component is not mounted anymore.
 */
function useSafeState(initialState) {
  const isMounted = useIsMounted();
  const [state, setState] = React.useState(initialState);
  const safeSetState = React.useCallback(value => {
    scheduleMicrotask(() => {
      if (isMounted()) {
        setState(value);
      }
    });
  }, [isMounted]);
  return [state, safeSetState];
}

/**
 * Schedules a microtask.
 * This can be useful to schedule state updates after rendering.
 */
function scheduleMicrotask(callback) {
  Promise.resolve().then(callback).catch(error => setTimeout(() => {
    throw error;
  }));
}
function multiSortBy(arr, accessors = [d => d]) {
  return arr.map((d, i) => [d, i]).sort(([a, ai], [b, bi]) => {
    for (const accessor of accessors) {
      const ao = accessor(a);
      const bo = accessor(b);
      if (typeof ao === 'undefined') {
        if (typeof bo === 'undefined') {
          continue;
        }
        return 1;
      }
      if (ao === bo) {
        continue;
      }
      return ao > bo ? 1 : -1;
    }
    return ai - bi;
  }).map(([d]) => d);
}

exports.displayValue = displayValue;
exports.getRouteStatusColor = getRouteStatusColor;
exports.getStatusColor = getStatusColor;
exports.isServer = isServer;
exports.multiSortBy = multiSortBy;
exports.styled = styled;
exports.useIsMounted = useIsMounted;
exports.useSafeState = useSafeState;
//# sourceMappingURL=utils.js.map
