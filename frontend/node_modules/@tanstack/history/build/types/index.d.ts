/**
 * @tanstack/history/src/index.ts
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
interface RouterHistory {
    location: HistoryLocation;
    subscribe: (cb: () => void) => () => void;
    push: (path: string, state?: any) => void;
    replace: (path: string, state?: any) => void;
    go: (index: number) => void;
    back: () => void;
    forward: () => void;
    createHref: (href: string) => string;
    block: (blocker: BlockerFn) => () => void;
    flush: () => void;
    destroy: () => void;
    notify: () => void;
}
interface HistoryLocation extends ParsedPath {
    state: HistoryState;
}
interface ParsedPath {
    href: string;
    pathname: string;
    search: string;
    hash: string;
}
interface HistoryState {
    key: string;
}
type ShouldAllowNavigation = any;
type BlockerFn = () => Promise<ShouldAllowNavigation> | ShouldAllowNavigation;
declare function createHistory(opts: {
    getLocation: () => HistoryLocation;
    pushState: (path: string, state: any, onUpdate: () => void) => void;
    replaceState: (path: string, state: any, onUpdate: () => void) => void;
    go: (n: number) => void;
    back: () => void;
    forward: () => void;
    createHref: (path: string) => string;
    flush?: () => void;
    destroy?: () => void;
    onBlocked?: (onUpdate: () => void) => void;
}): RouterHistory;
/**
 * Creates a history object that can be used to interact with the browser's
 * navigation. This is a lightweight API wrapping the browser's native methods.
 * It is designed to work with TanStack Router, but could be used as a standalone API as well.
 * IMPORTANT: This API implements history throttling via a microtask to prevent
 * excessive calls to the history API. In some browsers, calling history.pushState or
 * history.replaceState in quick succession can cause the browser to ignore subsequent
 * calls. This API smooths out those differences and ensures that your application
 * state will *eventually* match the browser state. In most cases, this is not a problem,
 * but if you need to ensure that the browser state is up to date, you can use the
 * `history.flush` method to immediately flush all pending state changes to the browser URL.
 * @param opts
 * @param opts.getHref A function that returns the current href (path + search + hash)
 * @param opts.createHref A function that takes a path and returns a href (path + search + hash)
 * @returns A history instance
 */
declare function createBrowserHistory(opts?: {
    parseLocation?: () => HistoryLocation;
    createHref?: (path: string) => string;
    window?: any;
}): RouterHistory;
declare function createHashHistory(opts?: {
    window?: any;
}): RouterHistory;
declare function createMemoryHistory(opts?: {
    initialEntries: string[];
    initialIndex?: number;
}): RouterHistory;

export { type BlockerFn, type HistoryLocation, type HistoryState, type ParsedPath, type RouterHistory, createBrowserHistory, createHashHistory, createHistory, createMemoryHistory };
