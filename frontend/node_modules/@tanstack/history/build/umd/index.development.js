/**
 * @tanstack/history/src/index.ts
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.TanStackHistory = {}));
})(this, (function (exports) { 'use strict';

  // While the public API was clearly inspired by the "history" npm package,
  // This implementation attempts to be more lightweight by
  // making assumptions about the way TanStack Router works

  const pushStateEvent = 'pushstate';
  const popStateEvent = 'popstate';
  const beforeUnloadEvent = 'beforeunload';
  const beforeUnloadListener = event => {
    event.preventDefault();
    // @ts-ignore
    return event.returnValue = '';
  };
  const stopBlocking = () => {
    removeEventListener(beforeUnloadEvent, beforeUnloadListener, {
      capture: true
    });
  };
  function createHistory(opts) {
    let location = opts.getLocation();
    let subscribers = new Set();
    let blockers = [];
    const onUpdate = () => {
      location = opts.getLocation();
      subscribers.forEach(subscriber => subscriber());
    };
    const tryNavigation = async task => {
      if (typeof document !== 'undefined' && blockers.length) {
        for (let blocker of blockers) {
          const allowed = await blocker();
          if (!allowed) {
            opts.onBlocked?.(onUpdate);
            return;
          }
        }
      }
      task();
    };
    return {
      get location() {
        return location;
      },
      subscribe: cb => {
        subscribers.add(cb);
        return () => {
          subscribers.delete(cb);
        };
      },
      push: (path, state) => {
        state = assignKey(state);
        tryNavigation(() => {
          opts.pushState(path, state, onUpdate);
        });
      },
      replace: (path, state) => {
        state = assignKey(state);
        tryNavigation(() => {
          opts.replaceState(path, state, onUpdate);
        });
      },
      go: index => {
        tryNavigation(() => {
          opts.go(index);
        });
      },
      back: () => {
        tryNavigation(() => {
          opts.back();
        });
      },
      forward: () => {
        tryNavigation(() => {
          opts.forward();
        });
      },
      createHref: str => opts.createHref(str),
      block: blocker => {
        blockers.push(blocker);
        if (blockers.length === 1) {
          addEventListener(beforeUnloadEvent, beforeUnloadListener, {
            capture: true
          });
        }
        return () => {
          blockers = blockers.filter(b => b !== blocker);
          if (!blockers.length) {
            stopBlocking();
          }
        };
      },
      flush: () => opts.flush?.(),
      destroy: () => opts.destroy?.(),
      notify: onUpdate
    };
  }
  function assignKey(state) {
    if (!state) {
      state = {};
    }
    return {
      ...state,
      key: createRandomKey()
    };
  }

  /**
   * Creates a history object that can be used to interact with the browser's
   * navigation. This is a lightweight API wrapping the browser's native methods.
   * It is designed to work with TanStack Router, but could be used as a standalone API as well.
   * IMPORTANT: This API implements history throttling via a microtask to prevent
   * excessive calls to the history API. In some browsers, calling history.pushState or
   * history.replaceState in quick succession can cause the browser to ignore subsequent
   * calls. This API smooths out those differences and ensures that your application
   * state will *eventually* match the browser state. In most cases, this is not a problem,
   * but if you need to ensure that the browser state is up to date, you can use the
   * `history.flush` method to immediately flush all pending state changes to the browser URL.
   * @param opts
   * @param opts.getHref A function that returns the current href (path + search + hash)
   * @param opts.createHref A function that takes a path and returns a href (path + search + hash)
   * @returns A history instance
   */
  function createBrowserHistory(opts) {
    const win = opts?.window ?? (typeof document !== 'undefined' ? window : undefined);
    const createHref = opts?.createHref ?? (path => path);
    const parseLocation = opts?.parseLocation ?? (() => parseHref(`${win.location.pathname}${win.location.search}${win.location.hash}`, win.history.state));
    let currentLocation = parseLocation();
    let rollbackLocation;
    const getLocation = () => currentLocation;
    let next;

    // Because we are proactively updating the location
    // in memory before actually updating the browser history,
    // we need to track when we are doing this so we don't
    // notify subscribers twice on the last update.
    let tracking = true;

    // We need to track the current scheduled update to prevent
    // multiple updates from being scheduled at the same time.
    let scheduled;

    // This function is a wrapper to prevent any of the callback's
    // side effects from causing a subscriber notification
    const untrack = fn => {
      tracking = false;
      fn();
      tracking = true;
    };

    // This function flushes the next update to the browser history
    const flush = () => {
      // Do not notify subscribers about this push/replace call
      untrack(() => {
        if (!next) return;
        win.history[next.isPush ? 'pushState' : 'replaceState'](next.state, '', next.href);
        // Reset the nextIsPush flag and clear the scheduled update
        next = undefined;
        scheduled = undefined;
        rollbackLocation = undefined;
      });
    };

    // This function queues up a call to update the browser history
    const queueHistoryAction = (type, destHref, state, onUpdate) => {
      const href = createHref(destHref);
      if (!scheduled) {
        rollbackLocation = currentLocation;
      }

      // Update the location in memory
      currentLocation = parseHref(destHref, state);

      // Keep track of the next location we need to flush to the URL
      next = {
        href,
        state,
        isPush: next?.isPush || type === 'push'
      };

      // Notify subscribers
      onUpdate();
      if (!scheduled) {
        // Schedule an update to the browser history
        scheduled = Promise.resolve().then(() => flush());
      }
    };
    const onPushPop = () => {
      currentLocation = parseLocation();
      history.notify();
    };
    var originalPushState = win.history.pushState;
    var originalReplaceState = win.history.replaceState;
    const history = createHistory({
      getLocation,
      pushState: (href, state, onUpdate) => queueHistoryAction('push', href, state, onUpdate),
      replaceState: (href, state, onUpdate) => queueHistoryAction('replace', href, state, onUpdate),
      back: () => win.history.back(),
      forward: () => win.history.forward(),
      go: n => win.history.go(n),
      createHref: href => createHref(href),
      flush,
      destroy: () => {
        win.history.pushState = originalPushState;
        win.history.replaceState = originalReplaceState;
        win.removeEventListener(pushStateEvent, onPushPop);
        win.removeEventListener(popStateEvent, onPushPop);
      },
      onBlocked: onUpdate => {
        // If a navigation is blocked, we need to rollback the location
        // that we optimistically updated in memory.
        if (rollbackLocation && currentLocation !== rollbackLocation) {
          currentLocation = rollbackLocation;
          // Notify subscribers
          onUpdate();
        }
      }
    });
    win.addEventListener(pushStateEvent, onPushPop);
    win.addEventListener(popStateEvent, onPushPop);
    win.history.pushState = function () {
      let res = originalPushState.apply(win.history, arguments);
      if (tracking) history.notify();
      return res;
    };
    win.history.replaceState = function () {
      let res = originalReplaceState.apply(win.history, arguments);
      if (tracking) history.notify();
      return res;
    };
    return history;
  }
  function createHashHistory(opts) {
    const win = opts?.window ?? (typeof document !== 'undefined' ? window : undefined);
    return createBrowserHistory({
      window: win,
      parseLocation: () => {
        const hashHref = win.location.hash.split('#').slice(1).join('#') ?? '/';
        return parseHref(hashHref, win.history.state);
      },
      createHref: href => `${win.location.pathname}${win.location.search}#${href}`
    });
  }
  function createMemoryHistory(opts = {
    initialEntries: ['/']
  }) {
    const entries = opts.initialEntries;
    let index = opts.initialIndex ?? entries.length - 1;
    let currentState = {
      key: createRandomKey()
    };
    const getLocation = () => parseHref(entries[index], currentState);
    return createHistory({
      getLocation,
      pushState: (path, state) => {
        currentState = state;
        entries.push(path);
        index++;
      },
      replaceState: (path, state) => {
        currentState = state;
        entries[index] = path;
      },
      back: () => {
        index--;
      },
      forward: () => {
        index = Math.min(index + 1, entries.length - 1);
      },
      go: n => {
        index = Math.min(Math.max(index + n, 0), entries.length - 1);
      },
      createHref: path => path
    });
  }
  function parseHref(href, state) {
    let hashIndex = href.indexOf('#');
    let searchIndex = href.indexOf('?');
    return {
      href,
      pathname: href.substring(0, hashIndex > 0 ? searchIndex > 0 ? Math.min(hashIndex, searchIndex) : hashIndex : searchIndex > 0 ? searchIndex : href.length),
      hash: hashIndex > -1 ? href.substring(hashIndex) : '',
      search: searchIndex > -1 ? href.slice(searchIndex, hashIndex === -1 ? undefined : hashIndex) : '',
      state: state || {}
    };
  }

  // Thanks co-pilot!
  function createRandomKey() {
    return (Math.random() + 1).toString(36).substring(7);
  }

  exports.createBrowserHistory = createBrowserHistory;
  exports.createHashHistory = createHashHistory;
  exports.createHistory = createHistory;
  exports.createMemoryHistory = createMemoryHistory;

}));
//# sourceMappingURL=index.development.js.map
