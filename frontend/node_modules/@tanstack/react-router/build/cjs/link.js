/**
 * @tanstack/react-router/src/index.tsx
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

var _rollupPluginBabelHelpers = require('./_virtual/_rollupPluginBabelHelpers.js');
var React = require('react');
var Matches = require('./Matches.js');
var RouterProvider = require('./RouterProvider.js');
var utils = require('./utils.js');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);

const preloadWarning = 'Error preloading route! ☝️';
function useLinkProps(options) {
  const router = RouterProvider.useRouter();
  const matchPathname = Matches.useMatch({
    strict: false,
    select: s => s.pathname
  });
  const {
    // custom props
    children,
    target,
    activeProps = () => ({
      className: 'active'
    }),
    inactiveProps = () => ({}),
    activeOptions,
    disabled,
    hash,
    search,
    params,
    to,
    state,
    mask,
    preload: userPreload,
    preloadDelay: userPreloadDelay,
    replace,
    startTransition,
    resetScroll,
    // element props
    style,
    className,
    onClick,
    onFocus,
    onMouseEnter,
    onMouseLeave,
    onTouchStart,
    ...rest
  } = options;

  // If this link simply reloads the current route,
  // make sure it has a new key so it will trigger a data refresh

  // If this `to` is a valid external URL, return
  // null for LinkUtils

  const dest = {
    from: options.to ? matchPathname : undefined,
    ...options
  };
  let type = 'internal';
  try {
    new URL(`${to}`);
    type = 'external';
  } catch {}
  if (type === 'external') {
    return {
      href: to
    };
  }
  const next = router.buildLocation(dest);
  const preload = userPreload ?? router.options.defaultPreload;
  const preloadDelay = userPreloadDelay ?? router.options.defaultPreloadDelay ?? 0;
  const isActive = RouterProvider.useRouterState({
    select: s => {
      // Compare path/hash for matches
      const currentPathSplit = s.location.pathname.split('/');
      const nextPathSplit = next.pathname.split('/');
      const pathIsFuzzyEqual = nextPathSplit.every((d, i) => d === currentPathSplit[i]);
      // Combine the matches based on user router.options
      const pathTest = activeOptions?.exact ? s.location.pathname === next.pathname : pathIsFuzzyEqual;
      const hashTest = activeOptions?.includeHash ? s.location.hash === next.hash : true;
      const searchTest = activeOptions?.includeSearch ?? true ? utils.deepEqual(s.location.search, next.search, !activeOptions?.exact) : true;

      // The final "active" test
      return pathTest && hashTest && searchTest;
    }
  });

  // The click handler
  const handleClick = e => {
    if (!disabled && !isCtrlEvent(e) && !e.defaultPrevented && (!target || target === '_self') && e.button === 0) {
      e.preventDefault();

      // All is well? Navigate!
      router.commitLocation({
        ...next,
        replace,
        resetScroll,
        startTransition
      });
    }
  };

  // The click handler
  const handleFocus = e => {
    if (preload) {
      router.preloadRoute(dest).catch(err => {
        console.warn(err);
        console.warn(preloadWarning);
      });
    }
  };
  const handleTouchStart = e => {
    if (preload) {
      router.preloadRoute(dest).catch(err => {
        console.warn(err);
        console.warn(preloadWarning);
      });
    }
  };
  const handleEnter = e => {
    const target = e.target || {};
    if (preload) {
      if (target.preloadTimeout) {
        return;
      }
      target.preloadTimeout = setTimeout(() => {
        target.preloadTimeout = null;
        router.preloadRoute(dest).catch(err => {
          console.warn(err);
          console.warn(preloadWarning);
        });
      }, preloadDelay);
    }
  };
  const handleLeave = e => {
    const target = e.target || {};
    if (target.preloadTimeout) {
      clearTimeout(target.preloadTimeout);
      target.preloadTimeout = null;
    }
  };
  const composeHandlers = handlers => e => {
    if (e.persist) e.persist();
    handlers.filter(Boolean).forEach(handler => {
      if (e.defaultPrevented) return;
      handler(e);
    });
  };

  // Get the active props
  const resolvedActiveProps = isActive ? utils.functionalUpdate(activeProps, {}) ?? {} : {};

  // Get the inactive props
  const resolvedInactiveProps = isActive ? {} : utils.functionalUpdate(inactiveProps, {}) ?? {};
  return {
    ...resolvedActiveProps,
    ...resolvedInactiveProps,
    ...rest,
    href: disabled ? undefined : next.maskedLocation ? next.maskedLocation.href : next.href,
    onClick: composeHandlers([onClick, handleClick]),
    onFocus: composeHandlers([onFocus, handleFocus]),
    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),
    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),
    onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),
    target,
    style: {
      ...style,
      ...resolvedActiveProps.style,
      ...resolvedInactiveProps.style
    },
    className: [className, resolvedActiveProps.className, resolvedInactiveProps.className].filter(Boolean).join(' ') || undefined,
    ...(disabled ? {
      role: 'link',
      'aria-disabled': true
    } : undefined),
    ['data-status']: isActive ? 'active' : undefined
  };
}
const Link = /*#__PURE__*/React__namespace.forwardRef((props, ref) => {
  const linkProps = useLinkProps(props);
  return /*#__PURE__*/React__namespace.createElement("a", _rollupPluginBabelHelpers.extends({
    ref: ref
  }, linkProps, {
    children: typeof props.children === 'function' ? props.children({
      isActive: linkProps['data-status'] === 'active'
    }) : props.children
  }));
});
function isCtrlEvent(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}

exports.Link = Link;
exports.useLinkProps = useLinkProps;
//# sourceMappingURL=link.js.map
