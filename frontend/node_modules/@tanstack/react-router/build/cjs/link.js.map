{"version":3,"file":"link.js","sources":["../../src/link.tsx"],"sourcesContent":["import * as React from 'react'\nimport { useMatch } from './Matches'\nimport { useRouter, useRouterState } from './RouterProvider'\nimport { Trim } from './fileRoute'\nimport { AnyRoute, ReactNode } from './route'\nimport {\n  AllParams,\n  FullSearchSchema,\n  RouteByPath,\n  RouteIds,\n  RoutePaths,\n} from './routeInfo'\nimport { RegisteredRouter } from './router'\nimport { LinkProps, UseLinkPropsOptions } from './useNavigate'\nimport {\n  Expand,\n  NoInfer,\n  NonNullableUpdater,\n  PickRequired,\n  UnionToIntersection,\n  Updater,\n  deepEqual,\n  functionalUpdate,\n} from './utils'\nimport { HistoryState } from '@tanstack/history'\n\nexport type CleanPath<T extends string> = T extends `${infer L}//${infer R}`\n  ? CleanPath<`${CleanPath<L>}/${CleanPath<R>}`>\n  : T extends `${infer L}//`\n    ? `${CleanPath<L>}/`\n    : T extends `//${infer L}`\n      ? `/${CleanPath<L>}`\n      : T\n\nexport type Split<S, TIncludeTrailingSlash = true> = S extends unknown\n  ? string extends S\n    ? string[]\n    : S extends string\n      ? CleanPath<S> extends ''\n        ? []\n        : TIncludeTrailingSlash extends true\n          ? CleanPath<S> extends `${infer T}/`\n            ? [...Split<T>, '/']\n            : CleanPath<S> extends `/${infer U}`\n              ? Split<U>\n              : CleanPath<S> extends `${infer T}/${infer U}`\n                ? [...Split<T>, ...Split<U>]\n                : [S]\n          : CleanPath<S> extends `${infer T}/${infer U}`\n            ? [...Split<T>, ...Split<U>]\n            : S extends string\n              ? [S]\n              : never\n      : never\n  : never\n\nexport type ParsePathParams<T extends string> = keyof {\n  [K in Trim<Split<T>[number], '_'> as K extends `$${infer L}` ? L : never]: K\n}\n\nexport type Join<T, Delimiter extends string = '/'> = T extends []\n  ? ''\n  : T extends [infer L extends string]\n    ? L\n    : T extends [infer L extends string, ...infer Tail extends [...string[]]]\n      ? CleanPath<`${L}${Delimiter}${Join<Tail>}`>\n      : never\n\nexport type Last<T extends any[]> = T extends [...infer _, infer L] ? L : never\n\nexport type RelativeToPathAutoComplete<\n  AllPaths extends string,\n  TFrom extends string,\n  TTo extends string,\n  SplitPaths extends string[] = Split<AllPaths, false>,\n> = TTo extends `..${infer _}`\n  ? SplitPaths extends [\n      ...Split<ResolveRelativePath<TFrom, TTo>, false>,\n      ...infer TToRest,\n    ]\n    ? `${CleanPath<\n        Join<\n          [\n            ...Split<TTo, false>,\n            ...(\n              | TToRest\n              | (Split<\n                  ResolveRelativePath<TFrom, TTo>,\n                  false\n                >['length'] extends 1\n                  ? never\n                  : ['../'])\n            ),\n          ]\n        >\n      >}`\n    : never\n  : TTo extends `./${infer RestTTo}`\n    ? SplitPaths extends [\n        ...Split<TFrom, false>,\n        ...Split<RestTTo, false>,\n        ...infer RestPath,\n      ]\n      ? `${TTo}${Join<RestPath>}`\n      : never\n    :\n        | (TFrom extends `/`\n            ? never\n            : SplitPaths extends [...Split<TFrom, false>, ...infer RestPath]\n              ? Join<RestPath> extends { length: 0 }\n                ? never\n                : './'\n              : never)\n        | (TFrom extends `/` ? never : '../')\n        | AllPaths\n\nexport type NavigateOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n> = ToOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // `replace` is a boolean that determines whether the navigation should replace the current history entry or push a new one.\n  replace?: boolean\n  resetScroll?: boolean\n  // If set to `true`, the link's underlying navigate() call will be wrapped in a `React.startTransition` call. Defaults to `true`.\n  startTransition?: boolean\n}\n\nexport type ToOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ToSubOptions<TRouteTree, TFrom, TTo> & {\n  mask?: ToMaskOptions<TRouteTree, TMaskFrom, TMaskTo>\n}\n\nexport type ToMaskOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ToSubOptions<TRouteTree, TMaskFrom, TMaskTo> & {\n  unmaskOnReload?: boolean\n}\n\nexport type ToSubOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n> = {\n  to?: ToPathOption<TRouteTree, TFrom, TTo>\n  // The new has string or a function to update it\n  hash?: true | Updater<string>\n  // State to pass to the history stack\n  state?: true | NonNullableUpdater<HistoryState>\n  // The source route path. This is automatically set when using route-level APIs, but for type-safe relative routing on the router itself, this is required\n  from?: TFrom\n  // // When using relative route paths, this option forces resolution from the current path, instead of the route API's path or `from` path\n} & CheckPath<TRouteTree, NoInfer<TResolved>, {}> &\n  SearchParamOptions<TRouteTree, TFrom, TTo, TResolved> &\n  PathParamOptions<TRouteTree, TFrom, TResolved>\n\nexport type SearchParamOptions<\n  TRouteTree extends AnyRoute,\n  TFrom,\n  TTo,\n  TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n  TFromSearchEnsured = '/' extends TFrom\n    ? FullSearchSchema<TRouteTree>\n    : Expand<\n          PickRequired<\n            RouteByPath<TRouteTree, TFrom>['types']['fullSearchSchema']\n          >\n      >,\n  TFromSearchOptional = Omit<\n    FullSearchSchema<TRouteTree>,\n    keyof TFromSearchEnsured\n  >,\n  TFromSearch = Expand<TFromSearchEnsured & TFromSearchOptional>,\n  TToSearch = '' extends TTo\n    ? FullSearchSchema<TRouteTree>\n    : Expand<RouteByPath<TRouteTree, TResolved>['types']['fullSearchSchema']>,\n> = keyof PickRequired<TToSearch> extends never\n  ? {\n      search?: true | SearchReducer<TFromSearch, TToSearch>\n    }\n  : {\n      search: TFromSearchEnsured extends PickRequired<TToSearch>\n        ? true | SearchReducer<TFromSearch, TToSearch>\n        : SearchReducer<TFromSearch, TToSearch>\n    }\n\ntype SearchReducer<TFrom, TTo> = TTo | ((current: TFrom) => TTo)\n\nexport type PathParamOptions<\n  TRouteTree extends AnyRoute,\n  TFrom,\n  TTo,\n  TFromParamsEnsured = Expand<\n    UnionToIntersection<\n      PickRequired<RouteByPath<TRouteTree, TFrom>['types']['allParams']>\n    >\n  >,\n  TFromParamsOptional = Omit<AllParams<TRouteTree>, keyof TFromParamsEnsured>,\n  TFromParams = Expand<TFromParamsOptional & TFromParamsEnsured>,\n  TToParams = Expand<RouteByPath<TRouteTree, TTo>['types']['allParams']>,\n> = never extends TToParams\n  ? {\n      params?: true | ParamsReducer<Partial<TFromParams>, Partial<TFromParams>>\n    }\n  : keyof PickRequired<TToParams> extends never\n    ? {\n        params?: true | ParamsReducer<TFromParams, TToParams>\n      }\n    : {\n        params: TFromParamsEnsured extends PickRequired<TToParams>\n          ? true | ParamsReducer<TFromParams, TToParams>\n          : ParamsReducer<TFromParams, TToParams>\n      }\n\ntype ParamsReducer<TFrom, TTo> = TTo | ((current: TFrom) => TTo)\n\nexport type ToPathOption<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n> =\n  | TTo\n  | RelativeToPathAutoComplete<\n      RoutePaths<TRouteTree>,\n      NoInfer<TFrom> extends string ? NoInfer<TFrom> : '',\n      NoInfer<TTo> & string\n    >\n\nexport type ToIdOption<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n> =\n  | TTo\n  | RelativeToPathAutoComplete<\n      RouteIds<TRouteTree>,\n      NoInfer<TFrom> extends string ? NoInfer<TFrom> : '',\n      NoInfer<TTo> & string\n    >\n\nexport interface ActiveOptions {\n  exact?: boolean\n  includeHash?: boolean\n  includeSearch?: boolean\n}\n\nexport type LinkOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n> = NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // The standard anchor tag target attribute\n  target?: HTMLAnchorElement['target']\n  // Defaults to `{ exact: false, includeHash: false }`\n  activeOptions?: ActiveOptions\n  // If set, will preload the linked route on hover and cache it for this many milliseconds in hopes that the user will eventually navigate there.\n  preload?: false | 'intent'\n  // Delay intent preloading by this many milliseconds. If the intent exits before this delay, the preload will be cancelled.\n  preloadDelay?: number\n  // If true, will render the link without the href attribute\n  disabled?: boolean\n}\n\nexport type CheckRelativePath<\n  TRouteTree extends AnyRoute,\n  TFrom,\n  TTo,\n> = TTo extends string\n  ? TFrom extends string\n    ? ResolveRelativePath<TFrom, TTo> extends RoutePaths<TRouteTree>\n      ? {}\n      : {\n          Error: `${TFrom} + ${TTo} resolves to ${ResolveRelativePath<\n            TFrom,\n            TTo\n          >}, which is not a valid route path.`\n          'Valid Route Paths': RoutePaths<TRouteTree>\n        }\n    : {}\n  : {}\n\nexport type CheckPath<TRouteTree extends AnyRoute, TPath, TPass> = Exclude<\n  TPath,\n  RoutePaths<TRouteTree>\n> extends never\n  ? TPass\n  : CheckPathError<TRouteTree, Exclude<TPath, RoutePaths<TRouteTree>>>\n\nexport type CheckPathError<TRouteTree extends AnyRoute, TInvalids> = {\n  to: RoutePaths<TRouteTree>\n}\n\nexport type CheckId<TRouteTree extends AnyRoute, TPath, TPass> = Exclude<\n  TPath,\n  RouteIds<TRouteTree>\n> extends never\n  ? TPass\n  : CheckIdError<TRouteTree, Exclude<TPath, RouteIds<TRouteTree>>>\n\nexport type CheckIdError<TRouteTree extends AnyRoute, TInvalids> = {\n  Error: `${TInvalids extends string\n    ? TInvalids\n    : never} is not a valid route ID.`\n  'Valid Route IDs': RouteIds<TRouteTree>\n}\n\nexport type ResolveRelativePath<TFrom, TTo = '.'> = TFrom extends string\n  ? TTo extends string\n    ? TTo extends '.'\n      ? TFrom\n      : TTo extends `./`\n        ? Join<[TFrom, '/']>\n        : TTo extends `./${infer TRest}`\n          ? ResolveRelativePath<TFrom, TRest>\n          : TTo extends `/${infer TRest}`\n            ? TTo\n            : Split<TTo> extends ['..', ...infer ToRest]\n              ? Split<TFrom> extends [...infer FromRest, infer FromTail]\n                ? ToRest extends ['/']\n                  ? Join<[...FromRest, '/']>\n                  : ResolveRelativePath<Join<FromRest>, Join<ToRest>>\n                : never\n              : Split<TTo> extends ['.', ...infer ToRest]\n                ? ToRest extends ['/']\n                  ? Join<[TFrom, '/']>\n                  : ResolveRelativePath<TFrom, Join<ToRest>>\n                : CleanPath<Join<['/', ...Split<TFrom>, ...Split<TTo>]>>\n    : never\n  : never\n\ntype LinkCurrentTargetElement = {\n  preloadTimeout?: null | ReturnType<typeof setTimeout>\n}\n\nconst preloadWarning = 'Error preloading route! ☝️'\n\nexport function useLinkProps<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n>(\n  options: UseLinkPropsOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n): React.AnchorHTMLAttributes<HTMLAnchorElement> {\n  const router = useRouter()\n  const matchPathname = useMatch({\n    strict: false,\n    select: (s) => s.pathname,\n  })\n\n  const {\n    // custom props\n    children,\n    target,\n    activeProps = () => ({ className: 'active' }),\n    inactiveProps = () => ({}),\n    activeOptions,\n    disabled,\n    hash,\n    search,\n    params,\n    to,\n    state,\n    mask,\n    preload: userPreload,\n    preloadDelay: userPreloadDelay,\n    replace,\n    startTransition,\n    resetScroll,\n    // element props\n    style,\n    className,\n    onClick,\n    onFocus,\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart,\n    ...rest\n  } = options\n\n  // If this link simply reloads the current route,\n  // make sure it has a new key so it will trigger a data refresh\n\n  // If this `to` is a valid external URL, return\n  // null for LinkUtils\n\n  const dest = {\n    from: options.to ? matchPathname : undefined,\n    ...options,\n  }\n\n  let type: 'internal' | 'external' = 'internal'\n\n  try {\n    new URL(`${to}`)\n    type = 'external'\n  } catch {}\n\n  if (type === 'external') {\n    return {\n      href: to,\n    }\n  }\n\n  const next = router.buildLocation(dest as any)\n\n  const preload = userPreload ?? router.options.defaultPreload\n  const preloadDelay =\n    userPreloadDelay ?? router.options.defaultPreloadDelay ?? 0\n\n  const isActive = useRouterState({\n    select: (s) => {\n      // Compare path/hash for matches\n      const currentPathSplit = s.location.pathname.split('/')\n      const nextPathSplit = next.pathname.split('/')\n      const pathIsFuzzyEqual = nextPathSplit.every(\n        (d, i) => d === currentPathSplit[i],\n      )\n      // Combine the matches based on user router.options\n      const pathTest = activeOptions?.exact\n        ? s.location.pathname === next.pathname\n        : pathIsFuzzyEqual\n      const hashTest = activeOptions?.includeHash\n        ? s.location.hash === next.hash\n        : true\n      const searchTest =\n        activeOptions?.includeSearch ?? true\n          ? deepEqual(s.location.search, next.search, !activeOptions?.exact)\n          : true\n\n      // The final \"active\" test\n      return pathTest && hashTest && searchTest\n    },\n  })\n\n  // The click handler\n  const handleClick = (e: MouseEvent) => {\n    if (\n      !disabled &&\n      !isCtrlEvent(e) &&\n      !e.defaultPrevented &&\n      (!target || target === '_self') &&\n      e.button === 0\n    ) {\n      e.preventDefault()\n\n      // All is well? Navigate!\n      router.commitLocation({ ...next, replace, resetScroll, startTransition })\n    }\n  }\n\n  // The click handler\n  const handleFocus = (e: MouseEvent) => {\n    if (preload) {\n      router.preloadRoute(dest as any).catch((err) => {\n        console.warn(err)\n        console.warn(preloadWarning)\n      })\n    }\n  }\n\n  const handleTouchStart = (e: TouchEvent) => {\n    if (preload) {\n      router.preloadRoute(dest as any).catch((err) => {\n        console.warn(err)\n        console.warn(preloadWarning)\n      })\n    }\n  }\n\n  const handleEnter = (e: MouseEvent) => {\n    const target = (e.target || {}) as LinkCurrentTargetElement\n\n    if (preload) {\n      if (target.preloadTimeout) {\n        return\n      }\n\n      target.preloadTimeout = setTimeout(() => {\n        target.preloadTimeout = null\n        router.preloadRoute(dest as any).catch((err) => {\n          console.warn(err)\n          console.warn(preloadWarning)\n        })\n      }, preloadDelay)\n    }\n  }\n\n  const handleLeave = (e: MouseEvent) => {\n    const target = (e.target || {}) as LinkCurrentTargetElement\n\n    if (target.preloadTimeout) {\n      clearTimeout(target.preloadTimeout)\n      target.preloadTimeout = null\n    }\n  }\n\n  const composeHandlers =\n    (handlers: (undefined | ((e: any) => void))[]) =>\n    (e: React.SyntheticEvent) => {\n      if (e.persist) e.persist()\n      handlers.filter(Boolean).forEach((handler) => {\n        if (e.defaultPrevented) return\n        handler!(e)\n      })\n    }\n\n  // Get the active props\n  const resolvedActiveProps: React.HTMLAttributes<HTMLAnchorElement> = isActive\n    ? functionalUpdate(activeProps as any, {}) ?? {}\n    : {}\n\n  // Get the inactive props\n  const resolvedInactiveProps: React.HTMLAttributes<HTMLAnchorElement> =\n    isActive ? {} : functionalUpdate(inactiveProps, {}) ?? {}\n\n  return {\n    ...resolvedActiveProps,\n    ...resolvedInactiveProps,\n    ...rest,\n    href: disabled\n      ? undefined\n      : next.maskedLocation\n        ? next.maskedLocation.href\n        : next.href,\n    onClick: composeHandlers([onClick, handleClick]),\n    onFocus: composeHandlers([onFocus, handleFocus]),\n    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),\n    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),\n    onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),\n    target,\n    style: {\n      ...style,\n      ...resolvedActiveProps.style,\n      ...resolvedInactiveProps.style,\n    },\n    className:\n      [\n        className,\n        resolvedActiveProps.className,\n        resolvedInactiveProps.className,\n      ]\n        .filter(Boolean)\n        .join(' ') || undefined,\n    ...(disabled\n      ? {\n          role: 'link',\n          'aria-disabled': true,\n        }\n      : undefined),\n    ['data-status']: isActive ? 'active' : undefined,\n  }\n}\n\nexport interface LinkComponent<TProps extends Record<string, any> = {}> {\n  <\n    TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n    TFrom extends RoutePaths<TRouteTree> = '/',\n    TTo extends string = '',\n    TMaskFrom extends RoutePaths<TRouteTree> = '/',\n    TMaskTo extends string = '',\n  >(\n    props: LinkProps<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> &\n      TProps &\n      React.RefAttributes<HTMLAnchorElement>,\n  ): ReactNode\n}\n\nexport const Link: LinkComponent = React.forwardRef((props: any, ref) => {\n  const linkProps = useLinkProps(props)\n\n  return (\n    <a\n      {...{\n        ref: ref as any,\n        ...linkProps,\n        children:\n          typeof props.children === 'function'\n            ? props.children({\n                isActive: (linkProps as any)['data-status'] === 'active',\n              })\n            : props.children,\n      }}\n    />\n  )\n}) as any\n\nfunction isCtrlEvent(e: MouseEvent) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n}\n"],"names":["preloadWarning","useLinkProps","options","router","useRouter","matchPathname","useMatch","strict","select","s","pathname","children","target","activeProps","className","inactiveProps","activeOptions","disabled","hash","search","params","to","state","mask","preload","userPreload","preloadDelay","userPreloadDelay","replace","startTransition","resetScroll","style","onClick","onFocus","onMouseEnter","onMouseLeave","onTouchStart","rest","dest","from","undefined","type","URL","href","next","buildLocation","defaultPreload","defaultPreloadDelay","isActive","useRouterState","currentPathSplit","location","split","nextPathSplit","pathIsFuzzyEqual","every","d","i","pathTest","exact","hashTest","includeHash","searchTest","includeSearch","deepEqual","handleClick","e","isCtrlEvent","defaultPrevented","button","preventDefault","commitLocation","handleFocus","preloadRoute","catch","err","console","warn","handleTouchStart","handleEnter","preloadTimeout","setTimeout","handleLeave","clearTimeout","composeHandlers","handlers","persist","filter","Boolean","forEach","handler","resolvedActiveProps","functionalUpdate","resolvedInactiveProps","maskedLocation","join","role","Link","React","forwardRef","props","ref","linkProps","createElement","_extends","metaKey","altKey","ctrlKey","shiftKey"],"mappings":"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"}