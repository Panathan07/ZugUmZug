{"version":3,"file":"route.js","sources":["../../src/route.ts"],"sourcesContent":["import * as React from 'react'\nimport invariant from 'tiny-invariant'\nimport { useLoaderData, useLoaderDeps, useMatch } from './Matches'\nimport { AnyRouteMatch } from './Matches'\nimport { NavigateOptions, ParsePathParams, ToSubOptions } from './link'\nimport { ParsedLocation } from './location'\nimport { joinPaths, trimPath } from './path'\nimport { RouteById, RouteIds, RoutePaths } from './routeInfo'\nimport { AnyRouter, RegisteredRouter } from './router'\nimport { useParams } from './useParams'\nimport { useSearch } from './useSearch'\nimport {\n  Assign,\n  Expand,\n  IsAny,\n  NoInfer,\n  PickRequired,\n  UnionToIntersection,\n} from './utils'\nimport { BuildLocationFn, NavigateFn } from './RouterProvider'\n\nexport const rootRouteId = '__root__' as const\nexport type RootRouteId = typeof rootRouteId\nexport type AnyPathParams = {}\n\nexport type AnySearchSchema = {}\n\nexport type AnyContext = {}\n\nexport interface RouteContext {}\n\nexport interface RouteMeta {}\n\nexport type PreloadableObj = { preload?: () => Promise<void> }\n\nexport type RoutePathOptions<TCustomId, TPath> =\n  | {\n      path: TPath\n    }\n  | {\n      id: TCustomId\n    }\n\nexport type RoutePathOptionsIntersection<TCustomId, TPath> =\n  UnionToIntersection<RoutePathOptions<TCustomId, TPath>>\n\nexport type MetaOptions = keyof PickRequired<RouteMeta> extends never\n  ? {\n      meta?: RouteMeta\n    }\n  : {\n      meta: RouteMeta\n    }\n\nexport type RouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TCustomId extends string = string,\n  TPath extends string = string,\n  TSearchSchema extends Record<string, any> = {},\n  TFullSearchSchema extends Record<string, any> = TSearchSchema,\n  TParams extends AnyPathParams = AnyPathParams,\n  TAllParams extends AnyPathParams = TParams,\n  TRouteContext extends RouteContext = RouteContext,\n  TAllContext extends Record<string, any> = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderData extends any = unknown,\n> = BaseRouteOptions<\n  TParentRoute,\n  TCustomId,\n  TPath,\n  TSearchSchema,\n  TFullSearchSchema,\n  TParams,\n  TAllParams,\n  TRouteContext,\n  TAllContext,\n  TLoaderDeps,\n  TLoaderData\n> &\n  UpdatableRouteOptions<NoInfer<TFullSearchSchema>>\n\nexport type ParamsFallback<\n  TPath extends string,\n  TParams,\n> = unknown extends TParams ? Record<ParsePathParams<TPath>, string> : TParams\n\nexport type BaseRouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TCustomId extends string = string,\n  TPath extends string = string,\n  TSearchSchema extends Record<string, any> = {},\n  TFullSearchSchema extends Record<string, any> = TSearchSchema,\n  TParams extends AnyPathParams = {},\n  TAllParams = ParamsFallback<TPath, TParams>,\n  TRouteContext extends RouteContext = RouteContext,\n  TAllContext extends Record<string, any> = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderData extends any = unknown,\n> = RoutePathOptions<TCustomId, TPath> & {\n  getParentRoute: () => TParentRoute\n  validateSearch?: SearchSchemaValidator<TSearchSchema>\n  shouldReload?:\n    | boolean\n    | ((\n        match: LoaderFnContext<\n          TAllParams,\n          TFullSearchSchema,\n          TAllContext,\n          TRouteContext\n        >,\n      ) => any)\n} & (keyof PickRequired<RouteContext> extends never\n    ? // This async function is called before a route is loaded.\n      // If an error is thrown here, the route's loader will not be called.\n      // If thrown during a navigation, the navigation will be cancelled and the error will be passed to the `onError` function.\n      // If thrown during a preload event, the error will be logged to the console.\n      {\n        beforeLoad?: BeforeLoadFn<\n          TFullSearchSchema,\n          TParentRoute,\n          TAllParams,\n          TRouteContext\n        >\n      }\n    : {\n        beforeLoad: BeforeLoadFn<\n          TFullSearchSchema,\n          TParentRoute,\n          TAllParams,\n          TRouteContext\n        >\n      }) & {\n    loaderDeps?: (opts: { search: TFullSearchSchema }) => TLoaderDeps\n    loader?: RouteLoaderFn<\n      TAllParams,\n      NoInfer<TLoaderDeps>,\n      NoInfer<TAllContext>,\n      NoInfer<TRouteContext>,\n      TLoaderData\n    >\n  } & (\n    | {\n        // Both or none\n        parseParams?: (\n          rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>,\n        ) => TParams extends Record<ParsePathParams<TPath>, any>\n          ? TParams\n          : 'parseParams must return an object'\n        stringifyParams?: (\n          params: NoInfer<ParamsFallback<TPath, TParams>>,\n        ) => Record<ParsePathParams<TPath>, string>\n      }\n    | {\n        stringifyParams?: never\n        parseParams?: never\n      }\n  )\n\ntype BeforeLoadFn<\n  TFullSearchSchema extends Record<string, any>,\n  TParentRoute extends AnyRoute,\n  TAllParams,\n  TRouteContext,\n> = (opts: {\n  search: TFullSearchSchema\n  abortController: AbortController\n  preload: boolean\n  params: TAllParams\n  context: TParentRoute['types']['allContext']\n  location: ParsedLocation\n  navigate: NavigateFn<AnyRoute>\n  buildLocation: BuildLocationFn<TParentRoute>\n  cause: 'preload' | 'enter' | 'stay'\n}) => Promise<TRouteContext> | TRouteContext | void\n\nexport type UpdatableRouteOptions<\n  TFullSearchSchema extends Record<string, any>,\n> = MetaOptions & {\n  // test?: (args: TAllContext) => void\n  // If true, this route will be matched as case-sensitive\n  caseSensitive?: boolean\n  // If true, this route will be forcefully wrapped in a suspense boundary\n  wrapInSuspense?: boolean\n  // The content to be rendered when the route is matched. If no component is provided, defaults to `<Outlet />`\n  component?: RouteComponent\n  errorComponent?: false | null | ErrorRouteComponent\n  pendingComponent?: RouteComponent\n  pendingMs?: number\n  pendingMinMs?: number\n  staleTime?: number\n  gcTime?: number\n  preloadStaleTime?: number\n  preloadGcTime?: number\n  // Filter functions that can manipulate search params *before* they are passed to links and navigate\n  // calls that match this route.\n  preSearchFilters?: SearchFilter<TFullSearchSchema>[]\n  // Filter functions that can manipulate search params *after* they are passed to links and navigate\n  // calls that match this route.\n  postSearchFilters?: SearchFilter<TFullSearchSchema>[]\n  onError?: (err: any) => void\n  // These functions are called as route matches are loaded, stick around and leave the active\n  // matches\n  onEnter?: (match: AnyRouteMatch) => void\n  onStay?: (match: AnyRouteMatch) => void\n  onLeave?: (match: AnyRouteMatch) => void\n}\n\nexport type ParseParamsOption<TPath extends string, TParams> = ParseParamsFn<\n  TPath,\n  TParams\n>\n\nexport type ParseParamsFn<TPath extends string, TParams> = (\n  rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>,\n) => TParams extends Record<ParsePathParams<TPath>, any>\n  ? TParams\n  : 'parseParams must return an object'\n\nexport type ParseParamsObj<TPath extends string, TParams> = {\n  parse?: ParseParamsFn<TPath, TParams>\n}\n\n// The parse type here allows a zod schema to be passed directly to the validator\nexport type SearchSchemaValidator<TReturn> =\n  | SearchSchemaValidatorObj<TReturn>\n  | SearchSchemaValidatorFn<TReturn>\n\nexport type SearchSchemaValidatorObj<TReturn> = {\n  parse?: SearchSchemaValidatorFn<TReturn>\n}\n\nexport type SearchSchemaValidatorFn<TReturn> = (\n  searchObj: Record<string, unknown>,\n) => TReturn\n\nexport type DefinedPathParamWarning =\n  'Path params cannot be redefined by child routes!'\n\nexport type ParentParams<TParentParams> = AnyPathParams extends TParentParams\n  ? {}\n  : {\n      [Key in keyof TParentParams]?: DefinedPathParamWarning\n    }\n\nexport type RouteLoaderFn<\n  TAllParams = {},\n  TLoaderDeps extends Record<string, any> = {},\n  TAllContext extends Record<string, any> = AnyContext,\n  TRouteContext extends Record<string, any> = AnyContext,\n  TLoaderData extends any = unknown,\n> = (\n  match: LoaderFnContext<TAllParams, TLoaderDeps, TAllContext, TRouteContext>,\n) => Promise<TLoaderData> | TLoaderData\n\nexport interface LoaderFnContext<\n  TAllParams = {},\n  TLoaderDeps extends Record<string, any> = {},\n  TAllContext extends Record<string, any> = AnyContext,\n  TRouteContext extends Record<string, any> = AnyContext,\n> {\n  abortController: AbortController\n  preload: boolean\n  params: TAllParams\n  deps: TLoaderDeps\n  context: Expand<Assign<TAllContext, TRouteContext>>\n  location: ParsedLocation // Do not supply search schema here so as to demotivate people from trying to shortcut loaderDeps\n  navigate: (opts: NavigateOptions<AnyRoute>) => Promise<void>\n  parentMatchPromise?: Promise<void>\n  cause: 'preload' | 'enter' | 'stay'\n}\n\nexport type SearchFilter<T, U = T> = (prev: T) => U\n\nexport type ResolveId<\n  TParentRoute,\n  TCustomId extends string,\n  TPath extends string,\n> = TParentRoute extends { id: infer TParentId extends string }\n  ? RoutePrefix<TParentId, string extends TCustomId ? TPath : TCustomId>\n  : RootRouteId\n\nexport type InferFullSearchSchema<TRoute> = TRoute extends {\n  types: {\n    fullSearchSchema: infer TFullSearchSchema\n  }\n}\n  ? TFullSearchSchema\n  : {}\n\nexport type ResolveFullSearchSchema<TParentRoute, TSearchSchema> = Expand<\n  Assign<InferFullSearchSchema<TParentRoute>, TSearchSchema>\n>\n\nexport interface AnyRoute\n  extends Route<\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  > {}\n\nexport type MergeFromFromParent<T, U> = IsAny<T, U, T & U>\n\nexport type ResolveAllParams<\n  TParentRoute extends AnyRoute,\n  TParams extends AnyPathParams,\n> = Record<never, string> extends TParentRoute['types']['allParams']\n  ? TParams\n  : Expand<\n      UnionToIntersection<TParentRoute['types']['allParams'] & TParams> & {}\n    >\n\nexport type RouteConstraints = {\n  TParentRoute: AnyRoute\n  TPath: string\n  TFullPath: string\n  TCustomId: string\n  TId: string\n  TSearchSchema: AnySearchSchema\n  TFullSearchSchema: AnySearchSchema\n  TParams: Record<string, any>\n  TAllParams: Record<string, any>\n  TParentContext: AnyContext\n  TRouteContext: RouteContext\n  TAllContext: AnyContext\n  TRouterContext: AnyContext\n  TChildren: unknown\n  TRouteTree: AnyRoute\n}\n\nexport class RouteApi<\n  TId extends RouteIds<RegisteredRouter['routeTree']>,\n  TRoute extends AnyRoute = RouteById<RegisteredRouter['routeTree'], TId>,\n  TFullSearchSchema extends Record<\n    string,\n    any\n  > = TRoute['types']['fullSearchSchema'],\n  TAllParams extends AnyPathParams = TRoute['types']['allParams'],\n  TAllContext extends Record<string, any> = TRoute['types']['allContext'],\n  TLoaderDeps extends Record<string, any> = TRoute['types']['loaderDeps'],\n  TLoaderData extends any = TRoute['types']['loaderData'],\n> {\n  id: TId\n\n  constructor({ id }: { id: TId }) {\n    this.id = id as any\n  }\n\n  useMatch = <TSelected = TAllContext>(opts?: {\n    select?: (s: TAllContext) => TSelected\n  }): TSelected => {\n    return useMatch({ ...opts, from: this.id }) as any\n  }\n\n  useRouteContext = <TSelected = TAllContext>(opts?: {\n    select?: (s: TAllContext) => TSelected\n  }): TSelected => {\n    return useMatch({\n      ...opts,\n      from: this.id,\n      select: (d: any) => (opts?.select ? opts.select(d.context) : d.context),\n    } as any)\n  }\n\n  useSearch = <TSelected = TFullSearchSchema>(opts?: {\n    select?: (s: TFullSearchSchema) => TSelected\n  }): TSelected => {\n    return useSearch({ ...opts, from: this.id } as any)\n  }\n\n  useParams = <TSelected = TAllParams>(opts?: {\n    select?: (s: TAllParams) => TSelected\n  }): TSelected => {\n    return useParams({ ...opts, from: this.id } as any)\n  }\n\n  useLoaderDeps = <TSelected = TLoaderDeps>(opts?: {\n    select?: (s: TLoaderDeps) => TSelected\n  }): TSelected => {\n    return useLoaderDeps({ ...opts, from: this.id } as any) as any\n  }\n\n  useLoaderData = <TSelected = TLoaderData>(opts?: {\n    select?: (s: TLoaderData) => TSelected\n  }): TSelected => {\n    return useLoaderData({ ...opts, from: this.id } as any) as any\n  }\n}\n\nexport class Route<\n  TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute,\n  TPath extends RouteConstraints['TPath'] = '/',\n  TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\n    TParentRoute,\n    TPath\n  >,\n  TCustomId extends RouteConstraints['TCustomId'] = string,\n  TId extends RouteConstraints['TId'] = ResolveId<\n    TParentRoute,\n    TCustomId,\n    TPath\n  >,\n  TSearchSchema extends RouteConstraints['TSearchSchema'] = {},\n  TFullSearchSchema extends\n    RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchema<\n    TParentRoute,\n    TSearchSchema\n  >,\n  TParams extends RouteConstraints['TParams'] = Expand<\n    Record<ParsePathParams<TPath>, string>\n  >,\n  TAllParams extends RouteConstraints['TAllParams'] = ResolveAllParams<\n    TParentRoute,\n    TParams\n  >,\n  TRouteContext extends RouteConstraints['TRouteContext'] = RouteContext,\n  TAllContext extends Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  > = Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  >,\n  TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderData extends any = unknown,\n  TChildren extends RouteConstraints['TChildren'] = unknown,\n  TRouteTree extends RouteConstraints['TRouteTree'] = AnyRoute,\n> {\n  isRoot: TParentRoute extends Route<any> ? true : false\n  options: RouteOptions<\n    TParentRoute,\n    TCustomId,\n    TPath,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContext,\n    TAllContext,\n    TLoaderDeps,\n    TLoaderData\n  >\n\n  test!: Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  >\n\n  // Set up in this.init()\n  parentRoute!: TParentRoute\n  id!: TId\n  // customId!: TCustomId\n  path!: TPath\n  fullPath!: TFullPath\n  to!: TrimPathRight<TFullPath>\n\n  // Optional\n  children?: TChildren\n  originalIndex?: number\n  router?: AnyRouter\n  rank!: number\n\n  constructor(\n    options: RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParams,\n      TAllParams,\n      TRouteContext,\n      TAllContext,\n      TLoaderDeps,\n      TLoaderData\n    >,\n  ) {\n    this.options = (options as any) || {}\n    this.isRoot = !options?.getParentRoute as any\n    invariant(\n      !((options as any)?.id && (options as any)?.path),\n      `Route cannot have both an 'id' and a 'path' option.`,\n    )\n    ;(this as any).$$typeof = Symbol.for('react.memo')\n  }\n\n  types!: {\n    parentRoute: TParentRoute\n    path: TPath\n    to: TrimPathRight<TFullPath>\n    fullPath: TFullPath\n    customId: TCustomId\n    id: TId\n    searchSchema: TSearchSchema\n    fullSearchSchema: TFullSearchSchema\n    params: TParams\n    allParams: TAllParams\n    routeContext: TRouteContext\n    allContext: TAllContext\n    children: TChildren\n    routeTree: TRouteTree\n    routerContext: TRouterContext\n    loaderData: TLoaderData\n    loaderDeps: TLoaderDeps\n  }\n\n  init = (opts: { originalIndex: number }) => {\n    this.originalIndex = opts.originalIndex\n\n    const options = this.options as RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParams,\n      TAllParams,\n      TRouteContext,\n      TAllContext,\n      TLoaderDeps,\n      TLoaderData\n    > &\n      RoutePathOptionsIntersection<TCustomId, TPath>\n\n    const isRoot = !options?.path && !options?.id\n\n    this.parentRoute = this.options?.getParentRoute?.()\n\n    if (isRoot) {\n      this.path = rootRouteId as TPath\n    } else {\n      invariant(\n        this.parentRoute,\n        `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`,\n      )\n    }\n\n    let path: undefined | string = isRoot ? rootRouteId : options.path\n\n    // If the path is anything other than an index path, trim it up\n    if (path && path !== '/') {\n      path = trimPath(path)\n    }\n\n    const customId = options?.id || path\n\n    // Strip the parentId prefix from the first level of children\n    let id = isRoot\n      ? rootRouteId\n      : joinPaths([\n          (this.parentRoute.id as any) === rootRouteId\n            ? ''\n            : this.parentRoute.id,\n          customId,\n        ])\n\n    if (path === rootRouteId) {\n      path = '/'\n    }\n\n    if (id !== rootRouteId) {\n      id = joinPaths(['/', id])\n    }\n\n    const fullPath =\n      id === rootRouteId ? '/' : joinPaths([this.parentRoute.fullPath, path])\n\n    this.path = path as TPath\n    this.id = id as TId\n    // this.customId = customId as TCustomId\n    this.fullPath = fullPath as TFullPath\n    this.to = fullPath as TrimPathRight<TFullPath>\n  }\n\n  addChildren = <TNewChildren extends AnyRoute[]>(\n    children: TNewChildren,\n  ): Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContext,\n    TAllContext,\n    TRouterContext,\n    TLoaderDeps,\n    TLoaderData,\n    TNewChildren,\n    TRouteTree\n  > => {\n    this.children = children as any\n    return this as any\n  }\n\n  update = (options: UpdatableRouteOptions<TFullSearchSchema>) => {\n    Object.assign(this.options, options)\n    return this\n  }\n\n  useMatch = <TSelected = TAllContext>(opts?: {\n    select?: (search: TAllContext) => TSelected\n  }): TSelected => {\n    return useMatch({ ...opts, from: this.id }) as any\n  }\n\n  useRouteContext = <TSelected = TAllContext>(opts?: {\n    select?: (search: TAllContext) => TSelected\n  }): TSelected => {\n    return useMatch({\n      ...opts,\n      from: this.id,\n      select: (d: any) => (opts?.select ? opts.select(d.context) : d.context),\n    } as any)\n  }\n\n  useSearch = <TSelected = TFullSearchSchema>(opts?: {\n    select?: (search: TFullSearchSchema) => TSelected\n  }): TSelected => {\n    return useSearch({ ...opts, from: this.id } as any)\n  }\n\n  useParams = <TSelected = TAllParams>(opts?: {\n    select?: (search: TAllParams) => TSelected\n  }): TSelected => {\n    return useParams({ ...opts, from: this.id } as any)\n  }\n\n  useLoaderDeps = <TSelected = TLoaderDeps>(opts?: {\n    select?: (s: TLoaderDeps) => TSelected\n  }): TSelected => {\n    return useLoaderDeps({ ...opts, from: this.id } as any) as any\n  }\n\n  useLoaderData = <TSelected = TLoaderData>(opts?: {\n    select?: (search: TLoaderData) => TSelected\n  }): TSelected => {\n    return useLoaderData({ ...opts, from: this.id } as any) as any\n  }\n}\n\nexport type AnyRootRoute = RootRoute<any, any, any, any>\n\nexport function rootRouteWithContext<TRouterContext extends {}>() {\n  return <\n    TSearchSchema extends Record<string, any> = {},\n    TRouteContext extends RouteContext = RouteContext,\n    TLoaderDeps extends Record<string, any> = {},\n    TLoaderData extends any = unknown,\n  >(\n    options?: Omit<\n      RouteOptions<\n        AnyRoute, // TParentRoute\n        RootRouteId, // TCustomId\n        '', // TPath\n        TSearchSchema, // TSearchSchema\n        TSearchSchema, // TFullSearchSchema\n        {}, // TParams\n        {}, // TAllParams\n        TRouteContext, // TRouteContext\n        Assign<TRouterContext, TRouteContext>, // TAllContext\n        TLoaderDeps,\n        TLoaderData // TLoaderData,\n      >,\n      | 'path'\n      | 'id'\n      | 'getParentRoute'\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n    >,\n  ): RootRoute<TSearchSchema, TRouteContext, TRouterContext> => {\n    return new RootRoute(options) as any\n  }\n}\n\nexport class RootRoute<\n  TSearchSchema extends Record<string, any> = {},\n  TRouteContext extends RouteContext = RouteContext,\n  TRouterContext extends {} = {},\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderData extends any = unknown,\n> extends Route<\n  any, // TParentRoute\n  '/', // TPath\n  '/', // TFullPath\n  string, // TCustomId\n  RootRouteId, // TId\n  TSearchSchema, // TSearchSchema\n  TSearchSchema, // TFullSearchSchema\n  {}, // TParams\n  {}, // TAllParams\n  TRouteContext, // TRouteContext\n  Expand<Assign<TRouterContext, TRouteContext>>, // TAllContext\n  TRouterContext, // TRouterContext\n  TLoaderDeps,\n  TLoaderData,\n  any, // TChildren\n  any // TRouteTree\n> {\n  constructor(\n    options?: Omit<\n      RouteOptions<\n        AnyRoute, // TParentRoute\n        RootRouteId, // TCustomId\n        '', // TPath\n        TSearchSchema, // TSearchSchema\n        TSearchSchema, // TFullSearchSchema\n        {}, // TParams\n        {}, // TAllParams\n        TRouteContext, // TRouteContext\n        Assign<TRouterContext, TRouteContext>, // TAllContext\n        TLoaderDeps,\n        TLoaderData\n      >,\n      | 'path'\n      | 'id'\n      | 'getParentRoute'\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n    >,\n  ) {\n    super(options as any)\n  }\n}\n\nexport type ResolveFullPath<\n  TParentRoute extends AnyRoute,\n  TPath extends string,\n  TPrefixed = RoutePrefix<TParentRoute['fullPath'], TPath>,\n> = TPrefixed extends RootRouteId ? '/' : TPrefixed\n\ntype RoutePrefix<\n  TPrefix extends string,\n  TPath extends string,\n> = string extends TPath\n  ? RootRouteId\n  : TPath extends string\n    ? TPrefix extends RootRouteId\n      ? TPath extends '/'\n        ? '/'\n        : `/${TrimPath<TPath>}`\n      : `${TPrefix}/${TPath}` extends '/'\n        ? '/'\n        : `/${TrimPathLeft<`${TrimPathRight<TPrefix>}/${TrimPath<TPath>}`>}`\n    : never\n\nexport type TrimPath<T extends string> = '' extends T\n  ? ''\n  : TrimPathRight<TrimPathLeft<T>>\n\nexport type TrimPathLeft<T extends string> =\n  T extends `${RootRouteId}/${infer U}`\n    ? TrimPathLeft<U>\n    : T extends `/${infer U}`\n      ? TrimPathLeft<U>\n      : T\nexport type TrimPathRight<T extends string> = T extends '/'\n  ? '/'\n  : T extends `${infer U}/`\n    ? TrimPathRight<U>\n    : T\n\nexport type RouteMask<TRouteTree extends AnyRoute> = {\n  routeTree: TRouteTree\n  from: RoutePaths<TRouteTree>\n  to?: any\n  params?: any\n  search?: any\n  hash?: any\n  state?: any\n  unmaskOnReload?: boolean\n}\n\nexport function createRouteMask<\n  TRouteTree extends AnyRoute,\n  TFrom extends RoutePaths<TRouteTree>,\n  TTo extends string,\n>(\n  opts: {\n    routeTree: TRouteTree\n  } & ToSubOptions<TRouteTree, TFrom, TTo>,\n): RouteMask<TRouteTree> {\n  return opts as any\n}\n\nexport type ErrorRouteProps = {\n  error: unknown\n  info: { componentStack: string }\n}\n//\n\nexport type ReactNode = any\n\nexport type SyncRouteComponent<TProps> =\n  | ((props: TProps) => ReactNode)\n  | React.LazyExoticComponent<(props: TProps) => ReactNode>\n\nexport type AsyncRouteComponent<TProps> = SyncRouteComponent<TProps> & {\n  preload?: () => Promise<void>\n}\n\nexport type RouteComponent<TProps = any> = SyncRouteComponent<TProps> &\n  AsyncRouteComponent<TProps>\n\nexport type ErrorRouteComponent = RouteComponent<ErrorRouteProps>\n\nexport class NotFoundRoute<\n  TParentRoute extends AnyRootRoute,\n  TSearchSchema extends RouteConstraints['TSearchSchema'] = {},\n  TFullSearchSchema extends\n    RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchema<\n    TParentRoute,\n    TSearchSchema\n  >,\n  TRouteContext extends RouteConstraints['TRouteContext'] = RouteContext,\n  TAllContext extends Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  > = Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  >,\n  TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderData extends any = unknown,\n  TChildren extends RouteConstraints['TChildren'] = unknown,\n  TRouteTree extends RouteConstraints['TRouteTree'] = AnyRoute,\n> extends Route<\n  TParentRoute,\n  '/404',\n  '/404',\n  '404',\n  '404',\n  TSearchSchema,\n  TFullSearchSchema,\n  {},\n  {},\n  TRouteContext,\n  TAllContext,\n  TRouterContext,\n  TLoaderDeps,\n  TLoaderData,\n  TChildren,\n  TRouteTree\n> {\n  constructor(\n    options: Omit<\n      RouteOptions<\n        TParentRoute,\n        string,\n        string,\n        TSearchSchema,\n        TFullSearchSchema,\n        {},\n        {},\n        TRouteContext,\n        TAllContext,\n        TLoaderDeps,\n        TLoaderData\n      >,\n      'caseSensitive' | 'parseParams' | 'stringifyParams' | 'path' | 'id'\n    >,\n  ) {\n    super({\n      ...(options as any),\n      id: '404',\n    })\n  }\n}\n"],"names":["rootRouteId","RouteApi","constructor","id","useMatch","opts","from","useRouteContext","select","d","context","useSearch","useParams","useLoaderDeps","useLoaderData","Route","options","isRoot","getParentRoute","invariant","path","$$typeof","Symbol","for","init","originalIndex","parentRoute","trimPath","customId","joinPaths","fullPath","to","addChildren","children","update","Object","assign","rootRouteWithContext","RootRoute","createRouteMask","NotFoundRoute"],"mappings":"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"}