/**
 * @tanstack/react-router/src/index.tsx
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

var React = require('react');
var invariant = require('tiny-invariant');
var warning = require('tiny-warning');
var CatchBoundary = require('./CatchBoundary.js');
var RouterProvider = require('./RouterProvider.js');
var utils = require('./utils.js');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);

const matchContext = /*#__PURE__*/React__namespace.createContext(undefined);
function Matches() {
  const router = RouterProvider.useRouter();
  const matchId = RouterProvider.useRouterState({
    select: s => {
      return getRenderedMatches(s)[0]?.id;
    }
  });
  return /*#__PURE__*/React__namespace.createElement(matchContext.Provider, {
    value: matchId
  }, /*#__PURE__*/React__namespace.createElement(CatchBoundary.CatchBoundary, {
    getResetKey: () => router.state.resolvedLocation.state?.key,
    errorComponent: CatchBoundary.ErrorComponent,
    onCatch: () => {
      warning(false, `Error in router! Consider setting an 'errorComponent' in your RootRoute! ðŸ‘`);
    }
  }, matchId ? /*#__PURE__*/React__namespace.createElement(Match, {
    matchId: matchId
  }) : null));
}
function SafeFragment(props) {
  return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, props.children);
}
function Match({
  matchId
}) {
  const router = RouterProvider.useRouter();
  const routeId = RouterProvider.useRouterState({
    select: s => getRenderedMatches(s).find(d => d.id === matchId)?.routeId
  });
  invariant(routeId, `Could not find routeId for matchId "${matchId}". Please file an issue!`);
  const route = router.routesById[routeId];
  const PendingComponent = route.options.pendingComponent ?? router.options.defaultPendingComponent;
  const pendingElement = PendingComponent ? /*#__PURE__*/React__namespace.createElement(PendingComponent, null) : null;
  const routeErrorComponent = route.options.errorComponent ?? router.options.defaultErrorComponent ?? CatchBoundary.ErrorComponent;
  const ResolvedSuspenseBoundary = route.options.wrapInSuspense ?? PendingComponent ?? route.options.component?.preload ?? route.options.pendingComponent?.preload ?? route.options.errorComponent?.preload ? React__namespace.Suspense : SafeFragment;
  const ResolvedCatchBoundary = routeErrorComponent ? CatchBoundary.CatchBoundary : SafeFragment;
  return /*#__PURE__*/React__namespace.createElement(matchContext.Provider, {
    value: matchId
  }, /*#__PURE__*/React__namespace.createElement(ResolvedSuspenseBoundary, {
    fallback: pendingElement
  }, /*#__PURE__*/React__namespace.createElement(ResolvedCatchBoundary, {
    getResetKey: () => router.state.resolvedLocation.state?.key,
    errorComponent: routeErrorComponent,
    onCatch: () => {
      warning(false, `Error in route match: ${matchId}`);
    }
  }, /*#__PURE__*/React__namespace.createElement(MatchInner, {
    matchId: matchId,
    pendingElement: pendingElement
  }))));
}
function MatchInner({
  matchId,
  pendingElement
}) {
  const router = RouterProvider.useRouter();
  const routeId = RouterProvider.useRouterState({
    select: s => getRenderedMatches(s).find(d => d.id === matchId)?.routeId
  });
  const route = router.routesById[routeId];
  const match = RouterProvider.useRouterState({
    select: s => utils.pick(getRenderedMatches(s).find(d => d.id === matchId), ['status', 'error', 'showPending', 'loadPromise'])
  });
  if (match.status === 'error') {
    throw match.error;
  }
  if (match.status === 'pending') {
    if (match.showPending) {
      return pendingElement;
    }
    throw match.loadPromise;
  }
  if (match.status === 'success') {
    let Comp = route.options.component ?? router.options.defaultComponent;
    if (Comp) {
      return /*#__PURE__*/React__namespace.createElement(Comp, null);
    }
    return /*#__PURE__*/React__namespace.createElement(Outlet, null);
  }
  invariant(false, 'Idle routeMatch status encountered during rendering! You should never see this. File an issue!');
}
const Outlet = /*#__PURE__*/React__namespace.memo(function Outlet() {
  const matchId = React__namespace.useContext(matchContext);
  const childMatchId = RouterProvider.useRouterState({
    select: s => {
      const matches = getRenderedMatches(s);
      const index = matches.findIndex(d => d.id === matchId);
      return matches[index + 1]?.id;
    }
  });
  if (!childMatchId) {
    return null;
  }
  return /*#__PURE__*/React__namespace.createElement(Match, {
    matchId: childMatchId
  });
});
function useMatchRoute() {
  RouterProvider.useRouterState({
    select: s => [s.location, s.resolvedLocation]
  });
  const {
    matchRoute
  } = RouterProvider.useRouter();
  return React__namespace.useCallback(opts => {
    const {
      pending,
      caseSensitive,
      ...rest
    } = opts;
    return matchRoute(rest, {
      pending,
      caseSensitive
    });
  }, []);
}
function MatchRoute(props) {
  const matchRoute = useMatchRoute();
  const params = matchRoute(props);
  if (typeof props.children === 'function') {
    return props.children(params);
  }
  return !!params ? props.children : null;
}
function getRenderedMatches(state) {
  return state.pendingMatches?.some(d => d.showPending) ? state.pendingMatches : state.matches;
}
function useMatch(opts) {
  const router = RouterProvider.useRouter();
  const nearestMatchId = React__namespace.useContext(matchContext);
  const nearestMatchRouteId = getRenderedMatches(router.state).find(d => d.id === nearestMatchId)?.routeId;
  const matchRouteId = (() => {
    const matches = getRenderedMatches(router.state);
    const match = opts?.from ? matches.find(d => d.routeId === opts?.from) : matches.find(d => d.id === nearestMatchId);
    return match.routeId;
  })();
  if (opts?.strict ?? true) {
    invariant(nearestMatchRouteId == matchRouteId, `useMatch("${matchRouteId}") is being called in a component that is meant to render the '${nearestMatchRouteId}' route. Did you mean to 'useMatch("${matchRouteId}", { strict: false })' or 'useRoute("${matchRouteId}")' instead?`);
  }
  const matchSelection = RouterProvider.useRouterState({
    select: state => {
      const match = getRenderedMatches(state).find(d => d.id === nearestMatchId);
      invariant(match, `Could not find ${opts?.from ? `an active match from "${opts.from}"` : 'a nearest match!'}`);
      return opts?.select ? opts.select(match) : match;
    }
  });
  return matchSelection;
}
function useMatches(opts) {
  return RouterProvider.useRouterState({
    select: state => {
      let matches = getRenderedMatches(state);
      return opts?.select ? opts.select(matches) : matches;
    }
  });
}
function useParentMatches(opts) {
  const contextMatchId = React__namespace.useContext(matchContext);
  return useMatches({
    select: matches => {
      matches = matches.slice(matches.findIndex(d => d.id === contextMatchId));
      return opts?.select ? opts.select(matches) : matches;
    }
  });
}
function useLoaderDeps(opts) {
  return useMatch({
    ...opts,
    select: s => {
      return typeof opts.select === 'function' ? opts.select(s?.loaderDeps) : s?.loaderDeps;
    }
  });
}
function useLoaderData(opts) {
  return useMatch({
    ...opts,
    select: s => {
      return typeof opts.select === 'function' ? opts.select(s?.loaderData) : s?.loaderData;
    }
  });
}

exports.Match = Match;
exports.MatchRoute = MatchRoute;
exports.Matches = Matches;
exports.Outlet = Outlet;
exports.matchContext = matchContext;
exports.useLoaderData = useLoaderData;
exports.useLoaderDeps = useLoaderDeps;
exports.useMatch = useMatch;
exports.useMatchRoute = useMatchRoute;
exports.useMatches = useMatches;
exports.useParentMatches = useParentMatches;
//# sourceMappingURL=Matches.js.map
