{"version":3,"file":"index.js","sources":["../../../esm/index.js"],"sourcesContent":["/**\n * @tanstack/react-router/src/index.tsx\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { createBrowserHistory, isDehydratedDeferred as isDehydratedDeferred$1 } from '@tanstack/history';\nexport * from '@tanstack/history';\nimport invariant from 'tiny-invariant';\nexport { default as invariant } from 'tiny-invariant';\nimport warning from 'tiny-warning';\nexport { default as warning } from 'tiny-warning';\nimport * as React from 'react';\n\nfunction CatchBoundary(props) {\n  const errorComponent = props.errorComponent ?? ErrorComponent;\n  return /*#__PURE__*/React.createElement(CatchBoundaryImpl, {\n    resetKey: props.resetKey,\n    onCatch: props.onCatch,\n    children: ({\n      error\n    }) => {\n      if (error) {\n        return /*#__PURE__*/React.createElement(errorComponent, {\n          error\n        });\n      }\n      return props.children;\n    }\n  });\n}\nclass CatchBoundaryImpl extends React.Component {\n  state = {\n    error: null\n  };\n  static getDerivedStateFromError(error) {\n    return {\n      error\n    };\n  }\n  componentDidUpdate(prevProps, prevState) {\n    if (prevState.error && prevProps.resetKey !== this.props.resetKey) {\n      this.setState({\n        error: null\n      });\n    }\n  }\n  componentDidCatch(error) {\n    console.error(error);\n    this.props.onCatch?.(error);\n  }\n  render() {\n    return this.props.children(this.state);\n  }\n}\nfunction ErrorComponent({\n  error\n}) {\n  const [show, setShow] = React.useState(process.env.NODE_ENV !== 'production');\n  return /*#__PURE__*/React.createElement(\"div\", {\n    style: {\n      padding: '.5rem',\n      maxWidth: '100%'\n    }\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    style: {\n      display: 'flex',\n      alignItems: 'center',\n      gap: '.5rem'\n    }\n  }, /*#__PURE__*/React.createElement(\"strong\", {\n    style: {\n      fontSize: '1rem'\n    }\n  }, \"Something went wrong!\"), /*#__PURE__*/React.createElement(\"button\", {\n    style: {\n      appearance: 'none',\n      fontSize: '.6em',\n      border: '1px solid currentColor',\n      padding: '.1rem .2rem',\n      fontWeight: 'bold',\n      borderRadius: '.25rem'\n    },\n    onClick: () => setShow(d => !d)\n  }, show ? 'Hide Error' : 'Show Error')), /*#__PURE__*/React.createElement(\"div\", {\n    style: {\n      height: '.25rem'\n    }\n  }), show ? /*#__PURE__*/React.createElement(\"div\", null, /*#__PURE__*/React.createElement(\"pre\", {\n    style: {\n      fontSize: '.7em',\n      border: '1px solid red',\n      borderRadius: '.25rem',\n      padding: '.3rem',\n      color: 'red',\n      overflow: 'auto'\n    }\n  }, error.message ? /*#__PURE__*/React.createElement(\"code\", null, error.message) : null)) : null);\n}\n\n// export type Expand<T> = T\n\n// type Compute<T> = { [K in keyof T]: T[K] } | never\n\n// type AllKeys<T> = T extends any ? keyof T : never\n\n// export type MergeUnion<T, Keys extends keyof T = keyof T> = Compute<\n//   {\n//     [K in Keys]: T[Keys]\n//   } & {\n//     [K in AllKeys<T>]?: T extends any\n//       ? K extends keyof T\n//         ? T[K]\n//         : never\n//       : never\n//   }\n// >\n// // Sample types to merge\n// type TypeA = {\n//   shared: string\n//   onlyInA: string\n//   nested: {\n//     shared: string\n//     aProp: string\n//   }\n//   array: string[]\n// }\n// type TypeB = {\n//   shared: number\n//   onlyInB: number\n//   nested: {\n//     shared: number\n//     bProp: number\n//   }\n//   array: number[]\n// }\n// type TypeC = {\n//   shared: boolean\n//   onlyInC: boolean\n//   nested: {\n//     shared: boolean\n//     cProp: boolean\n//   }\n//   array: boolean[]\n// }\n// type Test = Expand<Assign<TypeA, TypeB>>\n// // Using DeepMerge to merge TypeA and TypeB\n// type MergedType = Expand<AssignAll<[TypeA, TypeB, TypeC]>>\n//\n\nconst isServer = typeof document === 'undefined';\nfunction last(arr) {\n  return arr[arr.length - 1];\n}\nfunction isFunction(d) {\n  return typeof d === 'function';\n}\nfunction functionalUpdate(updater, previous) {\n  if (isFunction(updater)) {\n    return updater(previous);\n  }\n  return updater;\n}\nfunction pick(parent, keys) {\n  return keys.reduce((obj, key) => {\n    obj[key] = parent[key];\n    return obj;\n  }, {});\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between immutable JSON values for example.\n * Do not use this with signals\n */\nfunction replaceEqualDeep(prev, _next) {\n  if (prev === _next) {\n    return prev;\n  }\n  const next = _next;\n  const array = Array.isArray(prev) && Array.isArray(next);\n  if (array || isPlainObject(prev) && isPlainObject(next)) {\n    const prevSize = array ? prev.length : Object.keys(prev).length;\n    const nextItems = array ? next : Object.keys(next);\n    const nextSize = nextItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n    for (let i = 0; i < nextSize; i++) {\n      const key = array ? i : nextItems[i];\n      copy[key] = replaceEqualDeep(prev[key], next[key]);\n      if (copy[key] === prev[key]) {\n        equalItems++;\n      }\n    }\n    return prevSize === nextSize && equalItems === prevSize ? prev : copy;\n  }\n  return next;\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor;\n  if (typeof ctor === 'undefined') {\n    return true;\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype;\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n}\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\nfunction deepEqual(a, b, partial = false) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (isPlainObject(a) && isPlainObject(b)) {\n    const aKeys = Object.keys(a);\n    const bKeys = Object.keys(b);\n    if (!partial && aKeys.length !== bKeys.length) {\n      return false;\n    }\n    return !bKeys.some(key => !(key in a) || !deepEqual(a[key], b[key], partial));\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return !a.some((item, index) => !deepEqual(item, b[index], partial));\n  }\n  return false;\n}\nfunction useStableCallback(fn) {\n  const fnRef = React.useRef(fn);\n  fnRef.current = fn;\n  const ref = React.useRef((...args) => fnRef.current(...args));\n  return ref.current;\n}\nfunction shallow(objA, objB) {\n  if (Object.is(objA, objB)) {\n    return true;\n  }\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n    return false;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  for (let i = 0; i < keysA.length; i++) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction useRouteContext(opts) {\n  return useMatch({\n    ...opts,\n    select: match => opts?.select ? opts.select(match.context) : match.context\n  });\n}\nconst useLayoutEffect$1 = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\n\nfunction joinPaths(paths) {\n  return cleanPath(paths.filter(Boolean).join('/'));\n}\nfunction cleanPath(path) {\n  // remove double slashes\n  return path.replace(/\\/{2,}/g, '/');\n}\nfunction trimPathLeft(path) {\n  return path === '/' ? path : path.replace(/^\\/{1,}/, '');\n}\nfunction trimPathRight(path) {\n  return path === '/' ? path : path.replace(/\\/{1,}$/, '');\n}\nfunction trimPath(path) {\n  return trimPathRight(trimPathLeft(path));\n}\nfunction resolvePath(basepath, base, to) {\n  base = base.replace(new RegExp(`^${basepath}`), '/');\n  to = to.replace(new RegExp(`^${basepath}`), '/');\n  let baseSegments = parsePathname(base);\n  const toSegments = parsePathname(to);\n  toSegments.forEach((toSegment, index) => {\n    if (toSegment.value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment];\n      } else if (index === toSegments.length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment);\n      } else ;\n    } else if (toSegment.value === '..') {\n      // Extra trailing slash? pop it off\n      if (baseSegments.length > 1 && last(baseSegments)?.value === '/') {\n        baseSegments.pop();\n      }\n      baseSegments.pop();\n    } else if (toSegment.value === '.') {\n      return;\n    } else {\n      baseSegments.push(toSegment);\n    }\n  });\n  const joined = joinPaths([basepath, ...baseSegments.map(d => d.value)]);\n  return cleanPath(joined);\n}\nfunction parsePathname(pathname) {\n  if (!pathname) {\n    return [];\n  }\n  pathname = cleanPath(pathname);\n  const segments = [];\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1);\n    segments.push({\n      type: 'pathname',\n      value: '/'\n    });\n  }\n  if (!pathname) {\n    return segments;\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean);\n  segments.push(...split.map(part => {\n    if (part === '$' || part === '*') {\n      return {\n        type: 'wildcard',\n        value: part\n      };\n    }\n    if (part.charAt(0) === '$') {\n      return {\n        type: 'param',\n        value: part\n      };\n    }\n    return {\n      type: 'pathname',\n      value: part\n    };\n  }));\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1);\n    segments.push({\n      type: 'pathname',\n      value: '/'\n    });\n  }\n  return segments;\n}\nfunction interpolatePath(path, params, leaveWildcards = false) {\n  const interpolatedPathSegments = parsePathname(path);\n  return joinPaths(interpolatedPathSegments.map(segment => {\n    if (segment.type === 'wildcard') {\n      const value = params[segment.value];\n      if (leaveWildcards) return `${segment.value}${value ?? ''}`;\n      return value;\n    }\n    if (segment.type === 'param') {\n      return params[segment.value.substring(1)] ?? '';\n    }\n    return segment.value;\n  }));\n}\nfunction matchPathname(basepath, currentPathname, matchLocation) {\n  const pathParams = matchByPath(basepath, currentPathname, matchLocation);\n  // const searchMatched = matchBySearch(location.search, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return;\n  }\n  return pathParams ?? {};\n}\nfunction matchByPath(basepath, from, matchLocation) {\n  // Remove the base path from the pathname\n  from = basepath != '/' ? from.substring(basepath.length) : from;\n  // Default to to $ (wildcard)\n  const to = `${matchLocation.to ?? '$'}`;\n  // Parse the from and to\n  const baseSegments = parsePathname(from);\n  const routeSegments = parsePathname(to);\n  if (!from.startsWith('/')) {\n    baseSegments.unshift({\n      type: 'pathname',\n      value: '/'\n    });\n  }\n  if (!to.startsWith('/')) {\n    routeSegments.unshift({\n      type: 'pathname',\n      value: '/'\n    });\n  }\n  const params = {};\n  let isMatch = (() => {\n    for (let i = 0; i < Math.max(baseSegments.length, routeSegments.length); i++) {\n      const baseSegment = baseSegments[i];\n      const routeSegment = routeSegments[i];\n      const isLastBaseSegment = i >= baseSegments.length - 1;\n      const isLastRouteSegment = i >= routeSegments.length - 1;\n      if (routeSegment) {\n        if (routeSegment.type === 'wildcard') {\n          if (baseSegment?.value) {\n            params['*'] = joinPaths(baseSegments.slice(i).map(d => d.value));\n            return true;\n          }\n          return false;\n        }\n        if (routeSegment.type === 'pathname') {\n          if (routeSegment.value === '/' && !baseSegment?.value) {\n            return true;\n          }\n          if (baseSegment) {\n            if (matchLocation.caseSensitive) {\n              if (routeSegment.value !== baseSegment.value) {\n                return false;\n              }\n            } else if (routeSegment.value.toLowerCase() !== baseSegment.value.toLowerCase()) {\n              return false;\n            }\n          }\n        }\n        if (!baseSegment) {\n          return false;\n        }\n        if (routeSegment.type === 'param') {\n          if (baseSegment?.value === '/') {\n            return false;\n          }\n          if (baseSegment.value.charAt(0) !== '$') {\n            params[routeSegment.value.substring(1)] = baseSegment.value;\n          }\n        }\n      }\n      if (!isLastBaseSegment && isLastRouteSegment) {\n        return !!matchLocation.fuzzy;\n      }\n    }\n    return true;\n  })();\n  return isMatch ? params : undefined;\n}\n\nfunction useParams(opts) {\n  return useRouterState({\n    select: state => {\n      const params = last(state.matches)?.params;\n      return opts?.select ? opts.select(params) : params;\n    }\n  });\n}\n\nfunction useSearch(opts) {\n  return useMatch({\n    ...opts,\n    select: match => {\n      return opts?.select ? opts.select(match.search) : match.search;\n    }\n  });\n}\n\nconst rootRouteId = '__root__';\n\n// The parse type here allows a zod schema to be passed directly to the validator\n\nclass Route {\n  // Set up in this.init()\n\n  // customId!: TCustomId\n\n  // Optional\n\n  constructor(options) {\n    this.options = options || {};\n    this.isRoot = !options?.getParentRoute;\n    Route.__onInit(this);\n  }\n  init = opts => {\n    this.originalIndex = opts.originalIndex;\n    const options = this.options;\n    const isRoot = !options?.path && !options?.id;\n    this.parentRoute = this.options?.getParentRoute?.();\n    if (isRoot) {\n      this.path = rootRouteId;\n    } else {\n      invariant(this.parentRoute, `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`);\n    }\n    let path = isRoot ? rootRouteId : options.path;\n\n    // If the path is anything other than an index path, trim it up\n    if (path && path !== '/') {\n      path = trimPath(path);\n    }\n    const customId = options?.id || path;\n\n    // Strip the parentId prefix from the first level of children\n    let id = isRoot ? rootRouteId : joinPaths([this.parentRoute.id === rootRouteId ? '' : this.parentRoute.id, customId]);\n    if (path === rootRouteId) {\n      path = '/';\n    }\n    if (id !== rootRouteId) {\n      id = joinPaths(['/', id]);\n    }\n    const fullPath = id === rootRouteId ? '/' : joinPaths([this.parentRoute.fullPath, path]);\n    this.path = path;\n    this.id = id;\n    // this.customId = customId as TCustomId\n    this.fullPath = fullPath;\n    this.to = fullPath;\n  };\n  addChildren = children => {\n    this.children = children;\n    return this;\n  };\n  update = options => {\n    Object.assign(this.options, options);\n    return this;\n  };\n  static __onInit = route => {\n    // This is a dummy static method that should get\n    // replaced by a framework specific implementation if necessary\n  };\n  useMatch = opts => {\n    return useMatch({\n      ...opts,\n      from: this.id\n    });\n  };\n  useRouteContext = opts => {\n    return useMatch({\n      ...opts,\n      from: this.id,\n      select: d => opts?.select ? opts.select(d.context) : d.context\n    });\n  };\n  useSearch = opts => {\n    return useSearch({\n      ...opts,\n      from: this.id\n    });\n  };\n  useParams = opts => {\n    return useParams({\n      ...opts,\n      from: this.id\n    });\n  };\n  useLoaderData = opts => {\n    return useLoaderData({\n      ...opts,\n      from: this.id\n    });\n  };\n}\nfunction rootRouteWithContext() {\n  return options => {\n    return new RootRoute(options);\n  };\n}\nclass RootRoute extends Route {\n  constructor(options) {\n    super(options);\n  }\n}\nfunction createRouteMask(opts) {\n  return opts;\n}\n\n//\n\nfunction Matches() {\n  const {\n    routesById,\n    state\n  } = useRouter();\n  const {\n    matches\n  } = state;\n  const locationKey = useRouterState().location.state.key;\n  const route = routesById[rootRouteId];\n  const errorComponent = React.useCallback(props => {\n    return /*#__PURE__*/React.createElement(ErrorComponent, {\n      ...props,\n      useMatch: route.useMatch,\n      useRouteContext: route.useRouteContext,\n      useSearch: route.useSearch,\n      useParams: route.useParams\n    });\n  }, [route]);\n  return /*#__PURE__*/React.createElement(matchesContext.Provider, {\n    value: matches\n  }, /*#__PURE__*/React.createElement(CatchBoundary, {\n    resetKey: locationKey,\n    errorComponent: errorComponent,\n    onCatch: () => {\n      warning(false, `Error in router! Consider setting an 'errorComponent' in your RootRoute! ðŸ‘`);\n    }\n  }, matches.length ? /*#__PURE__*/React.createElement(Match, {\n    matches: matches\n  }) : null));\n}\nconst defaultPending = () => null;\nfunction SafeFragment(props) {\n  return /*#__PURE__*/React.createElement(React.Fragment, null, props.children);\n}\nfunction Match({\n  matches\n}) {\n  const {\n    options,\n    routesById\n  } = useRouter();\n  const match = matches[0];\n  const routeId = match?.routeId;\n  const route = routesById[routeId];\n  const locationKey = useRouterState().location.state?.key;\n  const PendingComponent = route.options.pendingComponent ?? options.defaultPendingComponent ?? defaultPending;\n  const routeErrorComponent = route.options.errorComponent ?? options.defaultErrorComponent ?? ErrorComponent;\n  const ResolvedSuspenseBoundary = route.options.wrapInSuspense ? React.Suspense : SafeFragment;\n  const errorComponent = routeErrorComponent ? React.useCallback(props => {\n    return /*#__PURE__*/React.createElement(routeErrorComponent, {\n      ...props,\n      useMatch: route.useMatch,\n      useRouteContext: route.useRouteContext,\n      useSearch: route.useSearch,\n      useParams: route.useParams\n    });\n  }, [route]) : undefined;\n  return /*#__PURE__*/React.createElement(matchesContext.Provider, {\n    value: matches\n  }, /*#__PURE__*/React.createElement(ResolvedSuspenseBoundary, {\n    fallback: /*#__PURE__*/React.createElement(PendingComponent, {\n      useMatch: route.useMatch,\n      useRouteContext: route.useRouteContext,\n      useSearch: route.useSearch,\n      useParams: route.useParams\n    })\n  }, errorComponent ? /*#__PURE__*/React.createElement(CatchBoundary, {\n    resetKey: locationKey,\n    errorComponent: errorComponent,\n    onCatch: () => {\n      warning(false, `Error in route match: ${match.id}`);\n    }\n  }, /*#__PURE__*/React.createElement(MatchInner, {\n    match: match\n  })) : /*#__PURE__*/React.createElement(SafeFragment, null, /*#__PURE__*/React.createElement(MatchInner, {\n    match: match\n  }))));\n}\nfunction MatchInner({\n  match\n}) {\n  const {\n    options,\n    routesById\n  } = useRouter();\n  const route = routesById[match.routeId];\n  if (match.status === 'error') {\n    throw match.error;\n  }\n  if (match.status === 'pending') {\n    throw match.loadPromise;\n  }\n  if (match.status === 'success') {\n    let comp = route.options.component ?? options.defaultComponent;\n    if (comp) {\n      return /*#__PURE__*/React.createElement(comp, {\n        useMatch: route.useMatch,\n        useRouteContext: route.useRouteContext,\n        useSearch: route.useSearch,\n        useParams: route.useParams,\n        useLoaderData: route.useLoaderData\n      });\n    }\n    return /*#__PURE__*/React.createElement(Outlet, null);\n  }\n  invariant(false, 'Idle routeMatch status encountered during rendering! You should never see this. File an issue!');\n}\nfunction Outlet() {\n  const matches = React.useContext(matchesContext).slice(1);\n  if (!matches[0]) {\n    return null;\n  }\n  return /*#__PURE__*/React.createElement(Match, {\n    matches: matches\n  });\n}\nfunction useMatchRoute() {\n  const {\n    matchRoute\n  } = useRouter();\n  return React.useCallback(opts => {\n    const {\n      pending,\n      caseSensitive,\n      ...rest\n    } = opts;\n    return matchRoute(rest, {\n      pending,\n      caseSensitive\n    });\n  }, []);\n}\nfunction MatchRoute(props) {\n  const matchRoute = useMatchRoute();\n  const params = matchRoute(props);\n  if (typeof props.children === 'function') {\n    return props.children(params);\n  }\n  return !!params ? props.children : null;\n}\nfunction useMatch(opts) {\n  const nearestMatch = React.useContext(matchesContext)[0];\n  const nearestMatchRouteId = nearestMatch?.routeId;\n  const matchRouteId = useRouterState({\n    select: state => {\n      const match = opts?.from ? state.matches.find(d => d.routeId === opts?.from) : state.matches.find(d => d.id === nearestMatch.id);\n      return match.routeId;\n    }\n  });\n  if (opts?.strict ?? true) {\n    invariant(nearestMatchRouteId == matchRouteId, `useMatch(\"${matchRouteId}\") is being called in a component that is meant to render the '${nearestMatchRouteId}' route. Did you mean to 'useMatch(\"${matchRouteId}\", { strict: false })' or 'useRoute(\"${matchRouteId}\")' instead?`);\n  }\n  const matchSelection = useRouterState({\n    select: state => {\n      const match = opts?.from ? state.matches.find(d => d.routeId === opts?.from) : state.matches.find(d => d.id === nearestMatch.id);\n      invariant(match, `Could not find ${opts?.from ? `an active match from \"${opts.from}\"` : 'a nearest match!'}`);\n      return opts?.select ? opts.select(match) : match;\n    }\n  });\n  return matchSelection;\n}\nconst matchesContext = /*#__PURE__*/React.createContext(null);\nfunction useMatches(opts) {\n  const contextMatches = React.useContext(matchesContext);\n  return useRouterState({\n    select: state => {\n      const matches = state.matches.slice(state.matches.findIndex(d => d.id === contextMatches[0]?.id));\n      return opts?.select ? opts.select(matches) : matches;\n    }\n  });\n}\nfunction useLoaderData(opts) {\n  const match = useMatch({\n    ...opts,\n    select: undefined\n  });\n  return typeof opts.select === 'function' ? opts.select(match?.loaderData) : match?.loaderData;\n}\n\n// Detect if we're in the DOM\n\nfunction redirect(opts) {\n  opts.isRedirect = true;\n  return opts;\n}\nfunction isRedirect(obj) {\n  return !!obj?.isRedirect;\n}\n\n// @ts-nocheck\n\n// qss has been slightly modified and inlined here for our use cases (and compression's sake). We've included it as a hard dependency for MIT license attribution.\n\nfunction encode(obj, pfx) {\n  var k,\n    i,\n    tmp,\n    str = '';\n  for (k in obj) {\n    if ((tmp = obj[k]) !== void 0) {\n      if (Array.isArray(tmp)) {\n        for (i = 0; i < tmp.length; i++) {\n          str && (str += '&');\n          str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp[i]);\n        }\n      } else {\n        str && (str += '&');\n        str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp);\n      }\n    }\n  }\n  return (pfx || '') + str;\n}\nfunction toValue(mix) {\n  if (!mix) return '';\n  var str = decodeURIComponent(mix);\n  if (str === 'false') return false;\n  if (str === 'true') return true;\n  return +str * 0 === 0 && +str + '' === str ? +str : str;\n}\nfunction decode(str) {\n  var tmp,\n    k,\n    out = {},\n    arr = str.split('&');\n  while (tmp = arr.shift()) {\n    tmp = tmp.split('=');\n    k = tmp.shift();\n    if (out[k] !== void 0) {\n      out[k] = [].concat(out[k], toValue(tmp.shift()));\n    } else {\n      out[k] = toValue(tmp.shift());\n    }\n  }\n  return out;\n}\n\nconst defaultParseSearch = parseSearchWith(JSON.parse);\nconst defaultStringifySearch = stringifySearchWith(JSON.stringify, JSON.parse);\nfunction parseSearchWith(parser) {\n  return searchStr => {\n    if (searchStr.substring(0, 1) === '?') {\n      searchStr = searchStr.substring(1);\n    }\n    let query = decode(searchStr);\n\n    // Try to parse any query params that might be json\n    for (let key in query) {\n      const value = query[key];\n      if (typeof value === 'string') {\n        try {\n          query[key] = parser(value);\n        } catch (err) {\n          //\n        }\n      }\n    }\n    return query;\n  };\n}\nfunction stringifySearchWith(stringify, parser) {\n  function stringifyValue(val) {\n    if (typeof val === 'object' && val !== null) {\n      try {\n        return stringify(val);\n      } catch (err) {\n        // silent\n      }\n    } else if (typeof val === 'string' && typeof parser === 'function') {\n      try {\n        // Check if it's a valid parseable string.\n        // If it is, then stringify it again.\n        parser(val);\n        return stringify(val);\n      } catch (err) {\n        // silent\n      }\n    }\n    return val;\n  }\n  return search => {\n    search = {\n      ...search\n    };\n    if (search) {\n      Object.keys(search).forEach(key => {\n        const val = search[key];\n        if (typeof val === 'undefined' || val === undefined) {\n          delete search[key];\n        } else {\n          search[key] = stringifyValue(val);\n        }\n      });\n    }\n    const searchStr = encode(search).toString();\n    return searchStr ? `?${searchStr}` : '';\n  };\n}\n\n//\n\n//\n\nconst componentTypes = ['component', 'errorComponent', 'pendingComponent'];\nclass Router {\n  // dehydratedData?: TDehydrated\n  // resetNextScroll = false\n  // tempLocationKey = `${Math.round(Math.random() * 10000000)}`\n  constructor(options) {\n    this.options = {\n      defaultPreloadDelay: 50,\n      context: undefined,\n      ...options,\n      stringifySearch: options?.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options?.parseSearch ?? defaultParseSearch\n    };\n    this.routeTree = this.options.routeTree;\n  }\n  subscribers = new Set();\n  subscribe = (eventType, fn) => {\n    const listener = {\n      eventType,\n      fn\n    };\n    this.subscribers.add(listener);\n    return () => {\n      this.subscribers.delete(listener);\n    };\n  };\n  emit = routerEvent => {\n    this.subscribers.forEach(listener => {\n      if (listener.eventType === routerEvent.type) {\n        listener.fn(routerEvent);\n      }\n    });\n  };\n\n  // dehydrate = (): DehydratedRouter => {\n  //   return {\n  //     state: {\n  //       dehydratedMatches: state.matches.map((d) =>\n  //         pick(d, ['fetchedAt', 'invalid', 'id', 'status', 'updatedAt']),\n  //       ),\n  //     },\n  //   }\n  // }\n\n  // hydrate = async (__do_not_use_server_ctx?: HydrationCtx) => {\n  //   let _ctx = __do_not_use_server_ctx\n  //   // Client hydrates from window\n  //   if (typeof document !== 'undefined') {\n  //     _ctx = window.__TSR_DEHYDRATED__\n  //   }\n\n  //   invariant(\n  //     _ctx,\n  //     'Expected to find a __TSR_DEHYDRATED__ property on window... but we did not. Did you forget to render <DehydrateRouter /> in your app?',\n  //   )\n\n  //   const ctx = _ctx\n  //   this.dehydratedData = ctx.payload as any\n  //   this.options.hydrate?.(ctx.payload as any)\n  //   const dehydratedState = ctx.router.state\n\n  //   let matches = this.matchRoutes(\n  //     state.location.pathname,\n  //     state.location.search,\n  //   ).map((match) => {\n  //     const dehydratedMatch = dehydratedState.dehydratedMatches.find(\n  //       (d) => d.id === match.id,\n  //     )\n\n  //     invariant(\n  //       dehydratedMatch,\n  //       `Could not find a client-side match for dehydrated match with id: ${match.id}!`,\n  //     )\n\n  //     if (dehydratedMatch) {\n  //       return {\n  //         ...match,\n  //         ...dehydratedMatch,\n  //       }\n  //     }\n  //     return match\n  //   })\n\n  //   this.setState((s) => {\n  //     return {\n  //       ...s,\n  //       matches: dehydratedState.dehydratedMatches as any,\n  //     }\n  //   })\n  // }\n\n  // TODO:\n  // injectedHtml: (string | (() => Promise<string> | string))[] = []\n\n  // TODO:\n  // injectHtml = async (html: string | (() => Promise<string> | string)) => {\n  //   this.injectedHtml.push(html)\n  // }\n\n  // TODO:\n  // dehydrateData = <T>(key: any, getData: T | (() => Promise<T> | T)) => {\n  //   if (typeof document === 'undefined') {\n  //     const strKey = typeof key === 'string' ? key : JSON.stringify(key)\n\n  //     this.injectHtml(async () => {\n  //       const id = `__TSR_DEHYDRATED__${strKey}`\n  //       const data =\n  //         typeof getData === 'function' ? await (getData as any)() : getData\n  //       return `<script id='${id}' suppressHydrationWarning>window[\"__TSR_DEHYDRATED__${escapeJSON(\n  //         strKey,\n  //       )}\"] = ${JSON.stringify(data)}\n  //       ;(() => {\n  //         var el = document.getElementById('${id}')\n  //         el.parentElement.removeChild(el)\n  //       })()\n  //       </script>`\n  //     })\n\n  //     return () => this.hydrateData<T>(key)\n  //   }\n\n  //   return () => undefined\n  // }\n\n  // hydrateData = <T = unknown>(key: any) => {\n  //   if (typeof document !== 'undefined') {\n  //     const strKey = typeof key === 'string' ? key : JSON.stringify(key)\n\n  //     return window[`__TSR_DEHYDRATED__${strKey}` as any] as T\n  //   }\n\n  //   return undefined\n  // }\n\n  // resolveMatchPromise = (matchId: string, key: string, value: any) => {\n  //   state.matches\n  //     .find((d) => d.id === matchId)\n  //     ?.__promisesByKey[key]?.resolve(value)\n  // }\n\n  // setRouteMatch = (\n  //   id: string,\n  //   pending: boolean,\n  //   updater: NonNullableUpdater<RouteMatch<TRouteTree>>,\n  // ) => {\n  //   const key = pending ? 'pendingMatches' : 'matches'\n\n  //   this.setState((prev) => {\n  //     return {\n  //       ...prev,\n  //       [key]: prev[key].map((d) => {\n  //         if (d.id === id) {\n  //           return functionalUpdate(updater, d)\n  //         }\n\n  //         return d\n  //       }),\n  //     }\n  //   })\n  // }\n\n  // setPendingRouteMatch = (\n  //   id: string,\n  //   updater: NonNullableUpdater<RouteMatch<TRouteTree>>,\n  // ) => {\n  //   this.setRouteMatch(id, true, updater)\n  // }\n}\n\n// A function that takes an import() argument which is a function and returns a new function that will\n// proxy arguments from the caller to the imported function, retaining all type\n// information along the way\nfunction lazyFn(fn, key) {\n  return async (...args) => {\n    const imported = await fn();\n    return imported[key || 'default'](...args);\n  };\n}\n\nconst routerContext = /*#__PURE__*/React.createContext(null);\nif (typeof document !== 'undefined') {\n  window.__TSR_ROUTER_CONTEXT__ = routerContext;\n}\nconst preloadWarning = 'Error preloading route! â˜ï¸';\nfunction isCtrlEvent(e) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n}\nclass SearchParamError extends Error {}\nclass PathParamError extends Error {}\nfunction getInitialRouterState(location) {\n  return {\n    status: 'idle',\n    resolvedLocation: location,\n    location,\n    matches: [],\n    pendingMatches: [],\n    lastUpdated: Date.now()\n  };\n}\nfunction RouterProvider({\n  router,\n  ...rest\n}) {\n  const options = {\n    ...router.options,\n    ...rest,\n    context: {\n      ...router.options.context,\n      ...rest?.context\n    }\n  };\n  const history = React.useState(() => options.history ?? createBrowserHistory())[0];\n  const tempLocationKeyRef = React.useRef(`${Math.round(Math.random() * 10000000)}`);\n  const resetNextScrollRef = React.useRef(true);\n  const navigateTimeoutRef = React.useRef(null);\n  const latestLoadPromiseRef = React.useRef(Promise.resolve());\n  const checkLatest = promise => {\n    return latestLoadPromiseRef.current !== promise ? latestLoadPromiseRef.current : undefined;\n  };\n  const parseLocation = useStableCallback(previousLocation => {\n    const parse = ({\n      pathname,\n      search,\n      hash,\n      state\n    }) => {\n      const parsedSearch = options.parseSearch(search);\n      return {\n        pathname: pathname,\n        searchStr: search,\n        search: replaceEqualDeep(previousLocation?.search, parsedSearch),\n        hash: hash.split('#').reverse()[0] ?? '',\n        href: `${pathname}${search}${hash}`,\n        state: replaceEqualDeep(previousLocation?.state, state)\n      };\n    };\n    const location = parse(history.location);\n    let {\n      __tempLocation,\n      __tempKey\n    } = location.state;\n    if (__tempLocation && (!__tempKey || __tempKey === tempLocationKeyRef.current)) {\n      // Sync up the location keys\n      const parsedTempLocation = parse(__tempLocation);\n      parsedTempLocation.state.key = location.state.key;\n      delete parsedTempLocation.state.__tempLocation;\n      return {\n        ...parsedTempLocation,\n        maskedLocation: location\n      };\n    }\n    return location;\n  });\n  const latestLocationRef = React.useRef(parseLocation());\n  const [preState, setState] = React.useState(() => getInitialRouterState(latestLocationRef.current));\n  const [isTransitioning, startReactTransition] = React.useTransition();\n  const pendingMatchesRef = React.useRef([]);\n  const state = React.useMemo(() => ({\n    ...preState,\n    status: isTransitioning ? 'pending' : 'idle',\n    location: isTransitioning ? latestLocationRef.current : preState.location,\n    pendingMatches: pendingMatchesRef.current\n  }), [preState, isTransitioning]);\n  React.useLayoutEffect(() => {\n    if (!isTransitioning && state.resolvedLocation !== state.location) {\n      router.emit({\n        type: 'onResolved',\n        fromLocation: state.resolvedLocation,\n        toLocation: state.location,\n        pathChanged: state.location.href !== state.resolvedLocation?.href\n      });\n      pendingMatchesRef.current = [];\n      setState(s => ({\n        ...s,\n        resolvedLocation: s.location\n      }));\n    }\n  });\n  const basepath = `/${trimPath(options.basepath ?? '') ?? ''}`;\n  const resolvePathWithBase = useStableCallback((from, path) => {\n    return resolvePath(basepath, from, cleanPath(path));\n  });\n  const [routesById, routesByPath] = React.useMemo(() => {\n    const routesById = {};\n    const routesByPath = {};\n    const recurseRoutes = routes => {\n      routes.forEach((route, i) => {\n        route.init({\n          originalIndex: i\n        });\n        const existingRoute = routesById[route.id];\n        invariant(!existingRoute, `Duplicate routes found with id: ${String(route.id)}`);\n        routesById[route.id] = route;\n        if (!route.isRoot && route.path) {\n          const trimmedFullPath = trimPathRight(route.fullPath);\n          if (!routesByPath[trimmedFullPath] || route.fullPath.endsWith('/')) {\n            routesByPath[trimmedFullPath] = route;\n          }\n        }\n        const children = route.children;\n        if (children?.length) {\n          recurseRoutes(children);\n        }\n      });\n    };\n    recurseRoutes([router.routeTree]);\n    return [routesById, routesByPath];\n  }, []);\n  const looseRoutesById = routesById;\n  const flatRoutes = React.useMemo(() => Object.values(routesByPath).map((d, i) => {\n    const trimmed = trimPath(d.fullPath);\n    const parsed = parsePathname(trimmed);\n    while (parsed.length > 1 && parsed[0]?.value === '/') {\n      parsed.shift();\n    }\n    const score = parsed.map(d => {\n      if (d.type === 'param') {\n        return 0.5;\n      }\n      if (d.type === 'wildcard') {\n        return 0.25;\n      }\n      return 1;\n    });\n    return {\n      child: d,\n      trimmed,\n      parsed,\n      index: i,\n      score\n    };\n  }).sort((a, b) => {\n    let isIndex = a.trimmed === '/' ? 1 : b.trimmed === '/' ? -1 : 0;\n    if (isIndex !== 0) return isIndex;\n    const length = Math.min(a.score.length, b.score.length);\n\n    // Sort by length of score\n    if (a.score.length !== b.score.length) {\n      return b.score.length - a.score.length;\n    }\n\n    // Sort by min available score\n    for (let i = 0; i < length; i++) {\n      if (a.score[i] !== b.score[i]) {\n        return b.score[i] - a.score[i];\n      }\n    }\n\n    // Sort by min available parsed value\n    for (let i = 0; i < length; i++) {\n      if (a.parsed[i].value !== b.parsed[i].value) {\n        return a.parsed[i].value > b.parsed[i].value ? 1 : -1;\n      }\n    }\n\n    // Sort by length of trimmed full path\n    if (a.trimmed !== b.trimmed) {\n      return a.trimmed > b.trimmed ? 1 : -1;\n    }\n\n    // Sort by original index\n    return a.index - b.index;\n  }).map((d, i) => {\n    d.child.rank = i;\n    return d.child;\n  }), [routesByPath]);\n  const matchRoutes = useStableCallback((pathname, locationSearch, opts) => {\n    let routeParams = {};\n    let foundRoute = flatRoutes.find(route => {\n      const matchedParams = matchPathname(basepath, trimPathRight(pathname), {\n        to: route.fullPath,\n        caseSensitive: route.options.caseSensitive ?? options.caseSensitive,\n        fuzzy: false\n      });\n      if (matchedParams) {\n        routeParams = matchedParams;\n        return true;\n      }\n      return false;\n    });\n    let routeCursor = foundRoute || routesById['__root__'];\n    let matchedRoutes = [routeCursor];\n    // let includingLayouts = true\n    while (routeCursor?.parentRoute) {\n      routeCursor = routeCursor.parentRoute;\n      if (routeCursor) matchedRoutes.unshift(routeCursor);\n    }\n\n    // Existing matches are matches that are already loaded along with\n    // pending matches that are still loading\n\n    const parseErrors = matchedRoutes.map(route => {\n      let parsedParamsError;\n      if (route.options.parseParams) {\n        try {\n          const parsedParams = route.options.parseParams(routeParams);\n          // Add the parsed params to the accumulated params bag\n          Object.assign(routeParams, parsedParams);\n        } catch (err) {\n          parsedParamsError = new PathParamError(err.message, {\n            cause: err\n          });\n          if (opts?.throwOnError) {\n            throw parsedParamsError;\n          }\n          return parsedParamsError;\n        }\n      }\n      return;\n    });\n    const matches = matchedRoutes.map((route, index) => {\n      const interpolatedPath = interpolatePath(route.path, routeParams);\n      const matchId = interpolatePath(route.id, routeParams, true);\n\n      // Waste not, want not. If we already have a match for this route,\n      // reuse it. This is important for layout routes, which might stick\n      // around between navigation actions that only change leaf routes.\n      const existingMatch = getRouteMatch(state, matchId);\n      if (existingMatch) {\n        return {\n          ...existingMatch\n        };\n      }\n\n      // Create a fresh route match\n      const hasLoaders = !!(route.options.loader || componentTypes.some(d => route.options[d]?.preload));\n      const routeMatch = {\n        id: matchId,\n        routeId: route.id,\n        params: routeParams,\n        pathname: joinPaths([basepath, interpolatedPath]),\n        updatedAt: Date.now(),\n        routeSearch: {},\n        search: {},\n        status: hasLoaders ? 'pending' : 'success',\n        isFetching: false,\n        invalid: false,\n        error: undefined,\n        paramsError: parseErrors[index],\n        searchError: undefined,\n        loadPromise: Promise.resolve(),\n        context: undefined,\n        abortController: new AbortController(),\n        shouldReloadDeps: undefined,\n        fetchedAt: 0\n      };\n      return routeMatch;\n    });\n\n    // Take each match and resolve its search params and context\n    // This has to happen after the matches are created or found\n    // so that we can use the parent match's search params and context\n    matches.forEach((match, i) => {\n      const parentMatch = matches[i - 1];\n      const route = looseRoutesById[match.routeId];\n      const searchInfo = (() => {\n        // Validate the search params and stabilize them\n        const parentSearchInfo = {\n          search: parentMatch?.search ?? locationSearch,\n          routeSearch: parentMatch?.routeSearch ?? locationSearch\n        };\n        try {\n          const validator = typeof route.options.validateSearch === 'object' ? route.options.validateSearch.parse : route.options.validateSearch;\n          let routeSearch = validator?.(parentSearchInfo.search) ?? {};\n          let search = {\n            ...parentSearchInfo.search,\n            ...routeSearch\n          };\n          routeSearch = replaceEqualDeep(match.routeSearch, routeSearch);\n          search = replaceEqualDeep(match.search, search);\n          return {\n            routeSearch,\n            search,\n            searchDidChange: match.routeSearch !== routeSearch\n          };\n        } catch (err) {\n          match.searchError = new SearchParamError(err.message, {\n            cause: err\n          });\n          if (opts?.throwOnError) {\n            throw match.searchError;\n          }\n          return parentSearchInfo;\n        }\n      })();\n      Object.assign(match, searchInfo);\n    });\n    return matches;\n  });\n  const cancelMatch = useStableCallback(id => {\n    getRouteMatch(state, id)?.abortController?.abort();\n  });\n  const cancelMatches = useStableCallback(state => {\n    state.matches.forEach(match => {\n      cancelMatch(match.id);\n    });\n  });\n  const buildLocation = useStableCallback(opts => {\n    const build = (dest = {}, matches) => {\n      const from = latestLocationRef.current;\n      const fromPathname = dest.from ?? from.pathname;\n      let pathname = resolvePathWithBase(fromPathname, `${dest.to ?? ''}`);\n      const fromMatches = matchRoutes(fromPathname, from.search);\n      const stayingMatches = matches?.filter(d => fromMatches?.find(e => e.routeId === d.routeId));\n      const prevParams = {\n        ...last(fromMatches)?.params\n      };\n      let nextParams = (dest.params ?? true) === true ? prevParams : functionalUpdate(dest.params, prevParams);\n      if (nextParams) {\n        matches?.map(d => looseRoutesById[d.routeId].options.stringifyParams).filter(Boolean).forEach(fn => {\n          nextParams = {\n            ...nextParams,\n            ...fn(nextParams)\n          };\n        });\n      }\n      pathname = interpolatePath(pathname, nextParams ?? {});\n      const preSearchFilters = stayingMatches?.map(match => looseRoutesById[match.routeId].options.preSearchFilters ?? []).flat().filter(Boolean) ?? [];\n      const postSearchFilters = stayingMatches?.map(match => looseRoutesById[match.routeId].options.postSearchFilters ?? []).flat().filter(Boolean) ?? [];\n\n      // Pre filters first\n      const preFilteredSearch = preSearchFilters?.length ? preSearchFilters?.reduce((prev, next) => next(prev), from.search) : from.search;\n\n      // Then the link/navigate function\n      const destSearch = dest.search === true ? preFilteredSearch // Preserve resolvedFrom true\n      : dest.search ? functionalUpdate(dest.search, preFilteredSearch) ?? {} // Updater\n      : preSearchFilters?.length ? preFilteredSearch // Preserve resolvedFrom filters\n      : {};\n\n      // Then post filters\n      const postFilteredSearch = postSearchFilters?.length ? postSearchFilters.reduce((prev, next) => next(prev), destSearch) : destSearch;\n      const search = replaceEqualDeep(from.search, postFilteredSearch);\n      const searchStr = options.stringifySearch(search);\n      const hash = dest.hash === true ? from.hash : dest.hash ? functionalUpdate(dest.hash, from.hash) : from.hash;\n      const hashStr = hash ? `#${hash}` : '';\n      let nextState = dest.state === true ? from.state : dest.state ? functionalUpdate(dest.state, from.state) : from.state;\n      nextState = replaceEqualDeep(from.state, nextState);\n      return {\n        pathname,\n        search,\n        searchStr,\n        state: nextState,\n        hash,\n        href: history.createHref(`${pathname}${searchStr}${hashStr}`),\n        unmaskOnReload: dest.unmaskOnReload\n      };\n    };\n    const buildWithMatches = (dest = {}, maskedDest) => {\n      let next = build(dest);\n      let maskedNext = maskedDest ? build(maskedDest) : undefined;\n      if (!maskedNext) {\n        let params = {};\n        let foundMask = options.routeMasks?.find(d => {\n          const match = matchPathname(basepath, next.pathname, {\n            to: d.from,\n            caseSensitive: false,\n            fuzzy: false\n          });\n          if (match) {\n            params = match;\n            return true;\n          }\n          return false;\n        });\n        if (foundMask) {\n          foundMask = {\n            ...foundMask,\n            from: interpolatePath(foundMask.from, params)\n          };\n          maskedDest = foundMask;\n          maskedNext = build(maskedDest);\n        }\n      }\n      const nextMatches = matchRoutes(next.pathname, next.search);\n      const maskedMatches = maskedNext ? matchRoutes(maskedNext.pathname, maskedNext.search) : undefined;\n      const maskedFinal = maskedNext ? build(maskedDest, maskedMatches) : undefined;\n      const final = build(dest, nextMatches);\n      if (maskedFinal) {\n        final.maskedLocation = maskedFinal;\n      }\n      return final;\n    };\n    if (opts.mask) {\n      return buildWithMatches(opts, {\n        ...pick(opts, ['from']),\n        ...opts.mask\n      });\n    }\n    return buildWithMatches(opts);\n  });\n  const commitLocation = useStableCallback(async ({\n    startTransition,\n    ...next\n  }) => {\n    if (navigateTimeoutRef.current) clearTimeout(navigateTimeoutRef.current);\n    const isSameUrl = latestLocationRef.current.href === next.href;\n\n    // If the next urls are the same and we're not replacing,\n    // do nothing\n    if (!isSameUrl || !next.replace) {\n      let {\n        maskedLocation,\n        ...nextHistory\n      } = next;\n      if (maskedLocation) {\n        nextHistory = {\n          ...maskedLocation,\n          state: {\n            ...maskedLocation.state,\n            __tempKey: undefined,\n            __tempLocation: {\n              ...nextHistory,\n              search: nextHistory.searchStr,\n              state: {\n                ...nextHistory.state,\n                __tempKey: undefined,\n                __tempLocation: undefined,\n                key: undefined\n              }\n            }\n          }\n        };\n        if (nextHistory.unmaskOnReload ?? options.unmaskOnReload ?? false) {\n          nextHistory.state.__tempKey = tempLocationKeyRef.current;\n        }\n      }\n      const apply = () => {\n        history[next.replace ? 'replace' : 'push'](nextHistory.href, nextHistory.state);\n      };\n      if (startTransition ?? true) {\n        startReactTransition(apply);\n      } else {\n        apply();\n      }\n    }\n    resetNextScrollRef.current = next.resetScroll ?? true;\n    return latestLoadPromiseRef.current;\n  });\n  const buildAndCommitLocation = useStableCallback(({\n    replace,\n    resetScroll,\n    startTransition,\n    ...rest\n  } = {}) => {\n    const location = buildLocation(rest);\n    return commitLocation({\n      ...location,\n      startTransition,\n      replace,\n      resetScroll\n    });\n  });\n  const navigate = useStableCallback(({\n    from,\n    to = '',\n    ...rest\n  }) => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n    const toString = String(to);\n    const fromString = typeof from === 'undefined' ? from : String(from);\n    let isExternal;\n    try {\n      new URL(`${toString}`);\n      isExternal = true;\n    } catch (e) {}\n    invariant(!isExternal, 'Attempting to navigate to external url with this.navigate!');\n    return buildAndCommitLocation({\n      ...rest,\n      from: fromString,\n      to: toString\n    });\n  });\n  const loadMatches = useStableCallback(async ({\n    checkLatest,\n    matches,\n    preload\n  }) => {\n    let latestPromise;\n    let firstBadMatchIndex;\n\n    // Check each match middleware to see if the route can be accessed\n    try {\n      for (let [index, match] of matches.entries()) {\n        const parentMatch = matches[index - 1];\n        const route = looseRoutesById[match.routeId];\n        const handleError = (err, code) => {\n          err.routerCode = code;\n          firstBadMatchIndex = firstBadMatchIndex ?? index;\n          if (isRedirect(err)) {\n            throw err;\n          }\n          try {\n            route.options.onError?.(err);\n          } catch (errorHandlerErr) {\n            err = errorHandlerErr;\n            if (isRedirect(errorHandlerErr)) {\n              throw errorHandlerErr;\n            }\n          }\n          matches[index] = match = {\n            ...match,\n            error: err,\n            status: 'error',\n            updatedAt: Date.now()\n          };\n        };\n        try {\n          if (match.paramsError) {\n            handleError(match.paramsError, 'PARSE_PARAMS');\n          }\n          if (match.searchError) {\n            handleError(match.searchError, 'VALIDATE_SEARCH');\n          }\n          const parentContext = parentMatch?.context ?? options.context ?? {};\n          const beforeLoadContext = (await route.options.beforeLoad?.({\n            search: match.search,\n            abortController: match.abortController,\n            params: match.params,\n            preload: !!preload,\n            context: parentContext,\n            location: state.location,\n            navigate: opts => navigate({\n              ...opts,\n              from: match.pathname\n            }),\n            buildLocation\n          })) ?? {};\n          const context = {\n            ...parentContext,\n            ...beforeLoadContext\n          };\n          matches[index] = match = {\n            ...match,\n            context: replaceEqualDeep(match.context, context)\n          };\n        } catch (err) {\n          handleError(err, 'BEFORE_LOAD');\n          break;\n        }\n      }\n    } catch (err) {\n      if (isRedirect(err)) {\n        if (!preload) navigate(err);\n        return matches;\n      }\n      throw err;\n    }\n    const validResolvedMatches = matches.slice(0, firstBadMatchIndex);\n    const matchPromises = [];\n    validResolvedMatches.forEach((match, index) => {\n      matchPromises.push((async () => {\n        const parentMatchPromise = matchPromises[index - 1];\n        const route = looseRoutesById[match.routeId];\n        const handleIfRedirect = err => {\n          if (isRedirect(err)) {\n            if (!preload) {\n              navigate(err);\n            }\n            return true;\n          }\n          return false;\n        };\n        let loadPromise;\n        matches[index] = match = {\n          ...match,\n          fetchedAt: Date.now(),\n          invalid: false\n        };\n        if (match.isFetching) {\n          loadPromise = getRouteMatch(state, match.id)?.loadPromise;\n        } else {\n          const cause = state.matches.find(d => d.id === match.id) ? 'stay' : 'enter';\n          const loaderContext = {\n            params: match.params,\n            search: match.search,\n            preload: !!preload,\n            parentMatchPromise,\n            abortController: match.abortController,\n            context: match.context,\n            location: state.location,\n            navigate: opts => navigate({\n              ...opts,\n              from: match.pathname\n            }),\n            cause\n          };\n\n          // Default to reloading the route all the time\n          let shouldReload = true;\n          let shouldReloadDeps = typeof route.options.shouldReload === 'function' ? route.options.shouldReload?.(loaderContext) : !!route.options.shouldReload;\n          if (typeof shouldReloadDeps === 'object') {\n            // compare the deps to see if they've changed\n            shouldReload = !deepEqual(shouldReloadDeps, match.shouldReloadDeps);\n            match.shouldReloadDeps = shouldReloadDeps;\n          } else {\n            shouldReload = !!shouldReloadDeps;\n          }\n\n          // If the user doesn't want the route to reload, just\n          // resolve with the existing loader data\n\n          if (!shouldReload) {\n            loadPromise = Promise.resolve(match.loaderData);\n          } else {\n            // Otherwise, load the route\n            matches[index] = match = {\n              ...match,\n              isFetching: true\n            };\n            const componentsPromise = Promise.all(componentTypes.map(async type => {\n              const component = route.options[type];\n              if (component?.preload) {\n                await component.preload();\n              }\n            }));\n            const loaderPromise = route.options.loader?.(loaderContext);\n            loadPromise = Promise.all([componentsPromise, loaderPromise]).then(d => d[1]);\n          }\n        }\n        matches[index] = match = {\n          ...match,\n          loadPromise\n        };\n        if (!preload) {\n          setState(s => ({\n            ...s,\n            matches: s.matches.map(d => d.id === match.id ? match : d)\n          }));\n        }\n        try {\n          const loaderData = await loadPromise;\n          if (latestPromise = checkLatest()) return await latestPromise;\n          matches[index] = match = {\n            ...match,\n            error: undefined,\n            status: 'success',\n            isFetching: false,\n            updatedAt: Date.now(),\n            loaderData,\n            loadPromise: undefined\n          };\n        } catch (error) {\n          if (latestPromise = checkLatest()) return await latestPromise;\n          if (handleIfRedirect(error)) return;\n          try {\n            route.options.onError?.(error);\n          } catch (onErrorError) {\n            error = onErrorError;\n            if (handleIfRedirect(onErrorError)) return;\n          }\n          matches[index] = match = {\n            ...match,\n            error,\n            status: 'error',\n            isFetching: false,\n            updatedAt: Date.now()\n          };\n        }\n        if (!preload) {\n          setState(s => ({\n            ...s,\n            matches: s.matches.map(d => d.id === match.id ? match : d)\n          }));\n        }\n      })());\n    });\n    await Promise.all(matchPromises);\n    return matches;\n  });\n  const load = useStableCallback(async () => {\n    const promise = new Promise(async (resolve, reject) => {\n      const next = latestLocationRef.current;\n      const prevLocation = state.resolvedLocation;\n      const pathDidChange = prevLocation.href !== next.href;\n      let latestPromise;\n\n      // Cancel any pending matches\n      cancelMatches(state);\n      router.emit({\n        type: 'onBeforeLoad',\n        fromLocation: prevLocation,\n        toLocation: next,\n        pathChanged: pathDidChange\n      });\n\n      // Match the routes\n      let matches = matchRoutes(next.pathname, next.search, {\n        debug: true\n      });\n      pendingMatchesRef.current = matches;\n      const previousMatches = state.matches;\n\n      // Ingest the new matches\n      setState(s => ({\n        ...s,\n        status: 'pending',\n        location: next,\n        matches\n      }));\n      try {\n        try {\n          // Load the matches\n          await loadMatches({\n            matches,\n            checkLatest: () => checkLatest(promise)\n          });\n        } catch (err) {\n          // swallow this error, since we'll display the\n          // errors on the route components\n        }\n\n        // Only apply the latest transition\n        if (latestPromise = checkLatest(promise)) {\n          return latestPromise;\n        }\n        const exitingMatchIds = previousMatches.filter(id => !pendingMatchesRef.current.includes(id));\n        const enteringMatchIds = pendingMatchesRef.current.filter(id => !previousMatches.includes(id));\n        const stayingMatchIds = previousMatches.filter(id => pendingMatchesRef.current.includes(id))\n\n        // setState((s) => ({\n        //   ...s,\n        //   status: 'idle',\n        //   resolvedLocation: s.location,\n        // }))\n\n        //\n        ;\n        [[exitingMatchIds, 'onLeave'], [enteringMatchIds, 'onEnter'], [stayingMatchIds, 'onTransition']].forEach(([matches, hook]) => {\n          matches.forEach(match => {\n            looseRoutesById[match.routeId].options[hook]?.(match);\n          });\n        });\n        router.emit({\n          type: 'onLoad',\n          fromLocation: prevLocation,\n          toLocation: next,\n          pathChanged: pathDidChange\n        });\n        resolve();\n      } catch (err) {\n        // Only apply the latest transition\n        if (latestPromise = checkLatest(promise)) {\n          return latestPromise;\n        }\n        reject(err);\n      }\n    });\n    latestLoadPromiseRef.current = promise;\n    return latestLoadPromiseRef.current;\n  });\n  const preloadRoute = useStableCallback(async (navigateOpts = state.location) => {\n    let next = buildLocation(navigateOpts);\n    let matches = matchRoutes(next.pathname, next.search, {\n      throwOnError: true\n    });\n    await loadMatches({\n      matches,\n      preload: true,\n      checkLatest: () => undefined\n    });\n    return [last(matches), matches];\n  });\n  const buildLink = useStableCallback(dest => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n\n    const {\n      to,\n      preload: userPreload,\n      preloadDelay: userPreloadDelay,\n      activeOptions,\n      disabled,\n      target,\n      replace,\n      resetScroll,\n      startTransition\n    } = dest;\n    try {\n      new URL(`${to}`);\n      return {\n        type: 'external',\n        href: to\n      };\n    } catch (e) {}\n    const nextOpts = dest;\n    const next = buildLocation(nextOpts);\n    const preload = userPreload ?? options.defaultPreload;\n    const preloadDelay = userPreloadDelay ?? options.defaultPreloadDelay ?? 0;\n\n    // Compare path/hash for matches\n    const currentPathSplit = latestLocationRef.current.pathname.split('/');\n    const nextPathSplit = next.pathname.split('/');\n    const pathIsFuzzyEqual = nextPathSplit.every((d, i) => d === currentPathSplit[i]);\n    // Combine the matches based on user options\n    const pathTest = activeOptions?.exact ? latestLocationRef.current.pathname === next.pathname : pathIsFuzzyEqual;\n    const hashTest = activeOptions?.includeHash ? latestLocationRef.current.hash === next.hash : true;\n    const searchTest = activeOptions?.includeSearch ?? true ? deepEqual(latestLocationRef.current.search, next.search, true) : true;\n\n    // The final \"active\" test\n    const isActive = pathTest && hashTest && searchTest;\n\n    // The click handler\n    const handleClick = e => {\n      if (!disabled && !isCtrlEvent(e) && !e.defaultPrevented && (!target || target === '_self') && e.button === 0) {\n        e.preventDefault();\n\n        // All is well? Navigate!\n        commitLocation({\n          ...next,\n          replace,\n          resetScroll,\n          startTransition\n        });\n      }\n    };\n\n    // The click handler\n    const handleFocus = e => {\n      if (preload) {\n        preloadRoute(nextOpts).catch(err => {\n          console.warn(err);\n          console.warn(preloadWarning);\n        });\n      }\n    };\n    const handleTouchStart = e => {\n      preloadRoute(nextOpts).catch(err => {\n        console.warn(err);\n        console.warn(preloadWarning);\n      });\n    };\n    const handleEnter = e => {\n      const target = e.target || {};\n      if (preload) {\n        if (target.preloadTimeout) {\n          return;\n        }\n        target.preloadTimeout = setTimeout(() => {\n          target.preloadTimeout = null;\n          preloadRoute(nextOpts).catch(err => {\n            console.warn(err);\n            console.warn(preloadWarning);\n          });\n        }, preloadDelay);\n      }\n    };\n    const handleLeave = e => {\n      const target = e.target || {};\n      if (target.preloadTimeout) {\n        clearTimeout(target.preloadTimeout);\n        target.preloadTimeout = null;\n      }\n    };\n    return {\n      type: 'internal',\n      next,\n      handleFocus,\n      handleClick,\n      handleEnter,\n      handleLeave,\n      handleTouchStart,\n      isActive,\n      disabled\n    };\n  });\n  React.useLayoutEffect(() => {\n    const unsub = history.subscribe(() => {\n      latestLocationRef.current = parseLocation(latestLocationRef.current);\n      if (state.location !== latestLocationRef.current) {\n        startReactTransition(() => {\n          try {\n            load();\n          } catch (err) {\n            console.error(err);\n          }\n        });\n      }\n    });\n    const nextLocation = buildLocation({\n      search: true,\n      params: true,\n      hash: true,\n      state: true\n    });\n    if (state.location.href !== nextLocation.href) {\n      commitLocation({\n        ...nextLocation,\n        replace: true\n      });\n    }\n    return () => {\n      unsub();\n    };\n  }, [history]);\n  React.useLayoutEffect(() => {\n    startReactTransition(() => {\n      try {\n        load();\n      } catch (err) {\n        console.error(err);\n      }\n    });\n  }, []);\n  const matchRoute = useStableCallback((location, opts) => {\n    location = {\n      ...location,\n      to: location.to ? resolvePathWithBase(location.from || '', location.to) : undefined\n    };\n    const next = buildLocation(location);\n    if (opts?.pending && state.status !== 'pending') {\n      return false;\n    }\n    const baseLocation = opts?.pending ? latestLocationRef.current : state.resolvedLocation;\n\n    // const baseLocation = state.resolvedLocation\n\n    if (!baseLocation) {\n      return false;\n    }\n    const match = matchPathname(basepath, baseLocation.pathname, {\n      ...opts,\n      to: next.pathname\n    });\n    if (!match) {\n      return false;\n    }\n    if (match && (opts?.includeSearch ?? true)) {\n      return deepEqual(baseLocation.search, next.search, true) ? match : false;\n    }\n    return match;\n  });\n  const routerContextValue = {\n    routeTree: router.routeTree,\n    navigate,\n    buildLink,\n    state,\n    matchRoute,\n    routesById,\n    options,\n    history,\n    load,\n    buildLocation,\n    subscribe: router.subscribe,\n    resetNextScrollRef\n  };\n  return /*#__PURE__*/React.createElement(routerContext.Provider, {\n    value: routerContextValue\n  }, /*#__PURE__*/React.createElement(Matches, null));\n}\nfunction getRouteMatch(state, id) {\n  return [...state.pendingMatches, ...state.matches].find(d => d.id === id);\n}\nfunction useRouterState(opts) {\n  const {\n    state\n  } = useRouter();\n  // return useStore(router.__store, opts?.select as any)\n  return opts?.select ? opts.select(state) : state;\n}\nfunction useRouter() {\n  const resolvedContext = window.__TSR_ROUTER_CONTEXT__ || routerContext;\n  const value = React.useContext(resolvedContext);\n  warning(value, 'useRouter must be used inside a <RouterProvider> component!');\n  return value;\n}\n\nfunction useAwaited({\n  promise\n}) {\n  const router = useRouter();\n  let state = promise.__deferredState;\n  const key = `__TSR__DEFERRED__${state.uid}`;\n  if (isDehydratedDeferred$1(promise)) {\n    state = router.hydrateData(key);\n    promise = Promise.resolve(state.data);\n    promise.__deferredState = state;\n  }\n  if (state.status === 'pending') {\n    throw promise;\n  }\n  if (state.status === 'error') {\n    throw state.error;\n  }\n  router.dehydrateData(key, state);\n  return [state.data];\n}\nfunction Await(props) {\n  const awaited = useAwaited(props);\n  return props.children(...awaited);\n}\n\nfunction defer(_promise) {\n  const promise = _promise;\n  if (!promise.__deferredState) {\n    promise.__deferredState = {\n      uid: Math.random().toString(36).slice(2),\n      status: 'pending'\n    };\n    const state = promise.__deferredState;\n    promise.then(data => {\n      state.status = 'success';\n      state.data = data;\n    }).catch(error => {\n      state.status = 'error';\n      state.error = error;\n    });\n  }\n  return promise;\n}\nfunction isDehydratedDeferred(obj) {\n  return typeof obj === 'object' && obj !== null && !(obj instanceof Promise) && !obj.then && '__deferredState' in obj;\n}\n\nclass FileRoute {\n  constructor(path) {\n    this.path = path;\n  }\n  createRoute = options => {\n    const route = new Route(options);\n    route.isRoot = false;\n    return route;\n  };\n}\n\nfunction lazyRouteComponent(importer, exportName) {\n  let loadPromise;\n  const load = () => {\n    if (!loadPromise) {\n      loadPromise = importer();\n    }\n    return loadPromise;\n  };\n  const lazyComp = /*#__PURE__*/React.lazy(async () => {\n    const moduleExports = await load();\n    const comp = moduleExports[exportName ?? 'default'];\n    return {\n      default: comp\n    };\n  });\n  lazyComp.preload = load;\n  return lazyComp;\n}\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nfunction useLinkProps(options) {\n  const {\n    buildLink\n  } = useRouter();\n  const match = useMatch({\n    strict: false\n  });\n  const {\n    // custom props\n    type,\n    children,\n    target,\n    activeProps = () => ({\n      className: 'active'\n    }),\n    inactiveProps = () => ({}),\n    activeOptions,\n    disabled,\n    hash,\n    search,\n    params,\n    to,\n    state,\n    mask,\n    preload,\n    preloadDelay,\n    replace,\n    startTransition,\n    resetScroll,\n    // element props\n    style,\n    className,\n    onClick,\n    onFocus,\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart,\n    ...rest\n  } = options;\n  const linkInfo = buildLink({\n    from: options.to ? match.pathname : undefined,\n    ...options\n  });\n  if (linkInfo.type === 'external') {\n    const {\n      href\n    } = linkInfo;\n    return {\n      href\n    };\n  }\n  const {\n    handleClick,\n    handleFocus,\n    handleEnter,\n    handleLeave,\n    handleTouchStart,\n    isActive,\n    next\n  } = linkInfo;\n  const composeHandlers = handlers => e => {\n    if (e.persist) e.persist();\n    handlers.filter(Boolean).forEach(handler => {\n      if (e.defaultPrevented) return;\n      handler(e);\n    });\n  };\n\n  // Get the active props\n  const resolvedActiveProps = isActive ? functionalUpdate(activeProps, {}) ?? {} : {};\n\n  // Get the inactive props\n  const resolvedInactiveProps = isActive ? {} : functionalUpdate(inactiveProps, {}) ?? {};\n  return {\n    ...resolvedActiveProps,\n    ...resolvedInactiveProps,\n    ...rest,\n    href: disabled ? undefined : next.maskedLocation ? next.maskedLocation.href : next.href,\n    onClick: composeHandlers([onClick, handleClick]),\n    onFocus: composeHandlers([onFocus, handleFocus]),\n    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),\n    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),\n    onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),\n    target,\n    style: {\n      ...style,\n      ...resolvedActiveProps.style,\n      ...resolvedInactiveProps.style\n    },\n    className: [className, resolvedActiveProps.className, resolvedInactiveProps.className].filter(Boolean).join(' ') || undefined,\n    ...(disabled ? {\n      role: 'link',\n      'aria-disabled': true\n    } : undefined),\n    ['data-status']: isActive ? 'active' : undefined\n  };\n}\nconst Link = /*#__PURE__*/React.forwardRef((props, ref) => {\n  const linkProps = useLinkProps(props);\n  return /*#__PURE__*/React.createElement(\"a\", _extends({\n    ref: ref\n  }, linkProps, {\n    children: typeof props.children === 'function' ? props.children({\n      isActive: linkProps['data-status'] === 'active'\n    }) : props.children\n  }));\n});\n\nconst useLayoutEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\nconst windowKey = 'window';\nconst delimiter = '___';\nlet weakScrolledElements = new WeakSet();\nlet cache;\nconst sessionsStorage = typeof window !== 'undefined' && window.sessionStorage;\nconst defaultGetKey = location => location.state.key;\nfunction useScrollRestoration(options) {\n  const {\n    state,\n    subscribe,\n    resetNextScrollRef\n  } = useRouter();\n  useLayoutEffect(() => {\n    const getKey = options?.getKey || defaultGetKey;\n    if (sessionsStorage) {\n      if (!cache) {\n        cache = (() => {\n          const storageKey = 'tsr-scroll-restoration-v2';\n          const state = JSON.parse(window.sessionStorage.getItem(storageKey) || 'null') || {\n            cached: {},\n            next: {}\n          };\n          return {\n            state,\n            set: updater => {\n              cache.state = functionalUpdate(updater, cache.state);\n              window.sessionStorage.setItem(storageKey, JSON.stringify(cache.state));\n            }\n          };\n        })();\n      }\n    }\n    const {\n      history\n    } = window;\n    if (history.scrollRestoration) {\n      history.scrollRestoration = 'manual';\n    }\n    const onScroll = event => {\n      if (weakScrolledElements.has(event.target)) return;\n      weakScrolledElements.add(event.target);\n      const elementSelector = event.target === document || event.target === window ? windowKey : getCssSelector(event.target);\n      if (!cache.state.next[elementSelector]) {\n        cache.set(c => ({\n          ...c,\n          next: {\n            ...c.next,\n            [elementSelector]: {\n              scrollX: NaN,\n              scrollY: NaN\n            }\n          }\n        }));\n      }\n    };\n    const getCssSelector = el => {\n      let path = [],\n        parent;\n      while (parent = el.parentNode) {\n        path.unshift(`${el.tagName}:nth-child(${[].indexOf.call(parent.children, el) + 1})`);\n        el = parent;\n      }\n      return `${path.join(' > ')}`.toLowerCase();\n    };\n    if (typeof document !== 'undefined') {\n      document.addEventListener('scroll', onScroll, true);\n    }\n    const unsubOnBeforeLoad = subscribe('onBeforeLoad', event => {\n      if (event.pathChanged) {\n        const restoreKey = getKey(event.fromLocation);\n        for (const elementSelector in cache.state.next) {\n          const entry = cache.state.next[elementSelector];\n          if (elementSelector === windowKey) {\n            entry.scrollX = window.scrollX || 0;\n            entry.scrollY = window.scrollY || 0;\n          } else if (elementSelector) {\n            const element = document.querySelector(elementSelector);\n            entry.scrollX = element?.scrollLeft || 0;\n            entry.scrollY = element?.scrollTop || 0;\n          }\n          cache.set(c => {\n            const next = {\n              ...c.next\n            };\n            delete next[elementSelector];\n            return {\n              ...c,\n              next,\n              cached: {\n                ...c.cached,\n                [[restoreKey, elementSelector].join(delimiter)]: entry\n              }\n            };\n          });\n        }\n      }\n    });\n    const unsubOnResolved = subscribe('onResolved', event => {\n      if (event.pathChanged) {\n        if (!resetNextScrollRef.current) {\n          return;\n        }\n        resetNextScrollRef.current = true;\n        const getKey = options?.getKey || defaultGetKey;\n        const restoreKey = getKey(event.toLocation);\n        let windowRestored = false;\n        for (const cacheKey in cache.state.cached) {\n          const entry = cache.state.cached[cacheKey];\n          const [key, elementSelector] = cacheKey.split(delimiter);\n          if (key === restoreKey) {\n            if (elementSelector === windowKey) {\n              windowRestored = true;\n              window.scrollTo(entry.scrollX, entry.scrollY);\n            } else if (elementSelector) {\n              const element = document.querySelector(elementSelector);\n              if (element) {\n                element.scrollLeft = entry.scrollX;\n                element.scrollTop = entry.scrollY;\n              }\n            }\n          }\n        }\n        if (!windowRestored) {\n          window.scrollTo(0, 0);\n        }\n        cache.set(c => ({\n          ...c,\n          next: {}\n        }));\n        weakScrolledElements = new WeakSet();\n      }\n    });\n    return () => {\n      document.removeEventListener('scroll', onScroll);\n      unsubOnBeforeLoad();\n      unsubOnResolved();\n    };\n  }, []);\n}\nfunction ScrollRestoration(props) {\n  useScrollRestoration(props);\n  return null;\n}\n\nfunction useBlocker(message, condition = true) {\n  const {\n    history\n  } = useRouter();\n  React.useEffect(() => {\n    if (!condition) return;\n    let unblock = history.block((retry, cancel) => {\n      if (window.confirm(message)) {\n        unblock();\n        retry();\n      }\n    });\n    return unblock;\n  });\n}\nfunction Block({\n  message,\n  condition,\n  children\n}) {\n  useBlocker(message, condition);\n  return children ?? null;\n}\n\nfunction useNavigate(defaultOpts) {\n  const {\n    navigate\n  } = useRouter();\n  const match = useMatch({\n    strict: false\n  });\n  return React.useCallback(opts => {\n    return navigate({\n      from: opts?.to ? match.pathname : undefined,\n      ...defaultOpts,\n      ...opts\n    });\n  }, []);\n}\nfunction typedNavigate(navigate) {\n  return navigate;\n} //\n\nfunction Navigate(props) {\n  const {\n    navigate\n  } = useRouter();\n  const match = useMatch({\n    strict: false\n  });\n  useLayoutEffect$1(() => {\n    navigate({\n      from: props.to ? match.pathname : undefined,\n      ...props\n    });\n  }, []);\n  return null;\n}\n\nexport { Await, Block, CatchBoundary, CatchBoundaryImpl, ErrorComponent, FileRoute, Link, Match, MatchRoute, Matches, Navigate, Outlet, PathParamError, RootRoute, Route, Router, RouterProvider, ScrollRestoration, SearchParamError, cleanPath, componentTypes, createRouteMask, decode, deepEqual, defaultParseSearch, defaultStringifySearch, defer, encode, functionalUpdate, getInitialRouterState, getRouteMatch, interpolatePath, isDehydratedDeferred, isPlainObject, isRedirect, isServer, joinPaths, last, lazyFn, lazyRouteComponent, matchByPath, matchPathname, matchesContext, parsePathname, parseSearchWith, pick, redirect, replaceEqualDeep, resolvePath, rootRouteId, rootRouteWithContext, routerContext, shallow, stringifySearchWith, trimPath, trimPathLeft, trimPathRight, typedNavigate, useAwaited, useBlocker, useLayoutEffect$1 as useLayoutEffect, useLinkProps, useLoaderData, useMatch, useMatchRoute, useMatches, useNavigate, useParams, useRouteContext, useRouter, useRouterState, useScrollRestoration, useSearch, useStableCallback };\n//# sourceMappingURL=index.js.map\n"],"names":["React"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA6iCA;AACK,MAAC,aAAa,gBAAgBA,gBAAK,CAAC,aAAa,CAAC,IAAI,EAAE;AAC7D,IAAI,OAAO,QAAQ,KAAK,WAAW,EAAE;AACrC,EAAE,MAAM,CAAC,sBAAsB,GAAG,aAAa,CAAC;AAChD,CAAC;AA0gCD,SAAS,oBAAoB,CAAC,GAAG,EAAE;AACnC,EAAE,OAAO,OAAO,GAAG,KAAK,QAAQ,IAAI,GAAG,KAAK,IAAI,IAAI,EAAE,GAAG,YAAY,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,IAAI,iBAAiB,IAAI,GAAG,CAAC;AACvH;;;;;;;;;;;;;;;;;;;"}