{"version":3,"file":"useNavigate.js","sources":["../../src/useNavigate.tsx"],"sourcesContent":["import * as React from 'react'\nimport { useMatch } from './Matches'\nimport { useRouter } from './RouterProvider'\nimport { LinkOptions, NavigateOptions } from './link'\nimport { AnyRoute } from './route'\nimport { RoutePaths } from './routeInfo'\nimport { RegisteredRouter } from './router'\nimport { useLayoutEffect } from './utils'\n\nexport function useNavigate<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TDefaultFrom extends RoutePaths<TRouteTree> = '/',\n>(defaultOpts?: { from?: TDefaultFrom }) {\n  const { navigate } = useRouter()\n  const matchPathname = useMatch({\n    strict: false,\n    select: (s) => s.pathname,\n  })\n  return React.useCallback(\n    <\n      TFrom extends RoutePaths<TRouteTree> = TDefaultFrom,\n      TTo extends string = '',\n      TMaskFrom extends RoutePaths<TRouteTree> = '/',\n      TMaskTo extends string = '',\n    >(\n      opts?: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n    ) => {\n      return navigate({\n        from: opts?.to ? matchPathname : undefined,\n        ...defaultOpts,\n        ...(opts as any),\n      })\n    },\n    [],\n  )\n}\n\n// NOTE: I don't know of anyone using this. It's undocumented, so let's wait until someone needs it\n// export function typedNavigate<\n//   TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n//   TDefaultFrom extends RoutePaths<TRouteTree> = '/',\n// >(navigate: (opts: NavigateOptions<any>) => Promise<void>) {\n//   return navigate as <\n//     TFrom extends RoutePaths<TRouteTree> = TDefaultFrom,\n//     TTo extends string = '',\n//     TMaskFrom extends RoutePaths<TRouteTree> = '/',\n//     TMaskTo extends string = '',\n//   >(\n//     opts?: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n//   ) => Promise<void>\n// } //\n\nexport function Navigate<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n>(props: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>): null {\n  const { navigate } = useRouter()\n  const match = useMatch({ strict: false })\n\n  React.useEffect(() => {\n    navigate({\n      from: props.to ? match.pathname : undefined,\n      ...props,\n    } as any)\n  }, [])\n\n  return null\n}\n\nexport type UseLinkPropsOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ActiveLinkOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> &\n  React.AnchorHTMLAttributes<HTMLAnchorElement>\n\nexport type LinkProps<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ActiveLinkOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> &\n  Omit<React.AnchorHTMLAttributes<HTMLAnchorElement>, 'children'> & {\n    // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n    children?:\n      | React.ReactNode\n      | ((state: { isActive: boolean }) => React.ReactNode)\n  }\n\nexport type ActiveLinkOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = LinkOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // A function that returns additional props for the `active` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n  activeProps?:\n    | React.AnchorHTMLAttributes<HTMLAnchorElement>\n    | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>)\n  // A function that returns additional props for the `inactive` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n  inactiveProps?:\n    | React.AnchorHTMLAttributes<HTMLAnchorElement>\n    | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>)\n}\n"],"names":["useNavigate","defaultOpts","navigate","useRouter","matchPathname","useMatch","strict","select","s","pathname","React","useCallback","opts","from","to","undefined","Navigate","props","match","useEffect"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASO,SAASA,WAAWA,CAGzBC,WAAqC,EAAE;EACvC,MAAM;AAAEC,IAAAA,QAAAA;GAAU,GAAGC,wBAAS,EAAE,CAAA;EAChC,MAAMC,aAAa,GAAGC,gBAAQ,CAAC;AAC7BC,IAAAA,MAAM,EAAE,KAAK;AACbC,IAAAA,MAAM,EAAGC,CAAC,IAAKA,CAAC,CAACC,QAAAA;AACnB,GAAC,CAAC,CAAA;AACF,EAAA,OAAOC,gBAAK,CAACC,WAAW,CAOpBC,IAAkE,IAC/D;AACH,IAAA,OAAOV,QAAQ,CAAC;AACdW,MAAAA,IAAI,EAAED,IAAI,EAAEE,EAAE,GAAGV,aAAa,GAAGW,SAAS;AAC1C,MAAA,GAAGd,WAAW;MACd,GAAIW,IAAAA;AACN,KAAC,CAAC,CAAA;GACH,EACD,EACF,CAAC,CAAA;AACH,CAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO,SAASI,QAAQA,CAMtBC,KAAkE,EAAQ;EAC1E,MAAM;AAAEf,IAAAA,QAAAA;GAAU,GAAGC,wBAAS,EAAE,CAAA;EAChC,MAAMe,KAAK,GAAGb,gBAAQ,CAAC;AAAEC,IAAAA,MAAM,EAAE,KAAA;AAAM,GAAC,CAAC,CAAA;EAEzCI,gBAAK,CAACS,SAAS,CAAC,MAAM;AACpBjB,IAAAA,QAAQ,CAAC;MACPW,IAAI,EAAEI,KAAK,CAACH,EAAE,GAAGI,KAAK,CAACT,QAAQ,GAAGM,SAAS;MAC3C,GAAGE,KAAAA;AACL,KAAQ,CAAC,CAAA;GACV,EAAE,EAAE,CAAC,CAAA;AAEN,EAAA,OAAO,IAAI,CAAA;AACb;;;;;"}