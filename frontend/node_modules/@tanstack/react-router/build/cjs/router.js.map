{"version":3,"file":"router.js","sources":["../../src/router.ts"],"sourcesContent":["import {\n  HistoryLocation,\n  HistoryState,\n  RouterHistory,\n  createBrowserHistory,\n  createMemoryHistory,\n} from '@tanstack/history'\nimport { Store } from '@tanstack/store'\n\n//\n\nimport {\n  AnySearchSchema,\n  AnyRoute,\n  AnyContext,\n  AnyPathParams,\n  RouteMask,\n  Route,\n  LoaderFnContext,\n} from './route'\nimport { FullSearchSchema, RoutesById, RoutesByPath } from './routeInfo'\nimport { defaultParseSearch, defaultStringifySearch } from './searchParams'\nimport {\n  PickAsRequired,\n  Updater,\n  NonNullableUpdater,\n  replaceEqualDeep,\n  deepEqual,\n  escapeJSON,\n  functionalUpdate,\n  last,\n  pick,\n  Timeout,\n} from './utils'\nimport { RouteComponent } from './route'\nimport { AnyRouteMatch, RouteMatch } from './Matches'\nimport { ParsedLocation } from './location'\nimport { SearchSerializer, SearchParser } from './searchParams'\nimport {\n  BuildLocationFn,\n  CommitLocationOptions,\n  InjectedHtmlEntry,\n  MatchRouteFn,\n  NavigateFn,\n  getRouteMatch,\n} from './RouterProvider'\n\nimport {\n  cleanPath,\n  interpolatePath,\n  joinPaths,\n  matchPathname,\n  parsePathname,\n  removeBasepath,\n  resolvePath,\n  trimPath,\n  trimPathLeft,\n  trimPathRight,\n} from './path'\nimport invariant from 'tiny-invariant'\nimport { isRedirect } from './redirects'\nimport { ToOptions } from './link'\n// import warning from 'tiny-warning'\n\n//\n\ndeclare global {\n  interface Window {\n    __TSR_DEHYDRATED__?: HydrationCtx\n    __TSR_ROUTER_CONTEXT__?: React.Context<Router<any>>\n  }\n}\n\nexport interface Register {\n  // router: Router\n}\n\nexport type AnyRouter = Router<AnyRoute, any>\n\nexport type RegisteredRouter = Register extends {\n  router: infer TRouter extends AnyRouter\n}\n  ? TRouter\n  : AnyRouter\n\nexport type HydrationCtx = {\n  router: DehydratedRouter\n  payload: Record<string, any>\n}\n\nexport type RouterContextOptions<TRouteTree extends AnyRoute> =\n  AnyContext extends TRouteTree['types']['routerContext']\n    ? {\n        context?: TRouteTree['types']['routerContext']\n      }\n    : {\n        context: TRouteTree['types']['routerContext']\n      }\n\nexport interface RouterOptions<\n  TRouteTree extends AnyRoute,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> {\n  history?: RouterHistory\n  stringifySearch?: SearchSerializer\n  parseSearch?: SearchParser\n  defaultPreload?: false | 'intent'\n  defaultPreloadDelay?: number\n  defaultComponent?: RouteComponent\n  defaultErrorComponent?: RouteComponent\n  defaultPendingComponent?: RouteComponent\n  defaultPendingMs?: number\n  defaultPendingMinMs?: number\n  defaultStaleTime?: number\n  defaultPreloadStaleTime?: number\n  defaultPreloadGcTime?: number\n  defaultGcTime?: number\n  caseSensitive?: boolean\n  routeTree?: TRouteTree\n  basepath?: string\n  context?: TRouteTree['types']['routerContext']\n  dehydrate?: () => TDehydrated\n  hydrate?: (dehydrated: TDehydrated) => void\n  routeMasks?: RouteMask<TRouteTree>[]\n  unmaskOnReload?: boolean\n  Wrap?: (props: { children: any }) => JSX.Element\n  InnerWrap?: (props: { children: any }) => JSX.Element\n  notFoundRoute?: AnyRoute\n}\n\nexport interface RouterState<TRouteTree extends AnyRoute = AnyRoute> {\n  status: 'pending' | 'idle'\n  isLoading: boolean\n  isTransitioning: boolean\n  matches: RouteMatch<TRouteTree>[]\n  pendingMatches?: RouteMatch<TRouteTree>[]\n  cachedMatches: RouteMatch<TRouteTree>[]\n  location: ParsedLocation<FullSearchSchema<TRouteTree>>\n  resolvedLocation: ParsedLocation<FullSearchSchema<TRouteTree>>\n  lastUpdated: number\n}\n\nexport type ListenerFn<TEvent extends RouterEvent> = (event: TEvent) => void\n\nexport interface BuildNextOptions {\n  to?: string | number | null\n  params?: true | Updater<unknown>\n  search?: true | Updater<unknown>\n  hash?: true | Updater<string>\n  state?: true | NonNullableUpdater<HistoryState>\n  mask?: {\n    to?: string | number | null\n    params?: true | Updater<unknown>\n    search?: true | Updater<unknown>\n    hash?: true | Updater<string>\n    state?: true | NonNullableUpdater<HistoryState>\n    unmaskOnReload?: boolean\n  }\n  from?: string\n}\n\nexport interface DehydratedRouterState {\n  dehydratedMatches: DehydratedRouteMatch[]\n}\n\nexport type DehydratedRouteMatch = Pick<\n  RouteMatch,\n  'id' | 'status' | 'updatedAt'\n>\n\nexport interface DehydratedRouter {\n  state: DehydratedRouterState\n}\n\nexport type RouterConstructorOptions<\n  TRouteTree extends AnyRoute,\n  TDehydrated extends Record<string, any>,\n> = Omit<RouterOptions<TRouteTree, TDehydrated>, 'context'> &\n  RouterContextOptions<TRouteTree>\n\nexport const componentTypes = [\n  'component',\n  'errorComponent',\n  'pendingComponent',\n] as const\n\nexport type RouterEvents = {\n  onBeforeLoad: {\n    type: 'onBeforeLoad'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n  onLoad: {\n    type: 'onLoad'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n  onResolved: {\n    type: 'onResolved'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n}\n\nexport type RouterEvent = RouterEvents[keyof RouterEvents]\n\nexport type RouterListener<TRouterEvent extends RouterEvent> = {\n  eventType: TRouterEvent['type']\n  fn: ListenerFn<TRouterEvent>\n}\n\nexport class Router<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> {\n  // Option-independent properties\n  tempLocationKey: string | undefined = `${Math.round(\n    Math.random() * 10000000,\n  )}`\n  resetNextScroll: boolean = true\n  navigateTimeout: Timeout | null = null\n  latestLoadPromise: Promise<void> = Promise.resolve()\n  subscribers = new Set<RouterListener<RouterEvent>>()\n  injectedHtml: InjectedHtmlEntry[] = []\n  dehydratedData?: TDehydrated\n\n  // Must build in constructor\n  __store!: Store<RouterState<TRouteTree>>\n  options!: PickAsRequired<\n    RouterOptions<TRouteTree, TDehydrated>,\n    'stringifySearch' | 'parseSearch' | 'context'\n  >\n  history!: RouterHistory\n  latestLocation!: ParsedLocation\n  basepath!: string\n  routeTree!: TRouteTree\n  routesById!: RoutesById<TRouteTree>\n  routesByPath!: RoutesByPath<TRouteTree>\n  flatRoutes!: AnyRoute[]\n\n  constructor(options: RouterConstructorOptions<TRouteTree, TDehydrated>) {\n    this.update({\n      defaultPreloadDelay: 50,\n      defaultPendingMs: 1000,\n      defaultPendingMinMs: 500,\n      context: undefined!,\n      ...options,\n      stringifySearch: options?.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options?.parseSearch ?? defaultParseSearch,\n    })\n  }\n\n  // These are default implementations that can optionally be overridden\n  // by the router provider once rendered. We provide these so that the\n  // router can be used in a non-react environment if necessary\n  startReactTransition: (fn: () => void) => void = (fn) => fn()\n\n  update = (newOptions: RouterConstructorOptions<TRouteTree, TDehydrated>) => {\n    this.options = {\n      ...this.options,\n      ...newOptions,\n    }\n\n    this.basepath = `/${trimPath(newOptions.basepath ?? '') ?? ''}`\n\n    if (\n      !this.history ||\n      (this.options.history && this.options.history !== this.history)\n    ) {\n      this.history =\n        this.options.history ??\n        (typeof document !== 'undefined'\n          ? createBrowserHistory()\n          : createMemoryHistory())\n      this.latestLocation = this.parseLocation()\n    }\n\n    if (this.options.routeTree !== this.routeTree) {\n      this.routeTree = this.options.routeTree as TRouteTree\n      this.buildRouteTree()\n    }\n\n    if (!this.__store) {\n      this.__store = new Store(getInitialRouterState(this.latestLocation), {\n        onUpdate: () => {\n          this.__store.state = {\n            ...this.state,\n            status:\n              this.state.isTransitioning || this.state.isLoading\n                ? 'pending'\n                : 'idle',\n          }\n        },\n      })\n    }\n  }\n\n  get state() {\n    return this.__store.state\n  }\n\n  buildRouteTree = () => {\n    this.routesById = {} as RoutesById<TRouteTree>\n    this.routesByPath = {} as RoutesByPath<TRouteTree>\n\n    const notFoundRoute = this.options.notFoundRoute\n    if (notFoundRoute) {\n      notFoundRoute.init({ originalIndex: 99999999999 })\n      ;(this.routesById as any)[notFoundRoute.id] = notFoundRoute\n    }\n\n    const recurseRoutes = (childRoutes: AnyRoute[]) => {\n      childRoutes.forEach((childRoute, i) => {\n        childRoute.init({ originalIndex: i })\n\n        const existingRoute = (this.routesById as any)[childRoute.id]\n\n        invariant(\n          !existingRoute,\n          `Duplicate routes found with id: ${String(childRoute.id)}`,\n        )\n        ;(this.routesById as any)[childRoute.id] = childRoute\n\n        if (!childRoute.isRoot && childRoute.path) {\n          const trimmedFullPath = trimPathRight(childRoute.fullPath)\n          if (\n            !(this.routesByPath as any)[trimmedFullPath] ||\n            childRoute.fullPath.endsWith('/')\n          ) {\n            ;(this.routesByPath as any)[trimmedFullPath] = childRoute\n          }\n        }\n\n        const children = childRoute.children as Route[]\n\n        if (children?.length) {\n          recurseRoutes(children)\n        }\n      })\n    }\n\n    recurseRoutes([this.routeTree])\n\n    const scoredRoutes: {\n      child: AnyRoute\n      trimmed: string\n      parsed: ReturnType<typeof parsePathname>\n      index: number\n      scores: number[]\n    }[] = []\n\n    ;(Object.values(this.routesById) as AnyRoute[]).forEach((d, i) => {\n      if (d.isRoot || !d.path) {\n        return\n      }\n\n      const trimmed = trimPathLeft(d.fullPath)\n      const parsed = parsePathname(trimmed)\n\n      while (parsed.length > 1 && parsed[0]?.value === '/') {\n        parsed.shift()\n      }\n\n      const scores = parsed.map((d) => {\n        if (d.value === '/') {\n          return 0.75\n        }\n\n        if (d.type === 'param') {\n          return 0.5\n        }\n\n        if (d.type === 'wildcard') {\n          return 0.25\n        }\n\n        return 1\n      })\n\n      scoredRoutes.push({ child: d, trimmed, parsed, index: i, scores })\n    })\n\n    this.flatRoutes = scoredRoutes\n      .sort((a, b) => {\n        const minLength = Math.min(a.scores.length, b.scores.length)\n\n        // Sort by min available score\n        for (let i = 0; i < minLength; i++) {\n          if (a.scores[i] !== b.scores[i]) {\n            return b.scores[i]! - a.scores[i]!\n          }\n        }\n\n        // Sort by length of score\n        if (a.scores.length !== b.scores.length) {\n          return b.scores.length - a.scores.length\n        }\n\n        // Sort by min available parsed value\n        for (let i = 0; i < minLength; i++) {\n          if (a.parsed[i]!.value !== b.parsed[i]!.value) {\n            return a.parsed[i]!.value! > b.parsed[i]!.value! ? 1 : -1\n          }\n        }\n\n        // Sort by original index\n        return a.index - b.index\n      })\n      .map((d, i) => {\n        d.child.rank = i\n        return d.child\n      })\n  }\n\n  subscribe = <TType extends keyof RouterEvents>(\n    eventType: TType,\n    fn: ListenerFn<RouterEvents[TType]>,\n  ) => {\n    const listener: RouterListener<any> = {\n      eventType,\n      fn,\n    }\n\n    this.subscribers.add(listener)\n\n    return () => {\n      this.subscribers.delete(listener)\n    }\n  }\n\n  emit = (routerEvent: RouterEvent) => {\n    this.subscribers.forEach((listener) => {\n      if (listener.eventType === routerEvent.type) {\n        listener.fn(routerEvent)\n      }\n    })\n  }\n\n  checkLatest = (promise: Promise<void>): undefined | Promise<void> => {\n    return this.latestLoadPromise !== promise\n      ? this.latestLoadPromise\n      : undefined\n  }\n\n  parseLocation = (\n    previousLocation?: ParsedLocation,\n  ): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n    const parse = ({\n      pathname,\n      search,\n      hash,\n      state,\n    }: HistoryLocation): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n      const parsedSearch = this.options.parseSearch(search)\n\n      return {\n        pathname: pathname,\n        searchStr: search,\n        search: replaceEqualDeep(previousLocation?.search, parsedSearch) as any,\n        hash: hash.split('#').reverse()[0] ?? '',\n        href: `${pathname}${search}${hash}`,\n        state: replaceEqualDeep(previousLocation?.state, state) as HistoryState,\n      }\n    }\n\n    const location = parse(this.history.location)\n\n    let { __tempLocation, __tempKey } = location.state\n\n    if (__tempLocation && (!__tempKey || __tempKey === this.tempLocationKey)) {\n      // Sync up the location keys\n      const parsedTempLocation = parse(__tempLocation) as any\n      parsedTempLocation.state.key = location.state.key\n\n      delete parsedTempLocation.state.__tempLocation\n\n      return {\n        ...parsedTempLocation,\n        maskedLocation: location,\n      }\n    }\n\n    return location\n  }\n\n  resolvePathWithBase = (from: string, path: string) => {\n    return resolvePath(this.basepath!, from, cleanPath(path))\n  }\n\n  get looseRoutesById() {\n    return this.routesById as Record<string, AnyRoute>\n  }\n\n  matchRoutes = <TRouteTree extends AnyRoute>(\n    pathname: string,\n    locationSearch: AnySearchSchema,\n    opts?: { throwOnError?: boolean; debug?: boolean },\n  ): RouteMatch<TRouteTree>[] => {\n    let routeParams: Record<string, string> = {}\n\n    let foundRoute = this.flatRoutes.find((route) => {\n      const matchedParams = matchPathname(\n        this.basepath,\n        trimPathRight(pathname),\n        {\n          to: route.fullPath,\n          caseSensitive:\n            route.options.caseSensitive ?? this.options.caseSensitive,\n          fuzzy: true,\n        },\n      )\n\n      if (matchedParams) {\n        routeParams = matchedParams\n        return true\n      }\n\n      return false\n    })\n\n    let routeCursor: AnyRoute =\n      foundRoute || (this.routesById as any)['__root__']\n\n    let matchedRoutes: AnyRoute[] = [routeCursor]\n\n    // Check to see if the route needs a 404 entry\n    if (\n      // If we found a route, and it's not an index route and we have left over path\n      (foundRoute\n        ? foundRoute.path !== '/' && routeParams['**']\n        : // Or if we didn't find a route and we have left over path\n          trimPathRight(pathname)) &&\n      // And we have a 404 route configured\n      this.options.notFoundRoute\n    ) {\n      matchedRoutes.push(this.options.notFoundRoute)\n    }\n\n    while (routeCursor?.parentRoute) {\n      routeCursor = routeCursor.parentRoute\n      if (routeCursor) matchedRoutes.unshift(routeCursor)\n    }\n\n    // Existing matches are matches that are already loaded along with\n    // pending matches that are still loading\n\n    const parseErrors = matchedRoutes.map((route) => {\n      let parsedParamsError\n\n      if (route.options.parseParams) {\n        try {\n          const parsedParams = route.options.parseParams(routeParams)\n          // Add the parsed params to the accumulated params bag\n          Object.assign(routeParams, parsedParams)\n        } catch (err: any) {\n          parsedParamsError = new PathParamError(err.message, {\n            cause: err,\n          })\n\n          if (opts?.throwOnError) {\n            throw parsedParamsError\n          }\n\n          return parsedParamsError\n        }\n      }\n\n      return\n    })\n\n    const matches: AnyRouteMatch[] = []\n\n    matchedRoutes.forEach((route, index) => {\n      // Take each matched route and resolve + validate its search params\n      // This has to happen serially because each route's search params\n      // can depend on the parent route's search params\n      // It must also happen before we create the match so that we can\n      // pass the search params to the route's potential key function\n      // which is used to uniquely identify the route match in state\n\n      const parentMatch = matches[index - 1]\n\n      const [preMatchSearch, searchError]: [Record<string, any>, any] = (() => {\n        // Validate the search params and stabilize them\n        const parentSearch = parentMatch?.search ?? locationSearch\n\n        try {\n          const validator =\n            typeof route.options.validateSearch === 'object'\n              ? route.options.validateSearch.parse\n              : route.options.validateSearch\n\n          let search = validator?.(parentSearch) ?? {}\n\n          return [\n            {\n              ...parentSearch,\n              ...search,\n            },\n            undefined,\n          ]\n        } catch (err: any) {\n          const searchError = new SearchParamError(err.message, {\n            cause: err,\n          })\n\n          if (opts?.throwOnError) {\n            throw searchError\n          }\n\n          return [parentSearch, searchError]\n        }\n      })()\n\n      // This is where we need to call route.options.loaderDeps() to get any additional\n      // deps that the route's loader function might need to run. We need to do this\n      // before we create the match so that we can pass the deps to the route's\n      // potential key function which is used to uniquely identify the route match in state\n\n      const loaderDeps =\n        route.options.loaderDeps?.({\n          search: preMatchSearch,\n        }) ?? ''\n\n      const loaderDepsHash = loaderDeps ? JSON.stringify(loaderDeps) : ''\n\n      const interpolatedPath = interpolatePath(route.fullPath, routeParams)\n      const matchId =\n        interpolatePath(route.id, routeParams, true) + loaderDepsHash\n\n      // Waste not, want not. If we already have a match for this route,\n      // reuse it. This is important for layout routes, which might stick\n      // around between navigation actions that only change leaf routes.\n      const existingMatch = getRouteMatch(this.state, matchId)\n\n      const cause = this.state.matches.find((d) => d.id === matchId)\n        ? 'stay'\n        : 'enter'\n\n      // Create a fresh route match\n      const hasLoaders = !!(\n        route.options.loader ||\n        componentTypes.some((d) => (route.options[d] as any)?.preload)\n      )\n\n      const match: AnyRouteMatch = existingMatch\n        ? { ...existingMatch, cause }\n        : {\n            id: matchId,\n            routeId: route.id,\n            params: routeParams,\n            pathname: joinPaths([this.basepath, interpolatedPath]),\n            updatedAt: Date.now(),\n            search: {} as any,\n            searchError: undefined,\n            status: hasLoaders ? 'pending' : 'success',\n            showPending: false,\n            isFetching: false,\n            error: undefined,\n            paramsError: parseErrors[index],\n            loadPromise: Promise.resolve(),\n            routeContext: undefined!,\n            context: undefined!,\n            abortController: new AbortController(),\n            fetchCount: 0,\n            cause,\n            loaderDeps,\n            invalid: false,\n            preload: false,\n          }\n\n      // Regardless of whether we're reusing an existing match or creating\n      // a new one, we need to update the match's search params\n      match.search = replaceEqualDeep(match.search, preMatchSearch)\n      // And also update the searchError if there is one\n      match.searchError = searchError\n\n      matches.push(match)\n    })\n\n    return matches as any\n  }\n\n  cancelMatch = (id: string) => {\n    getRouteMatch(this.state, id)?.abortController?.abort()\n  }\n\n  cancelMatches = () => {\n    this.state.pendingMatches?.forEach((match) => {\n      this.cancelMatch(match.id)\n    })\n  }\n\n  buildLocation: BuildLocationFn<TRouteTree> = (opts) => {\n    const build = (\n      dest: BuildNextOptions & {\n        unmaskOnReload?: boolean\n      } = {},\n      matches?: AnyRouteMatch[],\n    ): ParsedLocation => {\n      const from = this.latestLocation\n      const fromSearch =\n        (this.state.pendingMatches || this.state.matches).at(-1)?.search ||\n        from.search\n      const fromPathname = dest.from ?? from.pathname\n\n      let pathname = this.resolvePathWithBase(fromPathname, `${dest.to ?? ''}`)\n\n      const fromMatches = this.matchRoutes(fromPathname, fromSearch)\n      const stayingMatches = matches?.filter(\n        (d) => fromMatches?.find((e) => e.routeId === d.routeId),\n      )\n\n      const prevParams = { ...last(fromMatches)?.params }\n\n      let nextParams =\n        (dest.params ?? true) === true\n          ? prevParams\n          : functionalUpdate(dest.params!, prevParams)\n\n      if (nextParams) {\n        matches\n          ?.map((d) => this.looseRoutesById[d.routeId]!.options.stringifyParams)\n          .filter(Boolean)\n          .forEach((fn) => {\n            nextParams = { ...nextParams!, ...fn!(nextParams!) }\n          })\n      }\n\n      pathname = interpolatePath(pathname, nextParams ?? {})\n\n      const preSearchFilters =\n        stayingMatches\n          ?.map(\n            (match) =>\n              this.looseRoutesById[match.routeId]!.options.preSearchFilters ??\n              [],\n          )\n          .flat()\n          .filter(Boolean) ?? []\n\n      const postSearchFilters =\n        stayingMatches\n          ?.map(\n            (match) =>\n              this.looseRoutesById[match.routeId]!.options.postSearchFilters ??\n              [],\n          )\n          .flat()\n          .filter(Boolean) ?? []\n\n      // Pre filters first\n      const preFilteredSearch = preSearchFilters?.length\n        ? preSearchFilters?.reduce(\n            (prev, next) => next(prev) as any,\n            fromSearch,\n          )\n        : fromSearch\n\n      // Then the link/navigate function\n      const destSearch =\n        dest.search === true\n          ? preFilteredSearch // Preserve resolvedFrom true\n          : dest.search\n            ? functionalUpdate(dest.search, preFilteredSearch) ?? {} // Updater\n            : preSearchFilters?.length\n              ? preFilteredSearch // Preserve resolvedFrom filters\n              : {}\n\n      // Then post filters\n      const postFilteredSearch = postSearchFilters?.length\n        ? postSearchFilters.reduce((prev, next) => next(prev), destSearch)\n        : destSearch\n\n      const search = replaceEqualDeep(fromSearch, postFilteredSearch)\n\n      const searchStr = this.options.stringifySearch(search)\n\n      const hash =\n        dest.hash === true\n          ? from.hash\n          : dest.hash\n            ? functionalUpdate(dest.hash!, from.hash)\n            : from.hash\n\n      const hashStr = hash ? `#${hash}` : ''\n\n      let nextState =\n        dest.state === true\n          ? from.state\n          : dest.state\n            ? functionalUpdate(dest.state, from.state)\n            : from.state\n\n      nextState = replaceEqualDeep(from.state, nextState)\n\n      return {\n        pathname,\n        search,\n        searchStr,\n        state: nextState as any,\n        hash,\n        href: `${pathname}${searchStr}${hashStr}`,\n        unmaskOnReload: dest.unmaskOnReload,\n      }\n    }\n\n    const buildWithMatches = (\n      dest: BuildNextOptions = {},\n      maskedDest?: BuildNextOptions,\n    ) => {\n      let next = build(dest)\n      let maskedNext = maskedDest ? build(maskedDest) : undefined\n\n      if (!maskedNext) {\n        let params = {}\n\n        let foundMask = this.options.routeMasks?.find((d) => {\n          const match = matchPathname(this.basepath, next.pathname, {\n            to: d.from,\n            caseSensitive: false,\n            fuzzy: false,\n          })\n\n          if (match) {\n            params = match\n            return true\n          }\n\n          return false\n        })\n\n        if (foundMask) {\n          foundMask = {\n            ...foundMask,\n            from: interpolatePath(foundMask.from, params) as any,\n          }\n          maskedDest = foundMask\n          maskedNext = build(maskedDest)\n        }\n      }\n\n      const nextMatches = this.matchRoutes(next.pathname, next.search)\n      const maskedMatches = maskedNext\n        ? this.matchRoutes(maskedNext.pathname, maskedNext.search)\n        : undefined\n      const maskedFinal = maskedNext\n        ? build(maskedDest, maskedMatches)\n        : undefined\n\n      const final = build(dest, nextMatches)\n\n      if (maskedFinal) {\n        final.maskedLocation = maskedFinal\n      }\n\n      return final\n    }\n\n    if (opts.mask) {\n      return buildWithMatches(opts, {\n        ...pick(opts, ['from']),\n        ...opts.mask,\n      })\n    }\n\n    return buildWithMatches(opts)\n  }\n\n  commitLocation = async ({\n    startTransition,\n    ...next\n  }: ParsedLocation & CommitLocationOptions) => {\n    if (this.navigateTimeout) clearTimeout(this.navigateTimeout)\n\n    const isSameUrl = this.latestLocation.href === next.href\n\n    // If the next urls are the same and we're not replacing,\n    // do nothing\n    if (!isSameUrl || !next.replace) {\n      let { maskedLocation, ...nextHistory } = next\n\n      if (maskedLocation) {\n        nextHistory = {\n          ...maskedLocation,\n          state: {\n            ...maskedLocation.state,\n            __tempKey: undefined,\n            __tempLocation: {\n              ...nextHistory,\n              search: nextHistory.searchStr,\n              state: {\n                ...nextHistory.state,\n                __tempKey: undefined!,\n                __tempLocation: undefined!,\n                key: undefined!,\n              },\n            },\n          },\n        }\n\n        if (\n          nextHistory.unmaskOnReload ??\n          this.options.unmaskOnReload ??\n          false\n        ) {\n          nextHistory.state.__tempKey = this.tempLocationKey\n        }\n      }\n\n      const apply = () => {\n        this.history[next.replace ? 'replace' : 'push'](\n          nextHistory.href,\n          nextHistory.state,\n        )\n      }\n\n      if (startTransition ?? true) {\n        this.startReactTransition(apply)\n      } else {\n        apply()\n      }\n    }\n\n    this.resetNextScroll = next.resetScroll ?? true\n\n    return this.latestLoadPromise\n  }\n\n  buildAndCommitLocation = ({\n    replace,\n    resetScroll,\n    startTransition,\n    ...rest\n  }: BuildNextOptions & CommitLocationOptions = {}) => {\n    const location = this.buildLocation(rest as any)\n    return this.commitLocation({\n      ...location,\n      startTransition,\n      replace,\n      resetScroll,\n    })\n  }\n\n  navigate: NavigateFn<TRouteTree> = ({ from, to = '', ...rest }) => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n    const toString = String(to)\n    const fromString = typeof from === 'undefined' ? from : String(from)\n    let isExternal\n\n    try {\n      new URL(`${toString}`)\n      isExternal = true\n    } catch (e) {}\n\n    invariant(\n      !isExternal,\n      'Attempting to navigate to external url with this.navigate!',\n    )\n\n    return this.buildAndCommitLocation({\n      ...rest,\n      from: fromString,\n      to: toString,\n    })\n  }\n\n  loadMatches = async ({\n    checkLatest,\n    matches,\n    preload,\n  }: {\n    checkLatest: () => Promise<void> | undefined\n    matches: AnyRouteMatch[]\n    preload?: boolean\n  }): Promise<RouteMatch[]> => {\n    let latestPromise\n    let firstBadMatchIndex: number | undefined\n\n    const updateMatch = (match: AnyRouteMatch) => {\n      // const isPreload = this.state.cachedMatches.find((d) => d.id === match.id)\n      const isPending = this.state.pendingMatches?.find(\n        (d) => d.id === match.id,\n      )\n\n      const isMatched = this.state.matches.find((d) => d.id === match.id)\n\n      const matchesKey = isPending\n        ? 'pendingMatches'\n        : isMatched\n          ? 'matches'\n          : 'cachedMatches'\n\n      this.__store.setState((s) => ({\n        ...s,\n        [matchesKey]: s[matchesKey]?.map((d) =>\n          d.id === match.id ? match : d,\n        ),\n      }))\n    }\n\n    // Check each match middleware to see if the route can be accessed\n    try {\n      for (let [index, match] of matches.entries()) {\n        const parentMatch = matches[index - 1]\n        const route = this.looseRoutesById[match.routeId]!\n        const abortController = new AbortController()\n\n        const handleErrorAndRedirect = (err: any, code: string) => {\n          err.routerCode = code\n          firstBadMatchIndex = firstBadMatchIndex ?? index\n\n          if (isRedirect(err)) {\n            throw err\n          }\n\n          try {\n            route.options.onError?.(err)\n          } catch (errorHandlerErr) {\n            err = errorHandlerErr\n\n            if (isRedirect(errorHandlerErr)) {\n              throw errorHandlerErr\n            }\n          }\n\n          matches[index] = match = {\n            ...match,\n            error: err,\n            status: 'error',\n            updatedAt: Date.now(),\n            abortController: new AbortController(),\n          }\n        }\n\n        try {\n          if (match.paramsError) {\n            handleErrorAndRedirect(match.paramsError, 'PARSE_PARAMS')\n          }\n\n          if (match.searchError) {\n            handleErrorAndRedirect(match.searchError, 'VALIDATE_SEARCH')\n          }\n\n          const parentContext =\n            parentMatch?.context ?? this.options.context ?? {}\n\n          const beforeLoadContext =\n            (await route.options.beforeLoad?.({\n              search: match.search,\n              abortController,\n              params: match.params,\n              preload: !!preload,\n              context: parentContext,\n              location: this.state.location,\n              // TOOD: just expose state and router, etc\n              navigate: (opts) =>\n                this.navigate({ ...opts, from: match.pathname } as any),\n              buildLocation: this.buildLocation,\n              cause: preload ? 'preload' : match.cause,\n            })) ?? ({} as any)\n\n          if (isRedirect(beforeLoadContext)) {\n            throw beforeLoadContext\n          }\n\n          const context = {\n            ...parentContext,\n            ...beforeLoadContext,\n          }\n\n          matches[index] = match = {\n            ...match,\n            routeContext: replaceEqualDeep(\n              match.routeContext,\n              beforeLoadContext,\n            ),\n            context: replaceEqualDeep(match.context, context),\n            abortController,\n          }\n        } catch (err) {\n          handleErrorAndRedirect(err, 'BEFORE_LOAD')\n          break\n        }\n      }\n    } catch (err) {\n      if (isRedirect(err)) {\n        if (!preload) this.navigate(err as any)\n        return matches\n      }\n\n      throw err\n    }\n\n    const validResolvedMatches = matches.slice(0, firstBadMatchIndex)\n    const matchPromises: Promise<any>[] = []\n\n    validResolvedMatches.forEach((match, index) => {\n      matchPromises.push(\n        new Promise<void>(async (resolve) => {\n          const parentMatchPromise = matchPromises[index - 1]\n          const route = this.looseRoutesById[match.routeId]!\n\n          const handleErrorAndRedirect = (err: any) => {\n            if (isRedirect(err)) {\n              if (!preload) {\n                this.navigate(err as any)\n              }\n              return true\n            }\n            return false\n          }\n\n          let loadPromise: Promise<void> | undefined\n\n          matches[index] = match = {\n            ...match,\n            showPending: false,\n          }\n\n          let didShowPending = false\n          const pendingMs =\n            route.options.pendingMs ?? this.options.defaultPendingMs\n          const pendingMinMs =\n            route.options.pendingMinMs ?? this.options.defaultPendingMinMs\n          const shouldPending =\n            !preload &&\n            pendingMs &&\n            (route.options.pendingComponent ??\n              this.options.defaultPendingComponent)\n\n          const loaderContext: LoaderFnContext = {\n            params: match.params,\n            deps: match.loaderDeps,\n            preload: !!preload,\n            parentMatchPromise,\n            abortController: match.abortController,\n            context: match.context,\n            location: this.state.location,\n            navigate: (opts) =>\n              this.navigate({ ...opts, from: match.pathname } as any),\n            cause: preload ? 'preload' : match.cause,\n          }\n\n          const fetch = async () => {\n            if (match.isFetching) {\n              loadPromise = getRouteMatch(this.state, match.id)?.loadPromise\n            } else {\n              // If the user doesn't want the route to reload, just\n              // resolve with the existing loader data\n\n              if (match.fetchCount && match.status === 'success') {\n                resolve()\n              }\n\n              // Otherwise, load the route\n              matches[index] = match = {\n                ...match,\n                isFetching: true,\n                fetchCount: match.fetchCount + 1,\n              }\n\n              const componentsPromise = Promise.all(\n                componentTypes.map(async (type) => {\n                  const component = route.options[type]\n\n                  if ((component as any)?.preload) {\n                    await (component as any).preload()\n                  }\n                }),\n              )\n\n              const loaderPromise = route.options.loader?.(loaderContext)\n\n              loadPromise = Promise.all([\n                componentsPromise,\n                loaderPromise,\n              ]).then((d) => d[1])\n            }\n\n            matches[index] = match = {\n              ...match,\n              loadPromise,\n            }\n\n            updateMatch(match)\n\n            try {\n              const loaderData = await loadPromise\n              if ((latestPromise = checkLatest())) return await latestPromise\n\n              if (isRedirect(loaderData)) {\n                if (handleErrorAndRedirect(loaderData)) return\n              }\n\n              if (didShowPending && pendingMinMs) {\n                await new Promise((r) => setTimeout(r, pendingMinMs))\n              }\n\n              if ((latestPromise = checkLatest())) return await latestPromise\n\n              matches[index] = match = {\n                ...match,\n                error: undefined,\n                status: 'success',\n                isFetching: false,\n                updatedAt: Date.now(),\n                loaderData,\n                loadPromise: undefined,\n              }\n            } catch (error) {\n              if ((latestPromise = checkLatest())) return await latestPromise\n              if (handleErrorAndRedirect(error)) return\n\n              try {\n                route.options.onError?.(error)\n              } catch (onErrorError) {\n                error = onErrorError\n                if (handleErrorAndRedirect(onErrorError)) return\n              }\n\n              matches[index] = match = {\n                ...match,\n                error,\n                status: 'error',\n                isFetching: false,\n              }\n            }\n\n            updateMatch(match)\n          }\n\n          // This is where all of the stale-while-revalidate magic happens\n          const age = Date.now() - match.updatedAt\n\n          let staleAge = preload\n            ? route.options.preloadStaleTime ??\n              this.options.defaultPreloadStaleTime ??\n              30_000 // 30 seconds for preloads by default\n            : route.options.staleTime ?? this.options.defaultStaleTime ?? 0\n\n          // Default to reloading the route all the time\n          let shouldReload\n\n          const shouldReloadOption = route.options.shouldReload\n\n          // Allow shouldReload to get the last say,\n          // if provided.\n          shouldReload =\n            typeof shouldReloadOption === 'function'\n              ? shouldReloadOption(loaderContext)\n              : shouldReloadOption\n\n          matches[index] = match = {\n            ...match,\n            preload:\n              !!preload && !this.state.matches.find((d) => d.id === match.id),\n          }\n\n          if (match.status !== 'success') {\n            // If we need to potentially show the pending component,\n            // start a timer to show it after the pendingMs\n            if (shouldPending) {\n              new Promise((r) => setTimeout(r, pendingMs)).then(async () => {\n                if ((latestPromise = checkLatest())) return latestPromise\n\n                didShowPending = true\n                matches[index] = match = {\n                  ...match,\n                  showPending: true,\n                }\n\n                updateMatch(match)\n                resolve()\n              })\n            }\n\n            // Critical Fetching, we need to await\n            await fetch()\n          } else if (match.invalid || (shouldReload ?? age > staleAge)) {\n            // Background Fetching, no need to wait\n            fetch()\n          }\n\n          resolve()\n        }),\n      )\n    })\n\n    await Promise.all(matchPromises)\n    return matches\n  }\n\n  invalidate = () => {\n    const invalidate = (d: any) => ({\n      ...d,\n      invalid: true,\n    })\n\n    this.__store.setState((s) => ({\n      ...s,\n      matches: s.matches.map(invalidate),\n      cachedMatches: s.cachedMatches.map(invalidate),\n      pendingMatches: s.pendingMatches?.map(invalidate),\n    }))\n\n    this.load()\n  }\n\n  load = async (): Promise<void> => {\n    const promise = new Promise<void>(async (resolve, reject) => {\n      const next = this.latestLocation\n      const prevLocation = this.state.resolvedLocation\n      const pathDidChange = prevLocation!.href !== next.href\n      let latestPromise: Promise<void> | undefined | null\n\n      // Cancel any pending matches\n      this.cancelMatches()\n\n      this.emit({\n        type: 'onBeforeLoad',\n        fromLocation: prevLocation,\n        toLocation: next,\n        pathChanged: pathDidChange,\n      })\n\n      let pendingMatches!: RouteMatch<any, any>[]\n      const previousMatches = this.state.matches\n\n      this.__store.batch(() => {\n        this.cleanCache()\n\n        // Match the routes\n        pendingMatches = this.matchRoutes(next.pathname, next.search, {\n          debug: true,\n        })\n\n        // Ingest the new matches\n        // If a cached moved to pendingMatches, remove it from cachedMatches\n        this.__store.setState((s) => ({\n          ...s,\n          isLoading: true,\n          location: next,\n          pendingMatches,\n          cachedMatches: s.cachedMatches.filter((d) => {\n            return !pendingMatches.find((e) => e.id === d.id)\n          }),\n        }))\n      })\n\n      try {\n        try {\n          // Load the matches\n          await this.loadMatches({\n            matches: pendingMatches,\n            checkLatest: () => this.checkLatest(promise),\n          })\n        } catch (err) {\n          // swallow this error, since we'll display the\n          // errors on the route components\n        }\n\n        // Only apply the latest transition\n        if ((latestPromise = this.checkLatest(promise))) {\n          return latestPromise\n        }\n\n        const exitingMatches = previousMatches.filter(\n          (match) => !pendingMatches.find((d) => d.id === match.id),\n        )\n        const enteringMatches = pendingMatches.filter(\n          (match) => !previousMatches.find((d) => d.id === match.id),\n        )\n        const stayingMatches = previousMatches.filter((match) =>\n          pendingMatches.find((d) => d.id === match.id),\n        )\n\n        // Commit the pending matches. If a previous match was\n        // removed, place it in the cachedMatches\n        this.__store.batch(() => {\n          this.__store.setState((s) => ({\n            ...s,\n            isLoading: false,\n            matches: s.pendingMatches!,\n            pendingMatches: undefined,\n            cachedMatches: [\n              ...s.cachedMatches,\n              ...exitingMatches.filter((d) => d.status !== 'error'),\n            ],\n          }))\n          this.cleanCache()\n        })\n\n        //\n        ;(\n          [\n            [exitingMatches, 'onLeave'],\n            [enteringMatches, 'onEnter'],\n            [stayingMatches, 'onStay'],\n          ] as const\n        ).forEach(([matches, hook]) => {\n          matches.forEach((match) => {\n            this.looseRoutesById[match.routeId]!.options[hook]?.(match)\n          })\n        })\n\n        this.emit({\n          type: 'onLoad',\n          fromLocation: prevLocation,\n          toLocation: next,\n          pathChanged: pathDidChange,\n        })\n\n        resolve()\n      } catch (err) {\n        // Only apply the latest transition\n        if ((latestPromise = this.checkLatest(promise))) {\n          return latestPromise\n        }\n\n        reject(err)\n      }\n    })\n\n    this.latestLoadPromise = promise\n\n    return this.latestLoadPromise\n  }\n\n  cleanCache = () => {\n    // This is where all of the garbage collection magic happens\n    this.__store.setState((s) => {\n      return {\n        ...s,\n        cachedMatches: s.cachedMatches.filter((d) => {\n          const route = this.looseRoutesById[d.routeId]!\n\n          if (!route.options.loader) {\n            return false\n          }\n\n          // If the route was preloaded, use the preloadGcTime\n          // otherwise, use the gcTime\n          const gcTime =\n            (d.preload\n              ? route.options.preloadGcTime ?? this.options.defaultPreloadGcTime\n              : route.options.gcTime ?? this.options.defaultGcTime) ??\n            5 * 60 * 1000\n\n          return d.status !== 'error' && Date.now() - d.updatedAt < gcTime\n        }),\n      }\n    })\n  }\n\n  preloadRoute = async (\n    navigateOpts: ToOptions<TRouteTree> = this.state.location as any,\n  ) => {\n    let next = this.buildLocation(navigateOpts as any)\n\n    let matches = this.matchRoutes(next.pathname, next.search, {\n      throwOnError: true,\n    })\n\n    const loadedMatchIds = Object.fromEntries(\n      [\n        ...this.state.matches,\n        ...(this.state.pendingMatches ?? []),\n        ...this.state.cachedMatches,\n      ]?.map((d) => [d.id, true]),\n    )\n\n    this.__store.batch(() => {\n      matches.forEach((match) => {\n        if (!loadedMatchIds[match.id]) {\n          this.__store.setState((s) => ({\n            ...s,\n            cachedMatches: [...(s.cachedMatches as any), match],\n          }))\n        }\n      })\n    })\n\n    matches = await this.loadMatches({\n      matches,\n      preload: true,\n      checkLatest: () => undefined,\n    })\n\n    return matches\n  }\n\n  matchRoute: MatchRouteFn<TRouteTree> = (location, opts) => {\n    location = {\n      ...location,\n      to: location.to\n        ? this.resolvePathWithBase((location.from || '') as string, location.to)\n        : undefined,\n    } as any\n\n    const next = this.buildLocation(location as any)\n\n    if (opts?.pending && this.state.status !== 'pending') {\n      return false\n    }\n\n    const baseLocation = opts?.pending\n      ? this.latestLocation\n      : this.state.resolvedLocation\n\n    if (!baseLocation) {\n      return false\n    }\n\n    const match = matchPathname(this.basepath, baseLocation.pathname, {\n      ...opts,\n      to: next.pathname,\n    }) as any\n\n    if (!match) {\n      return false\n    }\n\n    if (match && (opts?.includeSearch ?? true)) {\n      return deepEqual(baseLocation.search, next.search, true) ? match : false\n    }\n\n    return match\n  }\n\n  injectHtml = async (html: string | (() => Promise<string> | string)) => {\n    this.injectedHtml.push(html)\n  }\n\n  dehydrateData = <T>(key: any, getData: T | (() => Promise<T> | T)) => {\n    if (typeof document === 'undefined') {\n      const strKey = typeof key === 'string' ? key : JSON.stringify(key)\n\n      this.injectHtml(async () => {\n        const id = `__TSR_DEHYDRATED__${strKey}`\n        const data =\n          typeof getData === 'function' ? await (getData as any)() : getData\n        return `<script id='${id}' suppressHydrationWarning>window[\"__TSR_DEHYDRATED__${escapeJSON(\n          strKey,\n        )}\"] = ${JSON.stringify(data)}\n          ;(() => {\n            var el = document.getElementById('${id}')\n            el.parentElement.removeChild(el)\n          })()\n          </script>`\n      })\n\n      return () => this.hydrateData<T>(key)\n    }\n\n    return () => undefined\n  }\n\n  hydrateData = <T extends any = unknown>(key: any) => {\n    if (typeof document !== 'undefined') {\n      const strKey = typeof key === 'string' ? key : JSON.stringify(key)\n\n      return window[`__TSR_DEHYDRATED__${strKey}` as any] as T\n    }\n\n    return undefined\n  }\n\n  dehydrate = (): DehydratedRouter => {\n    return {\n      state: {\n        dehydratedMatches: this.state.matches.map((d) =>\n          pick(d, ['id', 'status', 'updatedAt', 'loaderData']),\n        ),\n      },\n    }\n  }\n\n  hydrate = async (__do_not_use_server_ctx?: HydrationCtx) => {\n    let _ctx = __do_not_use_server_ctx\n    // Client hydrates from window\n    if (typeof document !== 'undefined') {\n      _ctx = window.__TSR_DEHYDRATED__\n    }\n\n    invariant(\n      _ctx,\n      'Expected to find a __TSR_DEHYDRATED__ property on window... but we did not. Did you forget to render <DehydrateRouter /> in your app?',\n    )\n\n    const ctx = _ctx\n    this.dehydratedData = ctx.payload as any\n    this.options.hydrate?.(ctx.payload as any)\n    const dehydratedState = ctx.router.state\n\n    let matches = this.matchRoutes(\n      this.state.location.pathname,\n      this.state.location.search,\n    ).map((match) => {\n      const dehydratedMatch = dehydratedState.dehydratedMatches.find(\n        (d) => d.id === match.id,\n      )\n\n      invariant(\n        dehydratedMatch,\n        `Could not find a client-side match for dehydrated match with id: ${match.id}!`,\n      )\n\n      if (dehydratedMatch) {\n        return {\n          ...match,\n          ...dehydratedMatch,\n        }\n      }\n      return match\n    })\n\n    this.__store.setState((s) => {\n      return {\n        ...s,\n        matches: matches as any,\n      }\n    })\n  }\n\n  // resolveMatchPromise = (matchId: string, key: string, value: any) => {\n  //   state.matches\n  //     .find((d) => d.id === matchId)\n  //     ?.__promisesByKey[key]?.resolve(value)\n  // }\n}\n\n// A function that takes an import() argument which is a function and returns a new function that will\n// proxy arguments from the caller to the imported function, retaining all type\n// information along the way\nexport function lazyFn<\n  T extends Record<string, (...args: any[]) => any>,\n  TKey extends keyof T = 'default',\n>(fn: () => Promise<T>, key?: TKey) {\n  return async (...args: Parameters<T[TKey]>): Promise<ReturnType<T[TKey]>> => {\n    const imported = await fn()\n    return imported[key || 'default'](...args)\n  }\n}\n\nexport class SearchParamError extends Error {}\n\nexport class PathParamError extends Error {}\n\nexport function getInitialRouterState(\n  location: ParsedLocation,\n): RouterState<any> {\n  return {\n    isLoading: false,\n    isTransitioning: false,\n    status: 'idle',\n    resolvedLocation: { ...location },\n    location,\n    matches: [],\n    pendingMatches: [],\n    cachedMatches: [],\n    lastUpdated: Date.now(),\n  }\n}\n"],"names":["componentTypes","Router","tempLocationKey","Math","round","random","resetNextScroll","navigateTimeout","latestLoadPromise","Promise","resolve","subscribers","Set","injectedHtml","constructor","options","update","defaultPreloadDelay","defaultPendingMs","defaultPendingMinMs","context","undefined","stringifySearch","defaultStringifySearch","parseSearch","defaultParseSearch","startReactTransition","fn","newOptions","basepath","trimPath","history","document","createBrowserHistory","createMemoryHistory","latestLocation","parseLocation","routeTree","buildRouteTree","__store","Store","getInitialRouterState","onUpdate","state","status","isTransitioning","isLoading","routesById","routesByPath","notFoundRoute","init","originalIndex","id","recurseRoutes","childRoutes","forEach","childRoute","i","existingRoute","invariant","String","isRoot","path","trimmedFullPath","trimPathRight","fullPath","endsWith","children","length","scoredRoutes","Object","values","d","trimmed","trimPathLeft","parsed","parsePathname","value","shift","scores","map","type","push","child","index","flatRoutes","sort","a","b","minLength","min","rank","subscribe","eventType","listener","add","delete","emit","routerEvent","checkLatest","promise","previousLocation","parse","pathname","search","hash","parsedSearch","searchStr","replaceEqualDeep","split","reverse","href","location","__tempLocation","__tempKey","parsedTempLocation","key","maskedLocation","resolvePathWithBase","from","resolvePath","cleanPath","looseRoutesById","matchRoutes","locationSearch","opts","routeParams","foundRoute","find","route","matchedParams","matchPathname","to","caseSensitive","fuzzy","routeCursor","matchedRoutes","parentRoute","unshift","parseErrors","parsedParamsError","parseParams","parsedParams","assign","err","PathParamError","message","cause","throwOnError","matches","parentMatch","preMatchSearch","searchError","parentSearch","validator","validateSearch","SearchParamError","loaderDeps","loaderDepsHash","JSON","stringify","interpolatedPath","interpolatePath","matchId","existingMatch","getRouteMatch","hasLoaders","loader","some","preload","match","routeId","params","joinPaths","updatedAt","Date","now","showPending","isFetching","error","paramsError","loadPromise","routeContext","abortController","AbortController","fetchCount","invalid","cancelMatch","abort","cancelMatches","pendingMatches","buildLocation","build","dest","fromSearch","at","fromPathname","fromMatches","stayingMatches","filter","e","prevParams","last","nextParams","functionalUpdate","stringifyParams","Boolean","preSearchFilters","flat","postSearchFilters","preFilteredSearch","reduce","prev","next","destSearch","postFilteredSearch","hashStr","nextState","unmaskOnReload","buildWithMatches","maskedDest","maskedNext","foundMask","routeMasks","nextMatches","maskedMatches","maskedFinal","final","mask","pick","commitLocation","startTransition","clearTimeout","isSameUrl","replace","nextHistory","apply","resetScroll","buildAndCommitLocation","rest","navigate","toString","fromString","isExternal","URL","loadMatches","latestPromise","firstBadMatchIndex","updateMatch","isPending","isMatched","matchesKey","setState","s","entries","handleErrorAndRedirect","code","routerCode","isRedirect","onError","errorHandlerErr","parentContext","beforeLoadContext","beforeLoad","validResolvedMatches","slice","matchPromises","parentMatchPromise","didShowPending","pendingMs","pendingMinMs","shouldPending","pendingComponent","defaultPendingComponent","loaderContext","deps","fetch","componentsPromise","all","component","loaderPromise","then","loaderData","r","setTimeout","onErrorError","age","staleAge","preloadStaleTime","defaultPreloadStaleTime","staleTime","defaultStaleTime","shouldReload","shouldReloadOption","invalidate","cachedMatches","load","reject","prevLocation","resolvedLocation","pathDidChange","fromLocation","toLocation","pathChanged","previousMatches","batch","cleanCache","debug","exitingMatches","enteringMatches","hook","gcTime","preloadGcTime","defaultPreloadGcTime","defaultGcTime","preloadRoute","navigateOpts","loadedMatchIds","fromEntries","matchRoute","pending","baseLocation","includeSearch","deepEqual","injectHtml","html","dehydrateData","getData","strKey","data","escapeJSON","hydrateData","window","dehydrate","dehydratedMatches","hydrate","__do_not_use_server_ctx","_ctx","__TSR_DEHYDRATED__","ctx","dehydratedData","payload","dehydratedState","router","dehydratedMatch","lazyFn","args","imported","Error","lastUpdated"],"mappings":"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"}