{"version":3,"file":"router.js","sources":["../../../../../src/router.ts"],"sourcesContent":["import {\n  HistoryLocation,\n  HistoryState,\n  RouterHistory,\n  createBrowserHistory,\n  createMemoryHistory,\n} from '@tanstack/history'\nimport { Store } from '@tanstack/react-store'\n\n//\n\nimport {\n  AnySearchSchema,\n  AnyRoute,\n  AnyContext,\n  AnyPathParams,\n  RouteMask,\n  Route,\n  LoaderFnContext,\n} from './route'\nimport { FullSearchSchema, RoutesById, RoutesByPath } from './routeInfo'\nimport { defaultParseSearch, defaultStringifySearch } from './searchParams'\nimport {\n  PickAsRequired,\n  Updater,\n  NonNullableUpdater,\n  replaceEqualDeep,\n  deepEqual,\n  escapeJSON,\n  functionalUpdate,\n  last,\n  pick,\n  PickAsPartial,\n} from './utils'\nimport {\n  ErrorRouteComponent,\n  PendingRouteComponent,\n  RouteComponent,\n} from './route'\nimport { AnyRouteMatch, RouteMatch } from './Matches'\nimport { ParsedLocation } from './location'\nimport { LocationState } from './location'\nimport { SearchSerializer, SearchParser } from './searchParams'\nimport {\n  BuildLinkFn,\n  BuildLocationFn,\n  CommitLocationOptions,\n  InjectedHtmlEntry,\n  MatchRouteFn,\n  NavigateFn,\n  getRouteMatch,\n} from './RouterProvider'\n\nimport {\n  cleanPath,\n  interpolatePath,\n  joinPaths,\n  matchPathname,\n  parsePathname,\n  resolvePath,\n  trimPath,\n  trimPathRight,\n} from './path'\nimport invariant from 'tiny-invariant'\nimport { isRedirect } from './redirects'\n// import warning from 'tiny-warning'\n\n//\n\ndeclare global {\n  interface Window {\n    __TSR_DEHYDRATED__?: HydrationCtx\n    __TSR_ROUTER_CONTEXT__?: React.Context<Router<any>>\n  }\n}\n\nexport interface Register {\n  // router: Router\n}\n\nexport type AnyRouter = Router<AnyRoute, any>\n\nexport type RegisteredRouter = Register extends {\n  router: infer TRouter extends AnyRouter\n}\n  ? TRouter\n  : AnyRouter\n\nexport type HydrationCtx = {\n  router: DehydratedRouter\n  payload: Record<string, any>\n}\n\nexport type RouterContextOptions<TRouteTree extends AnyRoute> =\n  AnyContext extends TRouteTree['types']['routerContext']\n    ? {\n        context?: TRouteTree['types']['routerContext']\n      }\n    : {\n        context: TRouteTree['types']['routerContext']\n      }\n\nexport interface RouterOptions<\n  TRouteTree extends AnyRoute,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> {\n  history?: RouterHistory\n  stringifySearch?: SearchSerializer\n  parseSearch?: SearchParser\n  defaultPreload?: false | 'intent'\n  defaultPreloadDelay?: number\n  defaultComponent?: RouteComponent<AnySearchSchema, AnyPathParams, AnyContext>\n  defaultErrorComponent?: ErrorRouteComponent<\n    AnySearchSchema,\n    AnyPathParams,\n    AnyContext\n  >\n  defaultPendingComponent?: PendingRouteComponent<\n    AnySearchSchema,\n    AnyPathParams,\n    AnyContext\n  >\n  defaultPendingMs?: number\n  defaultPendingMinMs?: number\n  caseSensitive?: boolean\n  routeTree?: TRouteTree\n  basepath?: string\n  context?: TRouteTree['types']['routerContext']\n  dehydrate?: () => TDehydrated\n  hydrate?: (dehydrated: TDehydrated) => void\n  routeMasks?: RouteMask<TRouteTree>[]\n  unmaskOnReload?: boolean\n  Wrap?: (props: { children: any }) => JSX.Element\n}\n\nexport interface RouterState<TRouteTree extends AnyRoute = AnyRoute> {\n  status: 'pending' | 'idle'\n  matches: RouteMatch<TRouteTree>[]\n  pendingMatches: RouteMatch<TRouteTree>[]\n  location: ParsedLocation<FullSearchSchema<TRouteTree>>\n  resolvedLocation: ParsedLocation<FullSearchSchema<TRouteTree>>\n  lastUpdated: number\n}\n\nexport type ListenerFn<TEvent extends RouterEvent> = (event: TEvent) => void\n\nexport interface BuildNextOptions {\n  to?: string | number | null\n  params?: true | Updater<unknown>\n  search?: true | Updater<unknown>\n  hash?: true | Updater<string>\n  state?: true | NonNullableUpdater<LocationState>\n  mask?: {\n    to?: string | number | null\n    params?: true | Updater<unknown>\n    search?: true | Updater<unknown>\n    hash?: true | Updater<string>\n    state?: true | NonNullableUpdater<LocationState>\n    unmaskOnReload?: boolean\n  }\n  from?: string\n}\n\nexport interface DehydratedRouterState {\n  dehydratedMatches: DehydratedRouteMatch[]\n}\n\nexport type DehydratedRouteMatch = Pick<\n  RouteMatch,\n  'fetchedAt' | 'invalid' | 'id' | 'status' | 'updatedAt'\n>\n\nexport interface DehydratedRouter {\n  state: DehydratedRouterState\n}\n\nexport type RouterConstructorOptions<\n  TRouteTree extends AnyRoute,\n  TDehydrated extends Record<string, any>,\n> = Omit<RouterOptions<TRouteTree, TDehydrated>, 'context'> &\n  RouterContextOptions<TRouteTree>\n\nexport const componentTypes = [\n  'component',\n  'errorComponent',\n  'pendingComponent',\n] as const\n\nexport type RouterEvents = {\n  onBeforeLoad: {\n    type: 'onBeforeLoad'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n  onLoad: {\n    type: 'onLoad'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n  onResolved: {\n    type: 'onResolved'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n}\n\nexport type RouterEvent = RouterEvents[keyof RouterEvents]\n\nexport type RouterListener<TRouterEvent extends RouterEvent> = {\n  eventType: TRouterEvent['type']\n  fn: ListenerFn<TRouterEvent>\n}\n\ntype LinkCurrentTargetElement = {\n  preloadTimeout?: null | ReturnType<typeof setTimeout>\n}\n\nconst preloadWarning = 'Error preloading route! ☝️'\n\nexport class Router<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> {\n  // Option-independent properties\n  tempLocationKey: string | undefined = `${Math.round(\n    Math.random() * 10000000,\n  )}`\n  resetNextScroll: boolean = true\n  navigateTimeout: NodeJS.Timeout | null = null\n  latestLoadPromise: Promise<void> = Promise.resolve()\n  subscribers = new Set<RouterListener<RouterEvent>>()\n  pendingMatches: AnyRouteMatch[] = []\n  injectedHtml: InjectedHtmlEntry[] = []\n  dehydratedData?: TDehydrated\n\n  // Must build in constructor\n  __store!: Store<RouterState<TRouteTree>>\n  options!: PickAsRequired<\n    RouterOptions<TRouteTree, TDehydrated>,\n    'stringifySearch' | 'parseSearch' | 'context'\n  >\n  history!: RouterHistory\n  latestLocation!: ParsedLocation\n  basepath!: string\n  routeTree!: TRouteTree\n  routesById!: RoutesById<TRouteTree>\n  routesByPath!: RoutesByPath<TRouteTree>\n  flatRoutes!: AnyRoute[]\n\n  constructor(options: RouterConstructorOptions<TRouteTree, TDehydrated>) {\n    this.update({\n      defaultPreloadDelay: 50,\n      defaultPendingMs: 1000,\n      defaultPendingMinMs: 500,\n      context: undefined!,\n      ...options,\n      stringifySearch: options?.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options?.parseSearch ?? defaultParseSearch,\n    })\n  }\n\n  // These are default implementations that can optionally be overridden\n  // by the router provider once rendered. We provide these so that the\n  // router can be used in a non-react environment if necessary\n  startReactTransition: (fn: () => void) => void = (fn) => fn()\n  isTransitioning: boolean = false\n\n  update = (newOptions: RouterConstructorOptions<TRouteTree, TDehydrated>) => {\n    this.options = {\n      ...this.options,\n      ...newOptions,\n    }\n\n    this.basepath = `/${trimPath(newOptions.basepath ?? '') ?? ''}`\n\n    if (\n      !this.history ||\n      (this.options.history && this.options.history !== this.history)\n    ) {\n      this.history =\n        this.options.history ??\n        (typeof document !== 'undefined'\n          ? createBrowserHistory()\n          : createMemoryHistory())\n      this.latestLocation = this.parseLocation()\n    }\n\n    if (this.options.routeTree !== this.routeTree) {\n      this.routeTree = this.options.routeTree as TRouteTree\n      this.buildRouteTree()\n    }\n\n    if (!this.__store) {\n      this.__store = new Store(getInitialRouterState(this.latestLocation), {\n        onUpdate: () => {\n          const isAnyTransitioning =\n            this.isTransitioning ||\n            this.__store.state.matches.some((d) => d.status === 'pending')\n\n          this.__store.state = {\n            ...this.__store.state,\n            status: isAnyTransitioning ? 'pending' : 'idle',\n            location: this.isTransitioning\n              ? this.latestLocation\n              : this.__store.state.location,\n            pendingMatches: this.pendingMatches,\n          }\n        },\n      })\n    }\n  }\n\n  get state() {\n    return this.__store.state\n  }\n\n  buildRouteTree = () => {\n    this.routesById = {} as RoutesById<TRouteTree>\n    this.routesByPath = {} as RoutesByPath<TRouteTree>\n\n    const recurseRoutes = (childRoutes: AnyRoute[]) => {\n      childRoutes.forEach((childRoute, i) => {\n        // if (typeof childRoute === 'function') {\n        //   childRoute = (childRoute as any)()\n        // }\n        childRoute.init({ originalIndex: i })\n\n        const existingRoute = (this.routesById as any)[childRoute.id]\n\n        invariant(\n          !existingRoute,\n          `Duplicate routes found with id: ${String(childRoute.id)}`,\n        )\n        ;(this.routesById as any)[childRoute.id] = childRoute\n\n        if (!childRoute.isRoot && childRoute.path) {\n          const trimmedFullPath = trimPathRight(childRoute.fullPath)\n          if (\n            !(this.routesByPath as any)[trimmedFullPath] ||\n            childRoute.fullPath.endsWith('/')\n          ) {\n            ;(this.routesByPath as any)[trimmedFullPath] = childRoute\n          }\n        }\n\n        const children = childRoute.children as Route[]\n\n        if (children?.length) {\n          recurseRoutes(children)\n        }\n      })\n    }\n\n    recurseRoutes([this.routeTree])\n\n    this.flatRoutes = (Object.values(this.routesByPath) as AnyRoute[])\n      .map((d, i) => {\n        const trimmed = trimPath(d.fullPath)\n        const parsed = parsePathname(trimmed)\n\n        while (parsed.length > 1 && parsed[0]?.value === '/') {\n          parsed.shift()\n        }\n\n        const score = parsed.map((d) => {\n          if (d.type === 'param') {\n            return 0.5\n          }\n\n          if (d.type === 'wildcard') {\n            return 0.25\n          }\n\n          return 1\n        })\n\n        return { child: d, trimmed, parsed, index: i, score }\n      })\n      .sort((a, b) => {\n        let isIndex = a.trimmed === '/' ? 1 : b.trimmed === '/' ? -1 : 0\n\n        if (isIndex !== 0) return isIndex\n\n        const length = Math.min(a.score.length, b.score.length)\n\n        // Sort by length of score\n        if (a.score.length !== b.score.length) {\n          return b.score.length - a.score.length\n        }\n\n        // Sort by min available score\n        for (let i = 0; i < length; i++) {\n          if (a.score[i] !== b.score[i]) {\n            return b.score[i]! - a.score[i]!\n          }\n        }\n\n        // Sort by min available parsed value\n        for (let i = 0; i < length; i++) {\n          if (a.parsed[i]!.value !== b.parsed[i]!.value) {\n            return a.parsed[i]!.value! > b.parsed[i]!.value! ? 1 : -1\n          }\n        }\n\n        // Sort by length of trimmed full path\n        if (a.trimmed !== b.trimmed) {\n          return a.trimmed > b.trimmed ? 1 : -1\n        }\n\n        // Sort by original index\n        return a.index - b.index\n      })\n      .map((d, i) => {\n        d.child.rank = i\n        return d.child\n      })\n  }\n\n  subscribe = <TType extends keyof RouterEvents>(\n    eventType: TType,\n    fn: ListenerFn<RouterEvents[TType]>,\n  ) => {\n    const listener: RouterListener<any> = {\n      eventType,\n      fn,\n    }\n\n    this.subscribers.add(listener)\n\n    return () => {\n      this.subscribers.delete(listener)\n    }\n  }\n\n  emit = (routerEvent: RouterEvent) => {\n    this.subscribers.forEach((listener) => {\n      if (listener.eventType === routerEvent.type) {\n        listener.fn(routerEvent)\n      }\n    })\n  }\n\n  checkLatest = (promise: Promise<void>): undefined | Promise<void> => {\n    return this.latestLoadPromise !== promise\n      ? this.latestLoadPromise\n      : undefined\n  }\n\n  parseLocation = (\n    previousLocation?: ParsedLocation,\n  ): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n    const parse = ({\n      pathname,\n      search,\n      hash,\n      state,\n    }: HistoryLocation): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n      const parsedSearch = this.options.parseSearch(search)\n\n      return {\n        pathname: pathname,\n        searchStr: search,\n        search: replaceEqualDeep(previousLocation?.search, parsedSearch) as any,\n        hash: hash.split('#').reverse()[0] ?? '',\n        href: `${pathname}${search}${hash}`,\n        state: replaceEqualDeep(previousLocation?.state, state) as HistoryState,\n      }\n    }\n\n    const location = parse(this.history.location)\n\n    let { __tempLocation, __tempKey } = location.state\n\n    if (__tempLocation && (!__tempKey || __tempKey === this.tempLocationKey)) {\n      // Sync up the location keys\n      const parsedTempLocation = parse(__tempLocation) as any\n      parsedTempLocation.state.key = location.state.key\n\n      delete parsedTempLocation.state.__tempLocation\n\n      return {\n        ...parsedTempLocation,\n        maskedLocation: location,\n      }\n    }\n\n    return location\n  }\n\n  resolvePathWithBase = (from: string, path: string) => {\n    return resolvePath(this.basepath!, from, cleanPath(path))\n  }\n\n  get looseRoutesById() {\n    return this.routesById as Record<string, AnyRoute>\n  }\n\n  matchRoutes = <TRouteTree extends AnyRoute>(\n    pathname: string,\n    locationSearch: AnySearchSchema,\n    opts?: { throwOnError?: boolean; debug?: boolean },\n  ): RouteMatch<TRouteTree>[] => {\n    let routeParams: AnyPathParams = {}\n\n    let foundRoute = this.flatRoutes.find((route) => {\n      const matchedParams = matchPathname(\n        this.basepath,\n        trimPathRight(pathname),\n        {\n          to: route.fullPath,\n          caseSensitive:\n            route.options.caseSensitive ?? this.options.caseSensitive,\n          fuzzy: false,\n        },\n      )\n\n      if (matchedParams) {\n        routeParams = matchedParams\n        return true\n      }\n\n      return false\n    })\n\n    let routeCursor: AnyRoute =\n      foundRoute || (this.routesById as any)['__root__']\n\n    let matchedRoutes: AnyRoute[] = [routeCursor]\n    // let includingLayouts = true\n    while (routeCursor?.parentRoute) {\n      routeCursor = routeCursor.parentRoute\n      if (routeCursor) matchedRoutes.unshift(routeCursor)\n    }\n\n    // Existing matches are matches that are already loaded along with\n    // pending matches that are still loading\n\n    const parseErrors = matchedRoutes.map((route) => {\n      let parsedParamsError\n\n      if (route.options.parseParams) {\n        try {\n          const parsedParams = route.options.parseParams(routeParams)\n          // Add the parsed params to the accumulated params bag\n          Object.assign(routeParams, parsedParams)\n        } catch (err: any) {\n          parsedParamsError = new PathParamError(err.message, {\n            cause: err,\n          })\n\n          if (opts?.throwOnError) {\n            throw parsedParamsError\n          }\n\n          return parsedParamsError\n        }\n      }\n\n      return\n    })\n\n    const matches: AnyRouteMatch[] = []\n\n    matchedRoutes.forEach((route, index) => {\n      // Take each matched route and resolve + validate its search params\n      // This has to happen serially because each route's search params\n      // can depend on the parent route's search params\n      // It must also happen before we create the match so that we can\n      // pass the search params to the route's potential key function\n      // which is used to uniquely identify the route match in state\n\n      const parentMatch = matches[index - 1]\n\n      const [preMatchSearch, searchError]: [Record<string, any>, any] = (() => {\n        // Validate the search params and stabilize them\n        const parentSearch = parentMatch?.search ?? locationSearch\n\n        try {\n          const validator =\n            typeof route.options.validateSearch === 'object'\n              ? route.options.validateSearch.parse\n              : route.options.validateSearch\n\n          let search = validator?.(parentSearch) ?? {}\n\n          return [\n            {\n              ...parentSearch,\n              ...search,\n            },\n            undefined,\n          ]\n        } catch (err: any) {\n          const searchError = new SearchParamError(err.message, {\n            cause: err,\n          })\n\n          if (opts?.throwOnError) {\n            throw searchError\n          }\n\n          return [parentSearch, searchError]\n        }\n      })()\n\n      const interpolatedPath = interpolatePath(route.path, routeParams)\n      const matchId =\n        interpolatePath(route.id, routeParams, true) +\n        (route.options.key?.({\n          search: preMatchSearch,\n          location: this.state.location,\n        }) ?? '')\n\n      // Waste not, want not. If we already have a match for this route,\n      // reuse it. This is important for layout routes, which might stick\n      // around between navigation actions that only change leaf routes.\n      const existingMatch = getRouteMatch(this.state, matchId)\n\n      const cause = this.state.matches.find((d) => d.id === matchId)\n        ? 'stay'\n        : 'enter'\n\n      // Create a fresh route match\n      const hasLoaders = !!(\n        route.options.loader ||\n        componentTypes.some((d) => (route.options[d] as any)?.preload)\n      )\n\n      const match: AnyRouteMatch = existingMatch\n        ? { ...existingMatch, cause }\n        : {\n            id: matchId,\n            routeId: route.id,\n            params: routeParams,\n            pathname: joinPaths([this.basepath, interpolatedPath]),\n            updatedAt: Date.now(),\n            search: {} as any,\n            searchError: undefined,\n            status: hasLoaders ? 'pending' : 'success',\n            showPending: false,\n            isFetching: false,\n            invalid: false,\n            error: undefined,\n            paramsError: parseErrors[index],\n            loadPromise: Promise.resolve(),\n            context: undefined!,\n            abortController: new AbortController(),\n            shouldReloadDeps: undefined,\n            fetchedAt: 0,\n            cause,\n          }\n\n      // Regardless of whether we're reusing an existing match or creating\n      // a new one, we need to update the match's search params\n      match.search = replaceEqualDeep(match.search, preMatchSearch)\n      // And also update the searchError if there is one\n      match.searchError = searchError\n\n      matches.push(match)\n    })\n\n    return matches as any\n  }\n\n  cancelMatch = (id: string) => {\n    getRouteMatch(this.state, id)?.abortController?.abort()\n  }\n\n  cancelMatches = () => {\n    this.state.matches.forEach((match) => {\n      this.cancelMatch(match.id)\n    })\n  }\n\n  buildLocation: BuildLocationFn<TRouteTree> = (opts) => {\n    const build = (\n      dest: BuildNextOptions & {\n        unmaskOnReload?: boolean\n      } = {},\n      matches?: AnyRouteMatch[],\n    ): ParsedLocation => {\n      const from = this.latestLocation\n      const fromPathname = dest.from ?? from.pathname\n\n      let pathname = this.resolvePathWithBase(fromPathname, `${dest.to ?? ''}`)\n\n      const fromMatches = this.matchRoutes(fromPathname, from.search)\n      const stayingMatches = matches?.filter(\n        (d) => fromMatches?.find((e) => e.routeId === d.routeId),\n      )\n\n      const prevParams = { ...last(fromMatches)?.params }\n\n      let nextParams =\n        (dest.params ?? true) === true\n          ? prevParams\n          : functionalUpdate(dest.params!, prevParams)\n\n      if (nextParams) {\n        matches\n          ?.map((d) => this.looseRoutesById[d.routeId]!.options.stringifyParams)\n          .filter(Boolean)\n          .forEach((fn) => {\n            nextParams = { ...nextParams!, ...fn!(nextParams!) }\n          })\n      }\n\n      pathname = interpolatePath(pathname, nextParams ?? {})\n\n      const preSearchFilters =\n        stayingMatches\n          ?.map(\n            (match) =>\n              this.looseRoutesById[match.routeId]!.options.preSearchFilters ??\n              [],\n          )\n          .flat()\n          .filter(Boolean) ?? []\n\n      const postSearchFilters =\n        stayingMatches\n          ?.map(\n            (match) =>\n              this.looseRoutesById[match.routeId]!.options.postSearchFilters ??\n              [],\n          )\n          .flat()\n          .filter(Boolean) ?? []\n\n      // Pre filters first\n      const preFilteredSearch = preSearchFilters?.length\n        ? preSearchFilters?.reduce(\n            (prev, next) => next(prev) as any,\n            from.search,\n          )\n        : from.search\n\n      // Then the link/navigate function\n      const destSearch =\n        dest.search === true\n          ? preFilteredSearch // Preserve resolvedFrom true\n          : dest.search\n            ? functionalUpdate(dest.search, preFilteredSearch) ?? {} // Updater\n            : preSearchFilters?.length\n              ? preFilteredSearch // Preserve resolvedFrom filters\n              : {}\n\n      // Then post filters\n      const postFilteredSearch = postSearchFilters?.length\n        ? postSearchFilters.reduce((prev, next) => next(prev), destSearch)\n        : destSearch\n\n      const search = replaceEqualDeep(from.search, postFilteredSearch)\n\n      const searchStr = this.options.stringifySearch(search)\n\n      const hash =\n        dest.hash === true\n          ? from.hash\n          : dest.hash\n            ? functionalUpdate(dest.hash!, from.hash)\n            : from.hash\n\n      const hashStr = hash ? `#${hash}` : ''\n\n      let nextState =\n        dest.state === true\n          ? from.state\n          : dest.state\n            ? functionalUpdate(dest.state, from.state)\n            : from.state\n\n      nextState = replaceEqualDeep(from.state, nextState)\n\n      return {\n        pathname,\n        search,\n        searchStr,\n        state: nextState as any,\n        hash,\n        href: this.history.createHref(`${pathname}${searchStr}${hashStr}`),\n        unmaskOnReload: dest.unmaskOnReload,\n      }\n    }\n\n    const buildWithMatches = (\n      dest: BuildNextOptions = {},\n      maskedDest?: BuildNextOptions,\n    ) => {\n      let next = build(dest)\n      let maskedNext = maskedDest ? build(maskedDest) : undefined\n\n      if (!maskedNext) {\n        let params = {}\n\n        let foundMask = this.options.routeMasks?.find((d) => {\n          const match = matchPathname(this.basepath, next.pathname, {\n            to: d.from,\n            caseSensitive: false,\n            fuzzy: false,\n          })\n\n          if (match) {\n            params = match\n            return true\n          }\n\n          return false\n        })\n\n        if (foundMask) {\n          foundMask = {\n            ...foundMask,\n            from: interpolatePath(foundMask.from, params) as any,\n          }\n          maskedDest = foundMask\n          maskedNext = build(maskedDest)\n        }\n      }\n\n      const nextMatches = this.matchRoutes(next.pathname, next.search)\n      const maskedMatches = maskedNext\n        ? this.matchRoutes(maskedNext.pathname, maskedNext.search)\n        : undefined\n      const maskedFinal = maskedNext\n        ? build(maskedDest, maskedMatches)\n        : undefined\n\n      const final = build(dest, nextMatches)\n\n      if (maskedFinal) {\n        final.maskedLocation = maskedFinal\n      }\n\n      return final\n    }\n\n    if (opts.mask) {\n      return buildWithMatches(opts, {\n        ...pick(opts, ['from']),\n        ...opts.mask,\n      })\n    }\n\n    return buildWithMatches(opts)\n  }\n\n  commitLocation = async ({\n    startTransition,\n    ...next\n  }: ParsedLocation & CommitLocationOptions) => {\n    if (this.navigateTimeout) clearTimeout(this.navigateTimeout)\n\n    const isSameUrl = this.latestLocation.href === next.href\n\n    // If the next urls are the same and we're not replacing,\n    // do nothing\n    if (!isSameUrl || !next.replace) {\n      let { maskedLocation, ...nextHistory } = next\n\n      if (maskedLocation) {\n        nextHistory = {\n          ...maskedLocation,\n          state: {\n            ...maskedLocation.state,\n            __tempKey: undefined,\n            __tempLocation: {\n              ...nextHistory,\n              search: nextHistory.searchStr,\n              state: {\n                ...nextHistory.state,\n                __tempKey: undefined!,\n                __tempLocation: undefined!,\n                key: undefined!,\n              },\n            },\n          },\n        }\n\n        if (\n          nextHistory.unmaskOnReload ??\n          this.options.unmaskOnReload ??\n          false\n        ) {\n          nextHistory.state.__tempKey = this.tempLocationKey\n        }\n      }\n\n      const apply = () => {\n        this.history[next.replace ? 'replace' : 'push'](\n          nextHistory.href,\n          nextHistory.state,\n        )\n      }\n\n      if (startTransition ?? true) {\n        this.startReactTransition(apply)\n      } else {\n        apply()\n      }\n    }\n\n    this.resetNextScroll = next.resetScroll ?? true\n\n    return this.latestLoadPromise\n  }\n\n  buildAndCommitLocation = ({\n    replace,\n    resetScroll,\n    startTransition,\n    ...rest\n  }: BuildNextOptions & CommitLocationOptions = {}) => {\n    const location = this.buildLocation(rest)\n    return this.commitLocation({\n      ...location,\n      startTransition,\n      replace,\n      resetScroll,\n    })\n  }\n\n  navigate: NavigateFn<TRouteTree> = ({ from, to = '', ...rest }) => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n    const toString = String(to)\n    const fromString = typeof from === 'undefined' ? from : String(from)\n    let isExternal\n\n    try {\n      new URL(`${toString}`)\n      isExternal = true\n    } catch (e) {}\n\n    invariant(\n      !isExternal,\n      'Attempting to navigate to external url with this.navigate!',\n    )\n\n    return this.buildAndCommitLocation({\n      ...rest,\n      from: fromString,\n      to: toString,\n    })\n  }\n\n  loadMatches = async ({\n    checkLatest,\n    matches,\n    preload,\n    invalidate,\n  }: {\n    checkLatest: () => Promise<void> | undefined\n    matches: AnyRouteMatch[]\n    preload?: boolean\n    invalidate?: boolean\n  }): Promise<RouteMatch[]> => {\n    let latestPromise\n    let firstBadMatchIndex: number | undefined\n\n    // Check each match middleware to see if the route can be accessed\n    try {\n      for (let [index, match] of matches.entries()) {\n        const parentMatch = matches[index - 1]\n        const route = this.looseRoutesById[match.routeId]!\n\n        const handleError = (err: any, code: string) => {\n          err.routerCode = code\n          firstBadMatchIndex = firstBadMatchIndex ?? index\n\n          if (isRedirect(err)) {\n            throw err\n          }\n\n          try {\n            route.options.onError?.(err)\n          } catch (errorHandlerErr) {\n            err = errorHandlerErr\n\n            if (isRedirect(errorHandlerErr)) {\n              throw errorHandlerErr\n            }\n          }\n\n          matches[index] = match = {\n            ...match,\n            error: err,\n            status: 'error',\n            updatedAt: Date.now(),\n          }\n        }\n\n        try {\n          if (match.paramsError) {\n            handleError(match.paramsError, 'PARSE_PARAMS')\n          }\n\n          if (match.searchError) {\n            handleError(match.searchError, 'VALIDATE_SEARCH')\n          }\n\n          const parentContext =\n            parentMatch?.context ?? this.options.context ?? {}\n\n          const beforeLoadContext =\n            (await route.options.beforeLoad?.({\n              search: match.search,\n              abortController: match.abortController,\n              params: match.params,\n              preload: !!preload,\n              context: parentContext,\n              location: this.state.location,\n              // TOOD: just expose state and router, etc\n              navigate: (opts) =>\n                this.navigate({ ...opts, from: match.pathname } as any),\n              buildLocation: this.buildLocation,\n              cause: match.cause,\n            })) ?? ({} as any)\n\n          const context = {\n            ...parentContext,\n            ...beforeLoadContext,\n          }\n\n          matches[index] = match = {\n            ...match,\n            context: replaceEqualDeep(match.context, context),\n          }\n        } catch (err) {\n          handleError(err, 'BEFORE_LOAD')\n          break\n        }\n      }\n    } catch (err) {\n      if (isRedirect(err)) {\n        if (!preload) this.navigate(err as any)\n        return matches\n      }\n\n      throw err\n    }\n\n    const validResolvedMatches = matches.slice(0, firstBadMatchIndex)\n    const matchPromises: Promise<any>[] = []\n\n    validResolvedMatches.forEach((match, index) => {\n      matchPromises.push(\n        (async () => {\n          const parentMatchPromise = matchPromises[index - 1]\n          const route = this.looseRoutesById[match.routeId]!\n\n          const handleIfRedirect = (err: any) => {\n            if (isRedirect(err)) {\n              if (!preload) {\n                this.navigate(err as any)\n              }\n              return true\n            }\n            return false\n          }\n\n          let loadPromise: Promise<void> | undefined\n\n          matches[index] = match = {\n            ...match,\n            fetchedAt: Date.now(),\n            invalid: false,\n            showPending: false,\n          }\n\n          const pendingMs =\n            route.options.pendingMs ?? this.options.defaultPendingMs\n\n          let pendingPromise: Promise<void> | undefined\n\n          if (\n            !preload &&\n            pendingMs &&\n            (route.options.pendingComponent ??\n              this.options.defaultPendingComponent)\n          ) {\n            pendingPromise = new Promise((r) => setTimeout(r, pendingMs))\n          }\n\n          if (match.isFetching) {\n            loadPromise = getRouteMatch(this.state, match.id)?.loadPromise\n          } else {\n            const loaderContext: LoaderFnContext = {\n              params: match.params,\n              search: match.search,\n              preload: !!preload,\n              parentMatchPromise,\n              abortController: match.abortController,\n              context: match.context,\n              location: this.state.location,\n              navigate: (opts) =>\n                this.navigate({ ...opts, from: match.pathname } as any),\n              cause: match.cause,\n            }\n\n            // Default to reloading the route all the time\n            let shouldReload = true\n\n            let shouldReloadDeps =\n              typeof route.options.shouldReload === 'function'\n                ? route.options.shouldReload?.(loaderContext)\n                : !!(route.options.shouldReload ?? true)\n\n            if (match.cause === 'enter' || invalidate) {\n              match.shouldReloadDeps = shouldReloadDeps\n            } else if (match.cause === 'stay') {\n              if (typeof shouldReloadDeps === 'object') {\n                // compare the deps to see if they've changed\n                shouldReload = !deepEqual(\n                  shouldReloadDeps,\n                  match.shouldReloadDeps,\n                )\n\n                match.shouldReloadDeps = shouldReloadDeps\n              } else {\n                shouldReload = !!shouldReloadDeps\n              }\n            }\n\n            // If the user doesn't want the route to reload, just\n            // resolve with the existing loader data\n\n            if (!shouldReload) {\n              loadPromise = Promise.resolve(match.loaderData)\n            } else {\n              // Otherwise, load the route\n              matches[index] = match = {\n                ...match,\n                isFetching: true,\n              }\n\n              const componentsPromise = Promise.all(\n                componentTypes.map(async (type) => {\n                  const component = route.options[type]\n\n                  if ((component as any)?.preload) {\n                    await (component as any).preload()\n                  }\n                }),\n              )\n\n              const loaderPromise = route.options.loader?.(loaderContext)\n\n              loadPromise = Promise.all([\n                componentsPromise,\n                loaderPromise,\n              ]).then((d) => d[1])\n            }\n          }\n\n          matches[index] = match = {\n            ...match,\n            loadPromise,\n          }\n\n          if (!preload) {\n            this.__store.setState((s) => ({\n              ...s,\n              matches: s.matches.map((d) => (d.id === match.id ? match : d)),\n            }))\n          }\n\n          let didShowPending = false\n\n          await new Promise<void>(async (resolve) => {\n            // If the route has a pending component and a pendingMs option,\n            // forcefully show the pending component\n            if (pendingPromise) {\n              pendingPromise.then(() => {\n                if ((latestPromise = checkLatest())) return\n\n                didShowPending = true\n                matches[index] = match = {\n                  ...match,\n                  showPending: true,\n                }\n\n                this.__store.setState((s) => ({\n                  ...s,\n                  matches: s.matches.map((d) =>\n                    d.id === match.id ? match : d,\n                  ),\n                }))\n                resolve()\n              })\n            }\n\n            try {\n              const loaderData = await loadPromise\n              if ((latestPromise = checkLatest())) return await latestPromise\n\n              const pendingMinMs =\n                route.options.pendingMinMs ?? this.options.defaultPendingMinMs\n\n              if (didShowPending && pendingMinMs) {\n                await new Promise((r) => setTimeout(r, pendingMinMs))\n              }\n\n              if ((latestPromise = checkLatest())) return await latestPromise\n\n              matches[index] = match = {\n                ...match,\n                error: undefined,\n                status: 'success',\n                isFetching: false,\n                updatedAt: Date.now(),\n                loaderData,\n                loadPromise: undefined,\n              }\n            } catch (error) {\n              if ((latestPromise = checkLatest())) return await latestPromise\n              if (handleIfRedirect(error)) return\n\n              try {\n                route.options.onError?.(error)\n              } catch (onErrorError) {\n                error = onErrorError\n                if (handleIfRedirect(onErrorError)) return\n              }\n\n              matches[index] = match = {\n                ...match,\n                error,\n                status: 'error',\n                isFetching: false,\n                updatedAt: Date.now(),\n              }\n            }\n\n            if (!preload) {\n              this.__store.setState((s) => ({\n                ...s,\n                matches: s.matches.map((d) => (d.id === match.id ? match : d)),\n              }))\n            }\n\n            resolve()\n          })\n        })(),\n      )\n    })\n\n    await Promise.all(matchPromises)\n    return matches\n  }\n\n  invalidate = () =>\n    this.load({\n      invalidate: true,\n    })\n\n  load = async (opts?: { invalidate?: boolean }): Promise<void> => {\n    const promise = new Promise<void>(async (resolve, reject) => {\n      const next = this.latestLocation\n      const prevLocation = this.state.resolvedLocation\n      const pathDidChange = prevLocation!.href !== next.href\n      let latestPromise: Promise<void> | undefined | null\n\n      // Cancel any pending matches\n      this.cancelMatches()\n\n      this.emit({\n        type: 'onBeforeLoad',\n        fromLocation: prevLocation,\n        toLocation: next,\n        pathChanged: pathDidChange,\n      })\n\n      // Match the routes\n      let matches: RouteMatch<any, any>[] = this.matchRoutes(\n        next.pathname,\n        next.search,\n        {\n          debug: true,\n        },\n      )\n\n      this.pendingMatches = matches\n\n      const previousMatches = this.state.matches\n\n      // Ingest the new matches\n      this.__store.setState((s) => ({\n        ...s,\n        // status: 'pending',\n        location: next,\n        matches,\n      }))\n\n      try {\n        try {\n          // Load the matches\n          await this.loadMatches({\n            matches,\n            checkLatest: () => this.checkLatest(promise),\n            invalidate: opts?.invalidate,\n          })\n        } catch (err) {\n          // swallow this error, since we'll display the\n          // errors on the route components\n        }\n\n        // Only apply the latest transition\n        if ((latestPromise = this.checkLatest(promise))) {\n          return latestPromise\n        }\n\n        const exitingMatchIds = previousMatches.filter(\n          (id) => !this.pendingMatches.includes(id),\n        )\n        const enteringMatchIds = this.pendingMatches.filter(\n          (id) => !previousMatches.includes(id),\n        )\n        const stayingMatchIds = previousMatches.filter((id) =>\n          this.pendingMatches.includes(id),\n        )\n\n        // setState((s) => ({\n        //   ...s,\n        //   status: 'idle',\n        //   resolvedLocation: s.location,\n        //   matches,\n        // }))\n\n        //\n        ;(\n          [\n            [exitingMatchIds, 'onLeave'],\n            [enteringMatchIds, 'onEnter'],\n            [stayingMatchIds, 'onTransition'],\n          ] as const\n        ).forEach(([matches, hook]) => {\n          matches.forEach((match) => {\n            this.looseRoutesById[match.routeId]!.options[hook]?.(match)\n          })\n        })\n\n        this.emit({\n          type: 'onLoad',\n          fromLocation: prevLocation,\n          toLocation: next,\n          pathChanged: pathDidChange,\n        })\n\n        resolve()\n      } catch (err) {\n        // Only apply the latest transition\n        if ((latestPromise = this.checkLatest(promise))) {\n          return latestPromise\n        }\n\n        reject(err)\n      }\n    })\n\n    this.latestLoadPromise = promise\n\n    return this.latestLoadPromise\n  }\n\n  preloadRoute = async (\n    navigateOpts: BuildNextOptions = this.state.location,\n  ) => {\n    let next = this.buildLocation(navigateOpts)\n\n    let matches = this.matchRoutes(next.pathname, next.search, {\n      throwOnError: true,\n    })\n\n    await this.loadMatches({\n      matches,\n      preload: true,\n      checkLatest: () => undefined,\n    })\n\n    return [last(matches)!, matches] as const\n  }\n\n  buildLink: BuildLinkFn<TRouteTree> = (dest) => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n\n    const {\n      to,\n      preload: userPreload,\n      preloadDelay: userPreloadDelay,\n      activeOptions,\n      disabled,\n      target,\n      replace,\n      resetScroll,\n      startTransition,\n    } = dest\n\n    try {\n      new URL(`${to}`)\n      return {\n        type: 'external',\n        href: to as any,\n      }\n    } catch (e) {}\n\n    const nextOpts = dest\n    const next = this.buildLocation(nextOpts as any)\n\n    const preload = userPreload ?? this.options.defaultPreload\n    const preloadDelay =\n      userPreloadDelay ?? this.options.defaultPreloadDelay ?? 0\n\n    // Compare path/hash for matches\n    const currentPathSplit = this.latestLocation.pathname.split('/')\n    const nextPathSplit = next.pathname.split('/')\n    const pathIsFuzzyEqual = nextPathSplit.every(\n      (d, i) => d === currentPathSplit[i],\n    )\n    // Combine the matches based on user this.options\n    const pathTest = activeOptions?.exact\n      ? this.latestLocation.pathname === next.pathname\n      : pathIsFuzzyEqual\n    const hashTest = activeOptions?.includeHash\n      ? this.latestLocation.hash === next.hash\n      : true\n    const searchTest =\n      activeOptions?.includeSearch ?? true\n        ? deepEqual(this.latestLocation.search, next.search, true)\n        : true\n\n    // The final \"active\" test\n    const isActive = pathTest && hashTest && searchTest\n\n    // The click handler\n    const handleClick = (e: MouseEvent) => {\n      if (\n        !disabled &&\n        !isCtrlEvent(e) &&\n        !e.defaultPrevented &&\n        (!target || target === '_self') &&\n        e.button === 0\n      ) {\n        e.preventDefault()\n\n        // All is well? Navigate!\n        this.commitLocation({ ...next, replace, resetScroll, startTransition })\n      }\n    }\n\n    // The click handler\n    const handleFocus = (e: MouseEvent) => {\n      if (preload) {\n        this.preloadRoute(nextOpts as any).catch((err) => {\n          console.warn(err)\n          console.warn(preloadWarning)\n        })\n      }\n    }\n\n    const handleTouchStart = (e: TouchEvent) => {\n      this.preloadRoute(nextOpts as any).catch((err) => {\n        console.warn(err)\n        console.warn(preloadWarning)\n      })\n    }\n\n    const handleEnter = (e: MouseEvent) => {\n      const target = (e.target || {}) as LinkCurrentTargetElement\n\n      if (preload) {\n        if (target.preloadTimeout) {\n          return\n        }\n\n        target.preloadTimeout = setTimeout(() => {\n          target.preloadTimeout = null\n          this.preloadRoute(nextOpts as any).catch((err) => {\n            console.warn(err)\n            console.warn(preloadWarning)\n          })\n        }, preloadDelay)\n      }\n    }\n\n    const handleLeave = (e: MouseEvent) => {\n      const target = (e.target || {}) as LinkCurrentTargetElement\n\n      if (target.preloadTimeout) {\n        clearTimeout(target.preloadTimeout)\n        target.preloadTimeout = null\n      }\n    }\n\n    return {\n      type: 'internal',\n      next,\n      handleFocus,\n      handleClick,\n      handleEnter,\n      handleLeave,\n      handleTouchStart,\n      isActive,\n      disabled,\n    }\n  }\n\n  matchRoute: MatchRouteFn<TRouteTree> = (location, opts) => {\n    location = {\n      ...location,\n      to: location.to\n        ? this.resolvePathWithBase((location.from || '') as string, location.to)\n        : undefined,\n    } as any\n\n    const next = this.buildLocation(location as any)\n\n    if (opts?.pending && this.state.status !== 'pending') {\n      return false\n    }\n\n    const baseLocation = opts?.pending\n      ? this.latestLocation\n      : this.state.resolvedLocation\n\n    // const baseLocation = state.resolvedLocation\n\n    if (!baseLocation) {\n      return false\n    }\n\n    const match = matchPathname(this.basepath, baseLocation.pathname, {\n      ...opts,\n      to: next.pathname,\n    }) as any\n\n    if (!match) {\n      return false\n    }\n\n    if (match && (opts?.includeSearch ?? true)) {\n      return deepEqual(baseLocation.search, next.search, true) ? match : false\n    }\n\n    return match\n  }\n\n  injectHtml = async (html: string | (() => Promise<string> | string)) => {\n    this.injectedHtml.push(html)\n  }\n\n  dehydrateData = <T>(key: any, getData: T | (() => Promise<T> | T)) => {\n    if (typeof document === 'undefined') {\n      const strKey = typeof key === 'string' ? key : JSON.stringify(key)\n\n      this.injectHtml(async () => {\n        const id = `__TSR_DEHYDRATED__${strKey}`\n        const data =\n          typeof getData === 'function' ? await (getData as any)() : getData\n        return `<script id='${id}' suppressHydrationWarning>window[\"__TSR_DEHYDRATED__${escapeJSON(\n          strKey,\n        )}\"] = ${JSON.stringify(data)}\n          ;(() => {\n            var el = document.getElementById('${id}')\n            el.parentElement.removeChild(el)\n          })()\n          </script>`\n      })\n\n      return () => this.hydrateData<T>(key)\n    }\n\n    return () => undefined\n  }\n\n  hydrateData = <T extends any = unknown>(key: any) => {\n    if (typeof document !== 'undefined') {\n      const strKey = typeof key === 'string' ? key : JSON.stringify(key)\n\n      return window[`__TSR_DEHYDRATED__${strKey}` as any] as T\n    }\n\n    return undefined\n  }\n\n  dehydrate = (): DehydratedRouter => {\n    return {\n      state: {\n        dehydratedMatches: this.state.matches.map((d) =>\n          pick(d, [\n            'fetchedAt',\n            'invalid',\n            'id',\n            'status',\n            'updatedAt',\n            'loaderData',\n          ]),\n        ),\n      },\n    }\n  }\n\n  hydrate = async (__do_not_use_server_ctx?: HydrationCtx) => {\n    let _ctx = __do_not_use_server_ctx\n    // Client hydrates from window\n    if (typeof document !== 'undefined') {\n      _ctx = window.__TSR_DEHYDRATED__\n    }\n\n    invariant(\n      _ctx,\n      'Expected to find a __TSR_DEHYDRATED__ property on window... but we did not. Did you forget to render <DehydrateRouter /> in your app?',\n    )\n\n    const ctx = _ctx\n    this.dehydratedData = ctx.payload as any\n    this.options.hydrate?.(ctx.payload as any)\n    const dehydratedState = ctx.router.state\n\n    let matches = this.matchRoutes(\n      this.state.location.pathname,\n      this.state.location.search,\n    ).map((match) => {\n      const dehydratedMatch = dehydratedState.dehydratedMatches.find(\n        (d) => d.id === match.id,\n      )\n\n      invariant(\n        dehydratedMatch,\n        `Could not find a client-side match for dehydrated match with id: ${match.id}!`,\n      )\n\n      if (dehydratedMatch) {\n        return {\n          ...match,\n          ...dehydratedMatch,\n        }\n      }\n      return match\n    })\n\n    this.__store.setState((s) => {\n      return {\n        ...s,\n        matches: matches as any,\n      }\n    })\n  }\n\n  // resolveMatchPromise = (matchId: string, key: string, value: any) => {\n  //   state.matches\n  //     .find((d) => d.id === matchId)\n  //     ?.__promisesByKey[key]?.resolve(value)\n  // }\n}\n\n// A function that takes an import() argument which is a function and returns a new function that will\n// proxy arguments from the caller to the imported function, retaining all type\n// information along the way\nexport function lazyFn<\n  T extends Record<string, (...args: any[]) => any>,\n  TKey extends keyof T = 'default',\n>(fn: () => Promise<T>, key?: TKey) {\n  return async (...args: Parameters<T[TKey]>): Promise<ReturnType<T[TKey]>> => {\n    const imported = await fn()\n    return imported[key || 'default'](...args)\n  }\n}\n\nfunction isCtrlEvent(e: MouseEvent) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n}\nexport class SearchParamError extends Error {}\n\nexport class PathParamError extends Error {}\n\nexport function getInitialRouterState(\n  location: ParsedLocation,\n): RouterState<any> {\n  return {\n    status: 'idle',\n    resolvedLocation: location,\n    location,\n    matches: [],\n    pendingMatches: [],\n    lastUpdated: Date.now(),\n  }\n}\n"],"names":["componentTypes","preloadWarning","Router","tempLocationKey","Math","round","random","resetNextScroll","navigateTimeout","latestLoadPromise","Promise","resolve","subscribers","Set","pendingMatches","injectedHtml","constructor","options","update","defaultPreloadDelay","defaultPendingMs","defaultPendingMinMs","context","undefined","stringifySearch","defaultStringifySearch","parseSearch","defaultParseSearch","startReactTransition","fn","isTransitioning","newOptions","basepath","trimPath","history","document","createBrowserHistory","createMemoryHistory","latestLocation","parseLocation","routeTree","buildRouteTree","__store","Store","getInitialRouterState","onUpdate","isAnyTransitioning","state","matches","some","d","status","location","routesById","routesByPath","recurseRoutes","childRoutes","forEach","childRoute","i","init","originalIndex","existingRoute","id","invariant","String","isRoot","path","trimmedFullPath","trimPathRight","fullPath","endsWith","children","length","flatRoutes","Object","values","map","trimmed","parsed","parsePathname","value","shift","score","type","child","index","sort","a","b","isIndex","min","rank","subscribe","eventType","listener","add","delete","emit","routerEvent","checkLatest","promise","previousLocation","parse","pathname","search","hash","parsedSearch","searchStr","replaceEqualDeep","split","reverse","href","__tempLocation","__tempKey","parsedTempLocation","key","maskedLocation","resolvePathWithBase","from","resolvePath","cleanPath","looseRoutesById","matchRoutes","locationSearch","opts","routeParams","foundRoute","find","route","matchedParams","matchPathname","to","caseSensitive","fuzzy","routeCursor","matchedRoutes","parentRoute","unshift","parseErrors","parsedParamsError","parseParams","parsedParams","assign","err","PathParamError","message","cause","throwOnError","parentMatch","preMatchSearch","searchError","parentSearch","validator","validateSearch","SearchParamError","interpolatedPath","interpolatePath","matchId","existingMatch","getRouteMatch","hasLoaders","loader","preload","match","routeId","params","joinPaths","updatedAt","Date","now","showPending","isFetching","invalid","error","paramsError","loadPromise","abortController","AbortController","shouldReloadDeps","fetchedAt","push","cancelMatch","abort","cancelMatches","buildLocation","build","dest","fromPathname","fromMatches","stayingMatches","filter","e","prevParams","last","nextParams","functionalUpdate","stringifyParams","Boolean","preSearchFilters","flat","postSearchFilters","preFilteredSearch","reduce","prev","next","destSearch","postFilteredSearch","hashStr","nextState","createHref","unmaskOnReload","buildWithMatches","maskedDest","maskedNext","foundMask","routeMasks","nextMatches","maskedMatches","maskedFinal","final","mask","pick","commitLocation","startTransition","clearTimeout","isSameUrl","replace","nextHistory","apply","resetScroll","buildAndCommitLocation","rest","navigate","toString","fromString","isExternal","URL","loadMatches","invalidate","latestPromise","firstBadMatchIndex","entries","handleError","code","routerCode","isRedirect","onError","errorHandlerErr","parentContext","beforeLoadContext","beforeLoad","validResolvedMatches","slice","matchPromises","parentMatchPromise","handleIfRedirect","pendingMs","pendingPromise","pendingComponent","defaultPendingComponent","r","setTimeout","loaderContext","shouldReload","deepEqual","loaderData","componentsPromise","all","component","loaderPromise","then","setState","s","didShowPending","pendingMinMs","onErrorError","load","reject","prevLocation","resolvedLocation","pathDidChange","fromLocation","toLocation","pathChanged","debug","previousMatches","exitingMatchIds","includes","enteringMatchIds","stayingMatchIds","hook","preloadRoute","navigateOpts","buildLink","userPreload","preloadDelay","userPreloadDelay","activeOptions","disabled","target","nextOpts","defaultPreload","currentPathSplit","nextPathSplit","pathIsFuzzyEqual","every","pathTest","exact","hashTest","includeHash","searchTest","includeSearch","isActive","handleClick","isCtrlEvent","defaultPrevented","button","preventDefault","handleFocus","catch","console","warn","handleTouchStart","handleEnter","preloadTimeout","handleLeave","matchRoute","pending","baseLocation","injectHtml","html","dehydrateData","getData","strKey","JSON","stringify","data","escapeJSON","hydrateData","window","dehydrate","dehydratedMatches","hydrate","__do_not_use_server_ctx","_ctx","__TSR_DEHYDRATED__","ctx","dehydratedData","payload","dehydratedState","router","dehydratedMatch","lazyFn","args","imported","metaKey","altKey","ctrlKey","shiftKey","Error","lastUpdated"],"mappings":"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"}