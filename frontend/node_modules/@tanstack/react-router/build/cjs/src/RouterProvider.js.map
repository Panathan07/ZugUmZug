{"version":3,"file":"RouterProvider.js","sources":["../../../src/RouterProvider.tsx"],"sourcesContent":["import {\n  HistoryLocation,\n  HistoryState,\n  RouterHistory,\n  createBrowserHistory,\n} from '@tanstack/history'\nimport * as React from 'react'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { Matches } from './Matches'\nimport {\n  LinkInfo,\n  LinkOptions,\n  NavigateOptions,\n  ResolveRelativePath,\n  ToOptions,\n} from './link'\nimport { ParsedLocation } from './location'\nimport {\n  cleanPath,\n  interpolatePath,\n  joinPaths,\n  matchPathname,\n  parsePathname,\n  resolvePath,\n  trimPath,\n  trimPathRight,\n} from './path'\nimport { isRedirect } from './redirects'\nimport {\n  AnyPathParams,\n  AnyRoute,\n  AnySearchSchema,\n  LoaderFnContext,\n  Route,\n} from './route'\nimport {\n  FullSearchSchema,\n  ParseRoute,\n  RouteById,\n  RouteIds,\n  RoutePaths,\n  RoutesById,\n  RoutesByPath,\n} from './routeInfo'\nimport {\n  BuildNextOptions,\n  DehydratedRouteMatch,\n  RegisteredRouter,\n  Router,\n  RouterOptions,\n  RouterState,\n  componentTypes,\n} from './router'\nimport {\n  NoInfer,\n  PickAsRequired,\n  functionalUpdate,\n  last,\n  deepEqual,\n  pick,\n  replaceEqualDeep,\n  useStableCallback,\n} from './utils'\nimport { MatchRouteOptions } from './Matches'\n\nexport interface CommitLocationOptions {\n  replace?: boolean\n  resetScroll?: boolean\n  startTransition?: boolean\n}\n\nexport interface MatchLocation {\n  to?: string | number | null\n  fuzzy?: boolean\n  caseSensitive?: boolean\n  from?: string\n}\n\ntype LinkCurrentTargetElement = {\n  preloadTimeout?: null | ReturnType<typeof setTimeout>\n}\n\nexport type BuildLinkFn<TRouteTree extends AnyRoute> = <\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n>(\n  dest: LinkOptions<TRouteTree, TFrom, TTo>,\n) => LinkInfo\n\nexport type NavigateFn<TRouteTree extends AnyRoute> = <\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n>(\n  opts: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n) => Promise<void>\n\nexport type MatchRouteFn<TRouteTree extends AnyRoute> = <\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n>(\n  location: ToOptions<TRouteTree, TFrom, TTo>,\n  opts?: MatchRouteOptions,\n) => false | RouteById<TRouteTree, TResolved>['types']['allParams']\n\nexport type LoadFn = (opts?: {\n  next?: ParsedLocation\n  throwOnError?: boolean\n  __dehydratedMatches?: DehydratedRouteMatch[]\n}) => Promise<void>\n\nexport type BuildLocationFn<TRouteTree extends AnyRoute> = (\n  opts: BuildNextOptions,\n) => ParsedLocation\n\nexport type RouterContext<\n  TRouteTree extends AnyRoute,\n  // TDehydrated extends Record<string, any>,\n> = {\n  buildLink: BuildLinkFn<TRouteTree>\n  state: RouterState<TRouteTree>\n  navigate: NavigateFn<TRouteTree>\n  matchRoute: MatchRouteFn<TRouteTree>\n  routeTree: TRouteTree\n  routesById: RoutesById<TRouteTree>\n  options: RouterOptions<TRouteTree>\n  history: RouterHistory\n  load: LoadFn\n  buildLocation: BuildLocationFn<TRouteTree>\n  subscribe: Router<TRouteTree>['subscribe']\n  resetNextScrollRef: React.MutableRefObject<boolean>\n}\n\nexport const routerContext = React.createContext<RouterContext<any>>(null!)\n\nif (typeof document !== 'undefined') {\n  window.__TSR_ROUTER_CONTEXT__ = routerContext as any\n}\n\nconst preloadWarning = 'Error preloading route! ☝️'\n\nfunction isCtrlEvent(e: MouseEvent) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n}\n\nexport class SearchParamError extends Error {}\n\nexport class PathParamError extends Error {}\n\nexport function getInitialRouterState(\n  location: ParsedLocation,\n): RouterState<any> {\n  return {\n    status: 'idle',\n    resolvedLocation: location,\n    location,\n    matches: [],\n    pendingMatches: [],\n    lastUpdated: Date.now(),\n  }\n}\n\nexport function RouterProvider<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TDehydrated extends Record<string, any> = Record<string, any>,\n>({ router, ...rest }: RouterProps<TRouteTree, TDehydrated>) {\n  const options = {\n    ...router.options,\n    ...rest,\n    context: {\n      ...router.options.context,\n      ...rest?.context,\n    },\n  } as PickAsRequired<\n    RouterOptions<TRouteTree, TDehydrated>,\n    'stringifySearch' | 'parseSearch' | 'context'\n  >\n\n  const history = React.useState(\n    () => options.history ?? createBrowserHistory(),\n  )[0]\n\n  const tempLocationKeyRef = React.useRef<string | undefined>(\n    `${Math.round(Math.random() * 10000000)}`,\n  )\n  const resetNextScrollRef = React.useRef<boolean>(true)\n  const navigateTimeoutRef = React.useRef<NodeJS.Timeout | null>(null)\n  const latestLoadPromiseRef = React.useRef<Promise<void>>(Promise.resolve())\n\n  const checkLatest = (promise: Promise<void>): undefined | Promise<void> => {\n    return latestLoadPromiseRef.current !== promise\n      ? latestLoadPromiseRef.current\n      : undefined\n  }\n\n  const parseLocation = useStableCallback(\n    (\n      previousLocation?: ParsedLocation,\n    ): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n      const parse = ({\n        pathname,\n        search,\n        hash,\n        state,\n      }: HistoryLocation): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n        const parsedSearch = options.parseSearch(search)\n\n        return {\n          pathname: pathname,\n          searchStr: search,\n          search: replaceEqualDeep(\n            previousLocation?.search,\n            parsedSearch,\n          ) as any,\n          hash: hash.split('#').reverse()[0] ?? '',\n          href: `${pathname}${search}${hash}`,\n          state: replaceEqualDeep(\n            previousLocation?.state,\n            state,\n          ) as HistoryState,\n        }\n      }\n\n      const location = parse(history.location)\n\n      let { __tempLocation, __tempKey } = location.state\n\n      if (\n        __tempLocation &&\n        (!__tempKey || __tempKey === tempLocationKeyRef.current)\n      ) {\n        // Sync up the location keys\n        const parsedTempLocation = parse(__tempLocation) as any\n        parsedTempLocation.state.key = location.state.key\n\n        delete parsedTempLocation.state.__tempLocation\n\n        return {\n          ...parsedTempLocation,\n          maskedLocation: location,\n        }\n      }\n\n      return location\n    },\n  )\n\n  const latestLocationRef = React.useRef<ParsedLocation>(parseLocation())\n  const [preState, setState] = React.useState<RouterState<TRouteTree>>(() =>\n    getInitialRouterState(latestLocationRef.current),\n  )\n  const [isTransitioning, startReactTransition] = React.useTransition()\n  const pendingMatchesRef = React.useRef<AnyRouteMatch[]>([])\n\n  const state = React.useMemo<RouterState<TRouteTree>>(\n    () => ({\n      ...preState,\n      status: isTransitioning ? 'pending' : 'idle',\n      location: isTransitioning ? latestLocationRef.current : preState.location,\n      pendingMatches: pendingMatchesRef.current,\n    }),\n    [preState, isTransitioning],\n  )\n\n  React.useLayoutEffect(() => {\n    if (!isTransitioning && state.resolvedLocation !== state.location) {\n      router.emit({\n        type: 'onResolved',\n        fromLocation: state.resolvedLocation,\n        toLocation: state.location,\n        pathChanged: state.location!.href !== state.resolvedLocation?.href,\n      })\n      pendingMatchesRef.current = []\n\n      setState((s) => ({\n        ...s,\n        resolvedLocation: s.location,\n      }))\n    }\n  })\n\n  const basepath = `/${trimPath(options.basepath ?? '') ?? ''}`\n\n  const resolvePathWithBase = useStableCallback(\n    (from: string, path: string) => {\n      return resolvePath(basepath!, from, cleanPath(path))\n    },\n  )\n\n  const [routesById, routesByPath] = React.useMemo(() => {\n    const routesById = {} as RoutesById<TRouteTree>\n    const routesByPath = {} as RoutesByPath<TRouteTree>\n\n    const recurseRoutes = (routes: AnyRoute[]) => {\n      routes.forEach((route, i) => {\n        route.init({ originalIndex: i })\n\n        const existingRoute = (routesById as any)[route.id]\n\n        invariant(\n          !existingRoute,\n          `Duplicate routes found with id: ${String(route.id)}`,\n        )\n        ;(routesById as any)[route.id] = route\n\n        if (!route.isRoot && route.path) {\n          const trimmedFullPath = trimPathRight(route.fullPath)\n          if (\n            !(routesByPath as any)[trimmedFullPath] ||\n            route.fullPath.endsWith('/')\n          ) {\n            ;(routesByPath as any)[trimmedFullPath] = route\n          }\n        }\n\n        const children = route.children as Route[]\n\n        if (children?.length) {\n          recurseRoutes(children)\n        }\n      })\n    }\n\n    recurseRoutes([router.routeTree])\n\n    return [routesById, routesByPath] as const\n  }, [])\n\n  const looseRoutesById = routesById as Record<string, AnyRoute>\n\n  const flatRoutes = React.useMemo(\n    () =>\n      (Object.values(routesByPath) as AnyRoute[])\n        .map((d, i) => {\n          const trimmed = trimPath(d.fullPath)\n          const parsed = parsePathname(trimmed)\n\n          while (parsed.length > 1 && parsed[0]?.value === '/') {\n            parsed.shift()\n          }\n\n          const score = parsed.map((d) => {\n            if (d.type === 'param') {\n              return 0.5\n            }\n\n            if (d.type === 'wildcard') {\n              return 0.25\n            }\n\n            return 1\n          })\n\n          return { child: d, trimmed, parsed, index: i, score }\n        })\n        .sort((a, b) => {\n          let isIndex = a.trimmed === '/' ? 1 : b.trimmed === '/' ? -1 : 0\n\n          if (isIndex !== 0) return isIndex\n\n          const length = Math.min(a.score.length, b.score.length)\n\n          // Sort by length of score\n          if (a.score.length !== b.score.length) {\n            return b.score.length - a.score.length\n          }\n\n          // Sort by min available score\n          for (let i = 0; i < length; i++) {\n            if (a.score[i] !== b.score[i]) {\n              return b.score[i]! - a.score[i]!\n            }\n          }\n\n          // Sort by min available parsed value\n          for (let i = 0; i < length; i++) {\n            if (a.parsed[i]!.value !== b.parsed[i]!.value) {\n              return a.parsed[i]!.value! > b.parsed[i]!.value! ? 1 : -1\n            }\n          }\n\n          // Sort by length of trimmed full path\n          if (a.trimmed !== b.trimmed) {\n            return a.trimmed > b.trimmed ? 1 : -1\n          }\n\n          // Sort by original index\n          return a.index - b.index\n        })\n        .map((d, i) => {\n          d.child.rank = i\n          return d.child\n        }),\n    [routesByPath],\n  )\n\n  const matchRoutes = useStableCallback(\n    <TRouteTree extends AnyRoute>(\n      pathname: string,\n      locationSearch: AnySearchSchema,\n      opts?: { throwOnError?: boolean; debug?: boolean },\n    ): RouteMatch<TRouteTree>[] => {\n      let routeParams: AnyPathParams = {}\n\n      let foundRoute = flatRoutes.find((route) => {\n        const matchedParams = matchPathname(basepath, trimPathRight(pathname), {\n          to: route.fullPath,\n          caseSensitive: route.options.caseSensitive ?? options.caseSensitive,\n          fuzzy: false,\n        })\n\n        if (matchedParams) {\n          routeParams = matchedParams\n          return true\n        }\n\n        return false\n      })\n\n      let routeCursor: AnyRoute = foundRoute || (routesById as any)['__root__']\n\n      let matchedRoutes: AnyRoute[] = [routeCursor]\n      // let includingLayouts = true\n      while (routeCursor?.parentRoute) {\n        routeCursor = routeCursor.parentRoute\n        if (routeCursor) matchedRoutes.unshift(routeCursor)\n      }\n\n      // Existing matches are matches that are already loaded along with\n      // pending matches that are still loading\n\n      const parseErrors = matchedRoutes.map((route) => {\n        let parsedParamsError\n\n        if (route.options.parseParams) {\n          try {\n            const parsedParams = route.options.parseParams(routeParams)\n            // Add the parsed params to the accumulated params bag\n            Object.assign(routeParams, parsedParams)\n          } catch (err: any) {\n            parsedParamsError = new PathParamError(err.message, {\n              cause: err,\n            })\n\n            if (opts?.throwOnError) {\n              throw parsedParamsError\n            }\n\n            return parsedParamsError\n          }\n        }\n\n        return\n      })\n\n      const matches = matchedRoutes.map((route, index) => {\n        const interpolatedPath = interpolatePath(route.path, routeParams)\n        const matchId = interpolatePath(route.id, routeParams, true)\n\n        // Waste not, want not. If we already have a match for this route,\n        // reuse it. This is important for layout routes, which might stick\n        // around between navigation actions that only change leaf routes.\n        const existingMatch = getRouteMatch(state, matchId)\n\n        if (existingMatch) {\n          return { ...existingMatch }\n        }\n\n        // Create a fresh route match\n        const hasLoaders = !!(\n          route.options.loader ||\n          componentTypes.some((d) => (route.options[d] as any)?.preload)\n        )\n\n        const routeMatch: AnyRouteMatch = {\n          id: matchId,\n          routeId: route.id,\n          params: routeParams,\n          pathname: joinPaths([basepath, interpolatedPath]),\n          updatedAt: Date.now(),\n          routeSearch: {},\n          search: {} as any,\n          status: hasLoaders ? 'pending' : 'success',\n          isFetching: false,\n          invalid: false,\n          error: undefined,\n          paramsError: parseErrors[index],\n          searchError: undefined,\n          loadPromise: Promise.resolve(),\n          context: undefined!,\n          abortController: new AbortController(),\n          shouldReloadDeps: undefined,\n          fetchedAt: 0,\n        }\n\n        return routeMatch\n      })\n\n      // Take each match and resolve its search params and context\n      // This has to happen after the matches are created or found\n      // so that we can use the parent match's search params and context\n      matches.forEach((match, i): any => {\n        const parentMatch = matches[i - 1]\n        const route = looseRoutesById[match.routeId]!\n\n        const searchInfo = (() => {\n          // Validate the search params and stabilize them\n          const parentSearchInfo = {\n            search: parentMatch?.search ?? locationSearch,\n            routeSearch: parentMatch?.routeSearch ?? locationSearch,\n          }\n\n          try {\n            const validator =\n              typeof route.options.validateSearch === 'object'\n                ? route.options.validateSearch.parse\n                : route.options.validateSearch\n\n            let routeSearch = validator?.(parentSearchInfo.search) ?? {}\n\n            let search = {\n              ...parentSearchInfo.search,\n              ...routeSearch,\n            }\n\n            routeSearch = replaceEqualDeep(match.routeSearch, routeSearch)\n            search = replaceEqualDeep(match.search, search)\n\n            return {\n              routeSearch,\n              search,\n              searchDidChange: match.routeSearch !== routeSearch,\n            }\n          } catch (err: any) {\n            match.searchError = new SearchParamError(err.message, {\n              cause: err,\n            })\n\n            if (opts?.throwOnError) {\n              throw match.searchError\n            }\n\n            return parentSearchInfo\n          }\n        })()\n\n        Object.assign(match, searchInfo)\n      })\n\n      return matches as any\n    },\n  )\n\n  const cancelMatch = useStableCallback(\n    <TRouteTree extends AnyRoute>(id: string) => {\n      getRouteMatch(state, id)?.abortController?.abort()\n    },\n  )\n\n  const cancelMatches = useStableCallback(\n    <TRouteTree extends AnyRoute>(state: RouterState<TRouteTree>) => {\n      state.matches.forEach((match) => {\n        cancelMatch(match.id)\n      })\n    },\n  )\n\n  const buildLocation = useStableCallback<BuildLocationFn<TRouteTree>>(\n    (opts) => {\n      const build = (\n        dest: BuildNextOptions & {\n          unmaskOnReload?: boolean\n        } = {},\n        matches?: AnyRouteMatch[],\n      ): ParsedLocation => {\n        const from = latestLocationRef.current\n        const fromPathname = dest.from ?? from.pathname\n\n        let pathname = resolvePathWithBase(fromPathname, `${dest.to ?? ''}`)\n\n        const fromMatches = matchRoutes(fromPathname, from.search)\n        const stayingMatches = matches?.filter((d) =>\n          fromMatches?.find((e) => e.routeId === d.routeId),\n        )\n\n        const prevParams = { ...last(fromMatches)?.params }\n\n        let nextParams =\n          (dest.params ?? true) === true\n            ? prevParams\n            : functionalUpdate(dest.params!, prevParams)\n\n        if (nextParams) {\n          matches\n            ?.map((d) => looseRoutesById[d.routeId]!.options.stringifyParams)\n            .filter(Boolean)\n            .forEach((fn) => {\n              nextParams = { ...nextParams!, ...fn!(nextParams!) }\n            })\n        }\n\n        pathname = interpolatePath(pathname, nextParams ?? {})\n\n        const preSearchFilters =\n          stayingMatches\n            ?.map(\n              (match) =>\n                looseRoutesById[match.routeId]!.options.preSearchFilters ?? [],\n            )\n            .flat()\n            .filter(Boolean) ?? []\n\n        const postSearchFilters =\n          stayingMatches\n            ?.map(\n              (match) =>\n                looseRoutesById[match.routeId]!.options.postSearchFilters ?? [],\n            )\n            .flat()\n            .filter(Boolean) ?? []\n\n        // Pre filters first\n        const preFilteredSearch = preSearchFilters?.length\n          ? preSearchFilters?.reduce(\n              (prev, next) => next(prev) as any,\n              from.search,\n            )\n          : from.search\n\n        // Then the link/navigate function\n        const destSearch =\n          dest.search === true\n            ? preFilteredSearch // Preserve resolvedFrom true\n            : dest.search\n            ? functionalUpdate(dest.search, preFilteredSearch) ?? {} // Updater\n            : preSearchFilters?.length\n            ? preFilteredSearch // Preserve resolvedFrom filters\n            : {}\n\n        // Then post filters\n        const postFilteredSearch = postSearchFilters?.length\n          ? postSearchFilters.reduce((prev, next) => next(prev), destSearch)\n          : destSearch\n\n        const search = replaceEqualDeep(from.search, postFilteredSearch)\n\n        const searchStr = options.stringifySearch(search)\n\n        const hash =\n          dest.hash === true\n            ? from.hash\n            : dest.hash\n            ? functionalUpdate(dest.hash!, from.hash)\n            : from.hash\n\n        const hashStr = hash ? `#${hash}` : ''\n\n        let nextState =\n          dest.state === true\n            ? from.state\n            : dest.state\n            ? functionalUpdate(dest.state, from.state)\n            : from.state\n\n        nextState = replaceEqualDeep(from.state, nextState)\n\n        return {\n          pathname,\n          search,\n          searchStr,\n          state: nextState as any,\n          hash,\n          href: history.createHref(`${pathname}${searchStr}${hashStr}`),\n          unmaskOnReload: dest.unmaskOnReload,\n        }\n      }\n\n      const buildWithMatches = (\n        dest: BuildNextOptions = {},\n        maskedDest?: BuildNextOptions,\n      ) => {\n        let next = build(dest)\n        let maskedNext = maskedDest ? build(maskedDest) : undefined\n\n        if (!maskedNext) {\n          let params = {}\n\n          let foundMask = options.routeMasks?.find((d) => {\n            const match = matchPathname(basepath, next.pathname, {\n              to: d.from,\n              caseSensitive: false,\n              fuzzy: false,\n            })\n\n            if (match) {\n              params = match\n              return true\n            }\n\n            return false\n          })\n\n          if (foundMask) {\n            foundMask = {\n              ...foundMask,\n              from: interpolatePath(foundMask.from, params) as any,\n            }\n            maskedDest = foundMask\n            maskedNext = build(maskedDest)\n          }\n        }\n\n        const nextMatches = matchRoutes(next.pathname, next.search)\n        const maskedMatches = maskedNext\n          ? matchRoutes(maskedNext.pathname, maskedNext.search)\n          : undefined\n        const maskedFinal = maskedNext\n          ? build(maskedDest, maskedMatches)\n          : undefined\n\n        const final = build(dest, nextMatches)\n\n        if (maskedFinal) {\n          final.maskedLocation = maskedFinal\n        }\n\n        return final\n      }\n\n      if (opts.mask) {\n        return buildWithMatches(opts, {\n          ...pick(opts, ['from']),\n          ...opts.mask,\n        })\n      }\n\n      return buildWithMatches(opts)\n    },\n  )\n\n  const commitLocation = useStableCallback(\n    async ({\n      startTransition,\n      ...next\n    }: ParsedLocation & CommitLocationOptions) => {\n      if (navigateTimeoutRef.current) clearTimeout(navigateTimeoutRef.current)\n\n      const isSameUrl = latestLocationRef.current.href === next.href\n\n      // If the next urls are the same and we're not replacing,\n      // do nothing\n      if (!isSameUrl || !next.replace) {\n        let { maskedLocation, ...nextHistory } = next\n\n        if (maskedLocation) {\n          nextHistory = {\n            ...maskedLocation,\n            state: {\n              ...maskedLocation.state,\n              __tempKey: undefined,\n              __tempLocation: {\n                ...nextHistory,\n                search: nextHistory.searchStr,\n                state: {\n                  ...nextHistory.state,\n                  __tempKey: undefined!,\n                  __tempLocation: undefined!,\n                  key: undefined!,\n                },\n              },\n            },\n          }\n\n          if (nextHistory.unmaskOnReload ?? options.unmaskOnReload ?? false) {\n            nextHistory.state.__tempKey = tempLocationKeyRef.current\n          }\n        }\n\n        const apply = () => {\n          history[next.replace ? 'replace' : 'push'](\n            nextHistory.href,\n            nextHistory.state,\n          )\n        }\n\n        if (startTransition ?? true) {\n          startReactTransition(apply)\n        } else {\n          apply()\n        }\n      }\n\n      resetNextScrollRef.current = next.resetScroll ?? true\n\n      return latestLoadPromiseRef.current\n    },\n  )\n\n  const buildAndCommitLocation = useStableCallback(\n    ({\n      replace,\n      resetScroll,\n      startTransition,\n      ...rest\n    }: BuildNextOptions & CommitLocationOptions = {}) => {\n      const location = buildLocation(rest)\n      return commitLocation({\n        ...location,\n        startTransition,\n        replace,\n        resetScroll,\n      })\n    },\n  )\n\n  const navigate = useStableCallback<NavigateFn<TRouteTree>>(\n    ({ from, to = '', ...rest }) => {\n      // If this link simply reloads the current route,\n      // make sure it has a new key so it will trigger a data refresh\n\n      // If this `to` is a valid external URL, return\n      // null for LinkUtils\n      const toString = String(to)\n      const fromString = typeof from === 'undefined' ? from : String(from)\n      let isExternal\n\n      try {\n        new URL(`${toString}`)\n        isExternal = true\n      } catch (e) {}\n\n      invariant(\n        !isExternal,\n        'Attempting to navigate to external url with this.navigate!',\n      )\n\n      return buildAndCommitLocation({\n        ...rest,\n        from: fromString,\n        to: toString,\n      })\n    },\n  )\n\n  const loadMatches = useStableCallback(\n    async ({\n      checkLatest,\n      matches,\n      preload,\n    }: {\n      checkLatest: () => Promise<void> | undefined\n      matches: AnyRouteMatch[]\n      preload?: boolean\n    }): Promise<RouteMatch[]> => {\n      let latestPromise\n      let firstBadMatchIndex: number | undefined\n\n      // Check each match middleware to see if the route can be accessed\n      try {\n        for (let [index, match] of matches.entries()) {\n          const parentMatch = matches[index - 1]\n          const route = looseRoutesById[match.routeId]!\n\n          const handleError = (err: any, code: string) => {\n            err.routerCode = code\n            firstBadMatchIndex = firstBadMatchIndex ?? index\n\n            if (isRedirect(err)) {\n              throw err\n            }\n\n            try {\n              route.options.onError?.(err)\n            } catch (errorHandlerErr) {\n              err = errorHandlerErr\n\n              if (isRedirect(errorHandlerErr)) {\n                throw errorHandlerErr\n              }\n            }\n\n            matches[index] = match = {\n              ...match,\n              error: err,\n              status: 'error',\n              updatedAt: Date.now(),\n            }\n          }\n\n          try {\n            if (match.paramsError) {\n              handleError(match.paramsError, 'PARSE_PARAMS')\n            }\n\n            if (match.searchError) {\n              handleError(match.searchError, 'VALIDATE_SEARCH')\n            }\n\n            const parentContext = parentMatch?.context ?? options.context ?? {}\n\n            const beforeLoadContext =\n              (await route.options.beforeLoad?.({\n                search: match.search,\n                abortController: match.abortController,\n                params: match.params,\n                preload: !!preload,\n                context: parentContext,\n                location: state.location,\n                navigate: (opts) =>\n                  navigate({ ...opts, from: match.pathname } as any),\n                buildLocation,\n              })) ?? ({} as any)\n\n            const context = {\n              ...parentContext,\n              ...beforeLoadContext,\n            }\n\n            matches[index] = match = {\n              ...match,\n              context: replaceEqualDeep(match.context, context),\n            }\n          } catch (err) {\n            handleError(err, 'BEFORE_LOAD')\n            break\n          }\n        }\n      } catch (err) {\n        if (isRedirect(err)) {\n          if (!preload) navigate(err as any)\n          return matches\n        }\n\n        throw err\n      }\n\n      const validResolvedMatches = matches.slice(0, firstBadMatchIndex)\n      const matchPromises: Promise<any>[] = []\n\n      validResolvedMatches.forEach((match, index) => {\n        matchPromises.push(\n          (async () => {\n            const parentMatchPromise = matchPromises[index - 1]\n            const route = looseRoutesById[match.routeId]!\n\n            const handleIfRedirect = (err: any) => {\n              if (isRedirect(err)) {\n                if (!preload) {\n                  navigate(err as any)\n                }\n                return true\n              }\n              return false\n            }\n\n            let loadPromise: Promise<void> | undefined\n\n            matches[index] = match = {\n              ...match,\n              fetchedAt: Date.now(),\n              invalid: false,\n            }\n\n            if (match.isFetching) {\n              loadPromise = getRouteMatch(state, match.id)?.loadPromise\n            } else {\n              const cause = state.matches.find((d) => d.id === match.id)\n                ? 'stay'\n                : 'enter'\n\n              const loaderContext: LoaderFnContext = {\n                params: match.params,\n                search: match.search,\n                preload: !!preload,\n                parentMatchPromise,\n                abortController: match.abortController,\n                context: match.context,\n                location: state.location,\n                navigate: (opts) =>\n                  navigate({ ...opts, from: match.pathname } as any),\n                cause,\n              }\n\n              // Default to reloading the route all the time\n              let shouldReload = true\n              let shouldReloadDeps =\n                typeof route.options.shouldReload === 'function'\n                  ? route.options.shouldReload?.(loaderContext)\n                  : !!route.options.shouldReload\n\n              if (typeof shouldReloadDeps === 'object') {\n                // compare the deps to see if they've changed\n                shouldReload = !deepEqual(\n                  shouldReloadDeps,\n                  match.shouldReloadDeps,\n                )\n\n                match.shouldReloadDeps = shouldReloadDeps\n              } else {\n                shouldReload = !!shouldReloadDeps\n              }\n\n              // If the user doesn't want the route to reload, just\n              // resolve with the existing loader data\n\n              if (!shouldReload) {\n                loadPromise = Promise.resolve(match.loaderData)\n              } else {\n                // Otherwise, load the route\n                matches[index] = match = {\n                  ...match,\n                  isFetching: true,\n                }\n\n                const componentsPromise = Promise.all(\n                  componentTypes.map(async (type) => {\n                    const component = route.options[type]\n\n                    if ((component as any)?.preload) {\n                      await (component as any).preload()\n                    }\n                  }),\n                )\n\n                const loaderPromise = route.options.loader?.(loaderContext)\n\n                loadPromise = Promise.all([\n                  componentsPromise,\n                  loaderPromise,\n                ]).then((d) => d[1])\n              }\n            }\n\n            matches[index] = match = {\n              ...match,\n              loadPromise,\n            }\n\n            if (!preload) {\n              setState((s) => ({\n                ...s,\n                matches: s.matches.map((d) => (d.id === match.id ? match : d)),\n              }))\n            }\n\n            try {\n              const loaderData = await loadPromise\n              if ((latestPromise = checkLatest())) return await latestPromise\n\n              matches[index] = match = {\n                ...match,\n                error: undefined,\n                status: 'success',\n                isFetching: false,\n                updatedAt: Date.now(),\n                loaderData,\n                loadPromise: undefined,\n              }\n            } catch (error) {\n              if ((latestPromise = checkLatest())) return await latestPromise\n              if (handleIfRedirect(error)) return\n\n              try {\n                route.options.onError?.(error)\n              } catch (onErrorError) {\n                error = onErrorError\n                if (handleIfRedirect(onErrorError)) return\n              }\n\n              matches[index] = match = {\n                ...match,\n                error,\n                status: 'error',\n                isFetching: false,\n                updatedAt: Date.now(),\n              }\n            }\n\n            if (!preload) {\n              setState((s) => ({\n                ...s,\n                matches: s.matches.map((d) => (d.id === match.id ? match : d)),\n              }))\n            }\n          })(),\n        )\n      })\n\n      await Promise.all(matchPromises)\n      return matches\n    },\n  )\n\n  const load = useStableCallback<LoadFn>(async () => {\n    const promise = new Promise<void>(async (resolve, reject) => {\n      const next = latestLocationRef.current\n      const prevLocation = state.resolvedLocation\n      const pathDidChange = prevLocation!.href !== next.href\n      let latestPromise: Promise<void> | undefined | null\n\n      // Cancel any pending matches\n      cancelMatches(state)\n\n      router.emit({\n        type: 'onBeforeLoad',\n        fromLocation: prevLocation,\n        toLocation: next,\n        pathChanged: pathDidChange,\n      })\n\n      // Match the routes\n      let matches: RouteMatch<any, any>[] = matchRoutes(\n        next.pathname,\n        next.search,\n        {\n          debug: true,\n        },\n      )\n\n      pendingMatchesRef.current = matches\n\n      const previousMatches = state.matches\n\n      // Ingest the new matches\n      setState((s) => ({\n        ...s,\n        status: 'pending',\n        location: next,\n        matches,\n      }))\n\n      try {\n        try {\n          // Load the matches\n          await loadMatches({\n            matches,\n            checkLatest: () => checkLatest(promise),\n          })\n        } catch (err) {\n          // swallow this error, since we'll display the\n          // errors on the route components\n        }\n\n        // Only apply the latest transition\n        if ((latestPromise = checkLatest(promise))) {\n          return latestPromise\n        }\n\n        const exitingMatchIds = previousMatches.filter(\n          (id) => !pendingMatchesRef.current.includes(id),\n        )\n        const enteringMatchIds = pendingMatchesRef.current.filter(\n          (id) => !previousMatches.includes(id),\n        )\n        const stayingMatchIds = previousMatches.filter((id) =>\n          pendingMatchesRef.current.includes(id),\n        )\n\n        // setState((s) => ({\n        //   ...s,\n        //   status: 'idle',\n        //   resolvedLocation: s.location,\n        // }))\n\n        //\n        ;(\n          [\n            [exitingMatchIds, 'onLeave'],\n            [enteringMatchIds, 'onEnter'],\n            [stayingMatchIds, 'onTransition'],\n          ] as const\n        ).forEach(([matches, hook]) => {\n          matches.forEach((match) => {\n            looseRoutesById[match.routeId]!.options[hook]?.(match)\n          })\n        })\n\n        router.emit({\n          type: 'onLoad',\n          fromLocation: prevLocation,\n          toLocation: next,\n          pathChanged: pathDidChange,\n        })\n\n        resolve()\n      } catch (err) {\n        // Only apply the latest transition\n        if ((latestPromise = checkLatest(promise))) {\n          return latestPromise\n        }\n\n        reject(err)\n      }\n    })\n\n    latestLoadPromiseRef.current = promise\n\n    return latestLoadPromiseRef.current\n  })\n\n  const preloadRoute = useStableCallback(\n    async (navigateOpts: BuildNextOptions = state.location) => {\n      let next = buildLocation(navigateOpts)\n\n      let matches = matchRoutes(next.pathname, next.search, {\n        throwOnError: true,\n      })\n\n      await loadMatches({\n        matches,\n        preload: true,\n        checkLatest: () => undefined,\n      })\n\n      return [last(matches)!, matches] as const\n    },\n  )\n\n  const buildLink = useStableCallback<BuildLinkFn<TRouteTree>>((dest) => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n\n    const {\n      to,\n      preload: userPreload,\n      preloadDelay: userPreloadDelay,\n      activeOptions,\n      disabled,\n      target,\n      replace,\n      resetScroll,\n      startTransition,\n    } = dest\n\n    try {\n      new URL(`${to}`)\n      return {\n        type: 'external',\n        href: to as any,\n      }\n    } catch (e) {}\n\n    const nextOpts = dest\n    const next = buildLocation(nextOpts as any)\n\n    const preload = userPreload ?? options.defaultPreload\n    const preloadDelay = userPreloadDelay ?? options.defaultPreloadDelay ?? 0\n\n    // Compare path/hash for matches\n    const currentPathSplit = latestLocationRef.current.pathname.split('/')\n    const nextPathSplit = next.pathname.split('/')\n    const pathIsFuzzyEqual = nextPathSplit.every(\n      (d, i) => d === currentPathSplit[i],\n    )\n    // Combine the matches based on user options\n    const pathTest = activeOptions?.exact\n      ? latestLocationRef.current.pathname === next.pathname\n      : pathIsFuzzyEqual\n    const hashTest = activeOptions?.includeHash\n      ? latestLocationRef.current.hash === next.hash\n      : true\n    const searchTest =\n      activeOptions?.includeSearch ?? true\n        ? deepEqual(latestLocationRef.current.search, next.search, true)\n        : true\n\n    // The final \"active\" test\n    const isActive = pathTest && hashTest && searchTest\n\n    // The click handler\n    const handleClick = (e: MouseEvent) => {\n      if (\n        !disabled &&\n        !isCtrlEvent(e) &&\n        !e.defaultPrevented &&\n        (!target || target === '_self') &&\n        e.button === 0\n      ) {\n        e.preventDefault()\n\n        // All is well? Navigate!\n        commitLocation({ ...next, replace, resetScroll, startTransition })\n      }\n    }\n\n    // The click handler\n    const handleFocus = (e: MouseEvent) => {\n      if (preload) {\n        preloadRoute(nextOpts as any).catch((err) => {\n          console.warn(err)\n          console.warn(preloadWarning)\n        })\n      }\n    }\n\n    const handleTouchStart = (e: TouchEvent) => {\n      preloadRoute(nextOpts as any).catch((err) => {\n        console.warn(err)\n        console.warn(preloadWarning)\n      })\n    }\n\n    const handleEnter = (e: MouseEvent) => {\n      const target = (e.target || {}) as LinkCurrentTargetElement\n\n      if (preload) {\n        if (target.preloadTimeout) {\n          return\n        }\n\n        target.preloadTimeout = setTimeout(() => {\n          target.preloadTimeout = null\n          preloadRoute(nextOpts as any).catch((err) => {\n            console.warn(err)\n            console.warn(preloadWarning)\n          })\n        }, preloadDelay)\n      }\n    }\n\n    const handleLeave = (e: MouseEvent) => {\n      const target = (e.target || {}) as LinkCurrentTargetElement\n\n      if (target.preloadTimeout) {\n        clearTimeout(target.preloadTimeout)\n        target.preloadTimeout = null\n      }\n    }\n\n    return {\n      type: 'internal',\n      next,\n      handleFocus,\n      handleClick,\n      handleEnter,\n      handleLeave,\n      handleTouchStart,\n      isActive,\n      disabled,\n    }\n  })\n\n  React.useLayoutEffect(() => {\n    const unsub = history.subscribe(() => {\n      latestLocationRef.current = parseLocation(latestLocationRef.current)\n\n      if (state.location !== latestLocationRef.current) {\n        startReactTransition(() => {\n          try {\n            load()\n          } catch (err) {\n            console.error(err)\n          }\n        })\n      }\n    })\n\n    const nextLocation = buildLocation({\n      search: true,\n      params: true,\n      hash: true,\n      state: true,\n    })\n\n    if (state.location.href !== nextLocation.href) {\n      commitLocation({ ...nextLocation, replace: true })\n    }\n\n    return () => {\n      unsub()\n    }\n  }, [history])\n\n  React.useLayoutEffect(() => {\n    startReactTransition(() => {\n      try {\n        load()\n      } catch (err) {\n        console.error(err)\n      }\n    })\n  }, [])\n\n  const matchRoute = useStableCallback<MatchRouteFn<TRouteTree>>(\n    (location, opts) => {\n      location = {\n        ...location,\n        to: location.to\n          ? resolvePathWithBase((location.from || '') as string, location.to)\n          : undefined,\n      } as any\n\n      const next = buildLocation(location as any)\n\n      if (opts?.pending && state.status !== 'pending') {\n        return false\n      }\n\n      const baseLocation = opts?.pending\n        ? latestLocationRef.current\n        : state.resolvedLocation\n\n      // const baseLocation = state.resolvedLocation\n\n      if (!baseLocation) {\n        return false\n      }\n\n      const match = matchPathname(basepath, baseLocation.pathname, {\n        ...opts,\n        to: next.pathname,\n      }) as any\n\n      if (!match) {\n        return false\n      }\n\n      if (match && (opts?.includeSearch ?? true)) {\n        return deepEqual(baseLocation.search, next.search, true) ? match : false\n      }\n\n      return match\n    },\n  )\n\n  const routerContextValue: RouterContext<TRouteTree> = {\n    routeTree: router.routeTree,\n    navigate,\n    buildLink,\n    state,\n    matchRoute,\n    routesById,\n    options,\n    history,\n    load,\n    buildLocation,\n    subscribe: router.subscribe,\n    resetNextScrollRef,\n  }\n\n  return (\n    <routerContext.Provider value={routerContextValue}>\n      <Matches />\n    </routerContext.Provider>\n  )\n}\n\nexport function getRouteMatch<TRouteTree extends AnyRoute>(\n  state: RouterState<TRouteTree>,\n  id: string,\n): undefined | RouteMatch<TRouteTree> {\n  return [...state.pendingMatches, ...state.matches].find((d) => d.id === id)\n}\n\nexport function useRouterState<\n  TSelected = RouterState<RegisteredRouter['routeTree']>,\n>(opts?: {\n  select: (state: RouterState<RegisteredRouter['routeTree']>) => TSelected\n}): TSelected {\n  const { state } = useRouter()\n  // return useStore(router.__store, opts?.select as any)\n  return opts?.select ? opts.select(state) : (state as any)\n}\n\nexport type RouterProps<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> = Omit<RouterOptions<TRouteTree, TDehydrated>, 'context'> & {\n  router: Router<TRouteTree>\n  context?: Partial<RouterOptions<TRouteTree, TDehydrated>['context']>\n}\n\nexport function useRouter<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n>(): RouterContext<TRouteTree> {\n  const resolvedContext = window.__TSR_ROUTER_CONTEXT__ || routerContext\n  const value = React.useContext(resolvedContext)\n  warning(value, 'useRouter must be used inside a <RouterProvider> component!')\n  return value as any\n}\nexport interface RouteMatch<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id'],\n> {\n  id: string\n  routeId: TRouteId\n  pathname: string\n  params: RouteById<TRouteTree, TRouteId>['types']['allParams']\n  status: 'pending' | 'success' | 'error'\n  isFetching: boolean\n  invalid: boolean\n  error: unknown\n  paramsError: unknown\n  searchError: unknown\n  updatedAt: number\n  loadPromise?: Promise<void>\n  loaderData?: RouteById<TRouteTree, TRouteId>['types']['loaderData']\n  __resolveLoadPromise?: () => void\n  context: RouteById<TRouteTree, TRouteId>['types']['allContext']\n  routeSearch: RouteById<TRouteTree, TRouteId>['types']['searchSchema']\n  search: FullSearchSchema<TRouteTree> &\n    RouteById<TRouteTree, TRouteId>['types']['fullSearchSchema']\n  fetchedAt: number\n  shouldReloadDeps: any\n  abortController: AbortController\n}\n\nexport type AnyRouteMatch = RouteMatch<any>\n"],"names":["routerContext","React","createContext","document","window","__TSR_ROUTER_CONTEXT__","preloadWarning","isCtrlEvent","e","metaKey","altKey","ctrlKey","shiftKey","SearchParamError","Error","PathParamError","getInitialRouterState","location","status","resolvedLocation","matches","pendingMatches","lastUpdated","Date","now","RouterProvider","router","rest","options","context","history","useState","createBrowserHistory","tempLocationKeyRef","useRef","Math","round","random","resetNextScrollRef","navigateTimeoutRef","latestLoadPromiseRef","Promise","resolve","checkLatest","promise","current","undefined","parseLocation","useStableCallback","previousLocation","parse","pathname","search","hash","state","parsedSearch","parseSearch","searchStr","replaceEqualDeep","split","reverse","href","__tempLocation","__tempKey","parsedTempLocation","key","maskedLocation","latestLocationRef","preState","setState","isTransitioning","startReactTransition","useTransition","pendingMatchesRef","useMemo","useLayoutEffect","emit","type","fromLocation","toLocation","pathChanged","s","basepath","trimPath","resolvePathWithBase","from","path","resolvePath","cleanPath","routesById","routesByPath","recurseRoutes","routes","forEach","route","i","init","originalIndex","existingRoute","id","invariant","String","isRoot","trimmedFullPath","trimPathRight","fullPath","endsWith","children","length","routeTree","looseRoutesById","flatRoutes","Object","values","map","d","trimmed","parsed","parsePathname","value","shift","score","child","index","sort","a","b","isIndex","min","rank","matchRoutes","locationSearch","opts","routeParams","foundRoute","find","matchedParams","matchPathname","to","caseSensitive","fuzzy","routeCursor","matchedRoutes","parentRoute","unshift","parseErrors","parsedParamsError","parseParams","parsedParams","assign","err","message","cause","throwOnError","interpolatedPath","interpolatePath","matchId","existingMatch","getRouteMatch","hasLoaders","loader","componentTypes","some","preload","routeMatch","routeId","params","joinPaths","updatedAt","routeSearch","isFetching","invalid","error","paramsError","searchError","loadPromise","abortController","AbortController","shouldReloadDeps","fetchedAt","match","parentMatch","searchInfo","parentSearchInfo","validator","validateSearch","searchDidChange","cancelMatch","abort","cancelMatches","buildLocation","build","dest","fromPathname","fromMatches","stayingMatches","filter","prevParams","last","nextParams","functionalUpdate","stringifyParams","Boolean","fn","preSearchFilters","flat","postSearchFilters","preFilteredSearch","reduce","prev","next","destSearch","postFilteredSearch","stringifySearch","hashStr","nextState","createHref","unmaskOnReload","buildWithMatches","maskedDest","maskedNext","foundMask","routeMasks","nextMatches","maskedMatches","maskedFinal","final","mask","pick","commitLocation","startTransition","clearTimeout","isSameUrl","replace","nextHistory","apply","resetScroll","buildAndCommitLocation","navigate","toString","fromString","isExternal","URL","loadMatches","latestPromise","firstBadMatchIndex","entries","handleError","code","routerCode","isRedirect","onError","errorHandlerErr","parentContext","beforeLoadContext","beforeLoad","validResolvedMatches","slice","matchPromises","push","parentMatchPromise","handleIfRedirect","loaderContext","shouldReload","deepEqual","loaderData","componentsPromise","all","component","loaderPromise","then","onErrorError","load","reject","prevLocation","pathDidChange","debug","previousMatches","exitingMatchIds","includes","enteringMatchIds","stayingMatchIds","hook","preloadRoute","navigateOpts","buildLink","userPreload","preloadDelay","userPreloadDelay","activeOptions","disabled","target","nextOpts","defaultPreload","defaultPreloadDelay","currentPathSplit","nextPathSplit","pathIsFuzzyEqual","every","pathTest","exact","hashTest","includeHash","searchTest","includeSearch","isActive","handleClick","defaultPrevented","button","preventDefault","handleFocus","catch","console","warn","handleTouchStart","handleEnter","preloadTimeout","setTimeout","handleLeave","unsub","subscribe","nextLocation","matchRoute","pending","baseLocation","routerContextValue","createElement","Provider","Matches","useRouterState","useRouter","select","resolvedContext","useContext","warning"],"mappings":"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"}