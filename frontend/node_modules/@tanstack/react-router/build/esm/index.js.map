{"version":3,"file":"index.js","sources":["../../src/CatchBoundary.tsx","../../src/utils.ts","../../src/Matches.tsx","../../src/RouterProvider.tsx","../../src/defer.ts","../../src/awaited.tsx","../../src/path.ts","../../src/useParams.tsx","../../src/useSearch.tsx","../../src/route.ts","../../src/fileRoute.ts","../../src/lazyRouteComponent.tsx","../../src/link.tsx","../../src/qss.ts","../../src/redirects.ts","../../src/searchParams.ts","../../src/router.ts","../../src/scroll-restoration.tsx","../../src/useBlocker.tsx","../../src/useNavigate.tsx"],"sourcesContent":["import * as React from 'react'\n\nexport function CatchBoundary(props: {\n  getResetKey: () => string\n  children: any\n  errorComponent?: any\n  onCatch: (error: any) => void\n}) {\n  const errorComponent = props.errorComponent ?? ErrorComponent\n\n  return (\n    <CatchBoundaryImpl\n      getResetKey={props.getResetKey}\n      onCatch={props.onCatch}\n      children={({ error }) => {\n        if (error) {\n          return React.createElement(errorComponent, {\n            error,\n          })\n        }\n\n        return props.children\n      }}\n    />\n  )\n}\n\nexport class CatchBoundaryImpl extends React.Component<{\n  getResetKey: () => string\n  children: (props: { error: any; reset: () => void }) => any\n  onCatch?: (error: any) => void\n}> {\n  state = { error: null } as any\n  static getDerivedStateFromProps(props: any) {\n    return { resetKey: props.getResetKey() }\n  }\n  static getDerivedStateFromError(error: any) {\n    return { error }\n  }\n  componentDidUpdate(\n    prevProps: Readonly<{\n      getResetKey: () => string\n      children: (props: { error: any; reset: () => void }) => any\n      onCatch?: ((error: any, info: any) => void) | undefined\n    }>,\n    prevState: any,\n  ): void {\n    if (prevState.error && prevState.resetKey !== this.state.resetKey) {\n      this.setState({ error: null })\n    }\n  }\n  componentDidCatch(error: any) {\n    console.error(error)\n    this.props.onCatch?.(error)\n  }\n  render() {\n    return this.props.children(this.state)\n  }\n}\n\nexport function ErrorComponent({ error }: { error: any }) {\n  const [show, setShow] = React.useState(process.env.NODE_ENV !== 'production')\n\n  return (\n    <div style={{ padding: '.5rem', maxWidth: '100%' }}>\n      <div style={{ display: 'flex', alignItems: 'center', gap: '.5rem' }}>\n        <strong style={{ fontSize: '1rem' }}>Something went wrong!</strong>\n        <button\n          style={{\n            appearance: 'none',\n            fontSize: '.6em',\n            border: '1px solid currentColor',\n            padding: '.1rem .2rem',\n            fontWeight: 'bold',\n            borderRadius: '.25rem',\n          }}\n          onClick={() => setShow((d) => !d)}\n        >\n          {show ? 'Hide Error' : 'Show Error'}\n        </button>\n      </div>\n      <div style={{ height: '.25rem' }} />\n      {show ? (\n        <div>\n          <pre\n            style={{\n              fontSize: '.7em',\n              border: '1px solid red',\n              borderRadius: '.25rem',\n              padding: '.3rem',\n              color: 'red',\n              overflow: 'auto',\n            }}\n          >\n            {error.message ? <code>{error.message}</code> : null}\n          </pre>\n        </div>\n      ) : null}\n    </div>\n  )\n}\n","import * as React from 'react'\nimport { useMatch } from './Matches'\nimport { RouteMatch } from './Matches'\nimport { AnyRoute } from './route'\nimport { ParseRoute, RouteIds, RoutesById, RouteById } from './routeInfo'\nimport { RegisteredRouter } from './router'\n\nexport type NoInfer<T> = [T][T extends any ? 0 : never]\nexport type IsAny<T, Y, N = T> = 1 extends 0 & T ? Y : N\nexport type IsAnyBoolean<T> = 1 extends 0 & T ? true : false\nexport type IsKnown<T, Y, N> = unknown extends T ? N : Y\nexport type PickAsRequired<T, K extends keyof T> = Omit<T, K> &\n  Required<Pick<T, K>>\nexport type PickAsPartial<T, K extends keyof T> = Omit<T, K> &\n  Partial<Pick<T, K>>\nexport type PickUnsafe<T, K> = K extends keyof T ? Pick<T, K> : never\nexport type PickExtra<T, K> = {\n  [TKey in keyof K as string extends TKey\n    ? never\n    : TKey extends keyof T\n    ? never\n    : TKey]: K[TKey]\n}\n\nexport type PickRequired<T> = {\n  [K in keyof T as undefined extends T[K] ? never : K]: T[K]\n}\n\n// export type Expand<T> = T\nexport type Expand<T> = T extends object\n  ? T extends infer O\n    ? { [K in keyof O]: O[K] }\n    : never\n  : T\n\nexport type UnionToIntersection<U> = (\n  U extends any ? (k: U) => void : never\n) extends (k: infer I) => any\n  ? I\n  : never\n\n// type Compute<T> = { [K in keyof T]: T[K] } | never\n\n// type AllKeys<T> = T extends any ? keyof T : never\n\n// export type MergeUnion<T, Keys extends keyof T = keyof T> = Compute<\n//   {\n//     [K in Keys]: T[Keys]\n//   } & {\n//     [K in AllKeys<T>]?: T extends any\n//       ? K extends keyof T\n//         ? T[K]\n//         : never\n//       : never\n//   }\n// >\n\nexport type Assign<Left, Right> = Omit<Left, keyof Right> & Right\n\nexport type AssignAll<T extends any[]> = T extends [infer Left, ...infer Right]\n  ? Right extends any[]\n    ? Assign<Left, AssignAll<Right>>\n    : Left\n  : {}\n\n// // Sample types to merge\n// type TypeA = {\n//   shared: string\n//   onlyInA: string\n//   nested: {\n//     shared: string\n//     aProp: string\n//   }\n//   array: string[]\n// }\n\n// type TypeB = {\n//   shared: number\n//   onlyInB: number\n//   nested: {\n//     shared: number\n//     bProp: number\n//   }\n//   array: number[]\n// }\n\n// type TypeC = {\n//   shared: boolean\n//   onlyInC: boolean\n//   nested: {\n//     shared: boolean\n//     cProp: boolean\n//   }\n//   array: boolean[]\n// }\n\n// type Test = Expand<Assign<TypeA, TypeB>>\n\n// // Using DeepMerge to merge TypeA and TypeB\n// type MergedType = Expand<AssignAll<[TypeA, TypeB, TypeC]>>\n\nexport type Values<O> = O[ValueKeys<O>]\nexport type ValueKeys<O> = Extract<keyof O, PropertyKey>\n\nexport type DeepAwaited<T> = T extends Promise<infer A>\n  ? DeepAwaited<A>\n  : T extends Record<infer A, Promise<infer B>>\n  ? { [K in A]: DeepAwaited<B> }\n  : T\n\nexport type PathParamMask<TRoutePath extends string> =\n  TRoutePath extends `${infer L}/$${infer C}/${infer R}`\n    ? PathParamMask<`${L}/${string}/${R}`>\n    : TRoutePath extends `${infer L}/$${infer C}`\n    ? PathParamMask<`${L}/${string}`>\n    : TRoutePath\n\nexport type Timeout = ReturnType<typeof setTimeout>\n\nexport type Updater<TPrevious, TResult = TPrevious> =\n  | TResult\n  | ((prev?: TPrevious) => TResult)\n\nexport type NonNullableUpdater<TPrevious, TResult = TPrevious> =\n  | TResult\n  | ((prev: TPrevious) => TResult)\n\nexport type PickExtract<T, U> = {\n  [K in keyof T as T[K] extends U ? K : never]: T[K]\n}\n\nexport type PickExclude<T, U> = {\n  [K in keyof T as T[K] extends U ? never : K]: T[K]\n}\n\n// from https://github.com/type-challenges/type-challenges/issues/737\ntype LastInUnion<U> = UnionToIntersection<\n  U extends unknown ? (x: U) => 0 : never\n> extends (x: infer L) => 0\n  ? L\n  : never\nexport type UnionToTuple<U, Last = LastInUnion<U>> = [U] extends [never]\n  ? []\n  : [...UnionToTuple<Exclude<U, Last>>, Last]\n\n//\n\nexport const isServer = typeof document === 'undefined'\n\nexport function last<T>(arr: T[]) {\n  return arr[arr.length - 1]\n}\n\nfunction isFunction(d: any): d is Function {\n  return typeof d === 'function'\n}\n\nexport function functionalUpdate<TResult>(\n  updater: Updater<TResult> | NonNullableUpdater<TResult>,\n  previous: TResult,\n): TResult {\n  if (isFunction(updater)) {\n    return updater(previous as TResult)\n  }\n\n  return updater\n}\n\nexport function pick<T, K extends keyof T>(parent: T, keys: K[]): Pick<T, K> {\n  return keys.reduce((obj: any, key: K) => {\n    obj[key] = parent[key]\n    return obj\n  }, {} as any)\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between immutable JSON values for example.\n * Do not use this with signals\n */\nexport function replaceEqualDeep<T>(prev: any, _next: T): T {\n  if (prev === _next) {\n    return prev\n  }\n\n  const next = _next as any\n\n  const array = Array.isArray(prev) && Array.isArray(next)\n\n  if (array || (isPlainObject(prev) && isPlainObject(next))) {\n    const prevSize = array ? prev.length : Object.keys(prev).length\n    const nextItems = array ? next : Object.keys(next)\n    const nextSize = nextItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < nextSize; i++) {\n      const key = array ? i : nextItems[i]\n      copy[key] = replaceEqualDeep(prev[key], next[key])\n      if (copy[key] === prev[key]) {\n        equalItems++\n      }\n    }\n\n    return prevSize === nextSize && equalItems === prevSize ? prev : copy\n  }\n\n  return next\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any) {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any) {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function deepEqual(a: any, b: any, partial: boolean = false): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (isPlainObject(a) && isPlainObject(b)) {\n    const aKeys = Object.keys(a)\n    const bKeys = Object.keys(b)\n\n    if (!partial && aKeys.length !== bKeys.length) {\n      return false\n    }\n\n    return !bKeys.some(\n      (key) => !(key in a) || !deepEqual(a[key], b[key], partial),\n    )\n  }\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return !a.some((item, index) => !deepEqual(item, b[index], partial))\n  }\n\n  return false\n}\n\nexport function useStableCallback<T extends (...args: any[]) => any>(fn: T): T {\n  const fnRef = React.useRef(fn)\n  fnRef.current = fn\n\n  const ref = React.useRef((...args: any[]) => fnRef.current(...args))\n  return ref.current as T\n}\n\nexport function shallow<T>(objA: T, objB: T) {\n  if (Object.is(objA, objB)) {\n    return true\n  }\n\n  if (\n    typeof objA !== 'object' ||\n    objA === null ||\n    typeof objB !== 'object' ||\n    objB === null\n  ) {\n    return false\n  }\n\n  const keysA = Object.keys(objA)\n  if (keysA.length !== Object.keys(objB).length) {\n    return false\n  }\n\n  for (let i = 0; i < keysA.length; i++) {\n    if (\n      !Object.prototype.hasOwnProperty.call(objB, keysA[i] as string) ||\n      !Object.is(objA[keysA[i] as keyof T], objB[keysA[i] as keyof T])\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\nexport type StrictOrFrom<TFrom> =\n  | {\n      from: TFrom\n      strict?: true\n    }\n  | {\n      from?: never\n      strict: false\n    }\n\nexport type RouteFromIdOrRoute<\n  T,\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n> = T extends ParseRoute<TRouteTree>\n  ? T\n  : T extends RouteIds<TRouteTree>\n  ? RoutesById<TRouteTree>[T]\n  : T extends string\n  ? RouteIds<TRouteTree>\n  : never\n\nexport function useRouteContext<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TStrict extends boolean = true,\n  TRouteContext = RouteById<TRouteTree, TFrom>['types']['allContext'],\n  TSelected = TRouteContext,\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (search: TRouteContext) => TSelected\n  },\n): TStrict extends true ? TSelected : TSelected | undefined {\n  return useMatch({\n    ...(opts as any),\n    select: (match: RouteMatch) =>\n      opts?.select\n        ? opts.select(match.context as TRouteContext)\n        : match.context,\n  })\n}\n\nexport const useLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\nexport function escapeJSON(jsonString: string) {\n  return jsonString\n    .replace(/\\\\/g, '\\\\\\\\') // Escape backslashes\n    .replace(/'/g, \"\\\\'\") // Escape single quotes\n    .replace(/\"/g, '\\\\\"') // Escape double quotes\n}\n","import * as React from 'react'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { CatchBoundary, ErrorComponent } from './CatchBoundary'\nimport { useRouter, useRouterState } from './RouterProvider'\nimport { ResolveRelativePath, ToOptions } from './link'\nimport { AnyRoute, ReactNode, rootRouteId } from './route'\nimport {\n  FullSearchSchema,\n  ParseRoute,\n  RouteById,\n  RouteByPath,\n  RouteIds,\n  RoutePaths,\n} from './routeInfo'\nimport { RegisteredRouter, RouterState } from './router'\nimport { NoInfer, StrictOrFrom, pick } from './utils'\n\nexport const matchContext = React.createContext<string | undefined>(undefined)\n\nexport interface RouteMatch<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id'],\n> {\n  id: string\n  routeId: TRouteId\n  pathname: string\n  params: RouteById<TRouteTree, TRouteId>['types']['allParams']\n  status: 'pending' | 'success' | 'error'\n  isFetching: boolean\n  showPending: boolean\n  error: unknown\n  paramsError: unknown\n  searchError: unknown\n  updatedAt: number\n  loadPromise?: Promise<void>\n  loaderData?: RouteById<TRouteTree, TRouteId>['types']['loaderData']\n  routeContext: RouteById<TRouteTree, TRouteId>['types']['routeContext']\n  context: RouteById<TRouteTree, TRouteId>['types']['allContext']\n  search: FullSearchSchema<TRouteTree> &\n    RouteById<TRouteTree, TRouteId>['types']['fullSearchSchema']\n  fetchCount: number\n  abortController: AbortController\n  cause: 'preload' | 'enter' | 'stay'\n  loaderDeps: RouteById<TRouteTree, TRouteId>['types']['loaderDeps']\n  preload: boolean\n  invalid: boolean\n}\n\nexport type AnyRouteMatch = RouteMatch<any, any>\n\nexport function Matches() {\n  const router = useRouter()\n  const matchId = useRouterState({\n    select: (s) => {\n      return getRenderedMatches(s)[0]?.id\n    },\n  })\n\n  return (\n    <matchContext.Provider value={matchId}>\n      <CatchBoundary\n        getResetKey={() => router.state.resolvedLocation.state?.key}\n        errorComponent={ErrorComponent}\n        onCatch={() => {\n          warning(\n            false,\n            `Error in router! Consider setting an 'errorComponent' in your RootRoute! ðŸ‘`,\n          )\n        }}\n      >\n        {matchId ? <Match matchId={matchId} /> : null}\n      </CatchBoundary>\n    </matchContext.Provider>\n  )\n}\n\nfunction SafeFragment(props: any) {\n  return <>{props.children}</>\n}\n\nexport function Match({ matchId }: { matchId: string }) {\n  const router = useRouter()\n  const routeId = useRouterState({\n    select: (s) =>\n      getRenderedMatches(s).find((d) => d.id === matchId)?.routeId as string,\n  })\n\n  invariant(\n    routeId,\n    `Could not find routeId for matchId \"${matchId}\". Please file an issue!`,\n  )\n\n  const route = router.routesById[routeId]!\n\n  const PendingComponent = (route.options.pendingComponent ??\n    router.options.defaultPendingComponent) as any\n\n  const pendingElement = PendingComponent ? <PendingComponent /> : null\n\n  const routeErrorComponent =\n    route.options.errorComponent ??\n    router.options.defaultErrorComponent ??\n    ErrorComponent\n\n  const ResolvedSuspenseBoundary =\n    route.options.wrapInSuspense ??\n    PendingComponent ??\n    route.options.component?.preload ??\n    route.options.pendingComponent?.preload ??\n    (route.options.errorComponent as any)?.preload\n      ? React.Suspense\n      : SafeFragment\n\n  const ResolvedCatchBoundary = routeErrorComponent\n    ? CatchBoundary\n    : SafeFragment\n\n  return (\n    <matchContext.Provider value={matchId}>\n      <ResolvedSuspenseBoundary fallback={pendingElement}>\n        <ResolvedCatchBoundary\n          getResetKey={() => router.state.resolvedLocation.state?.key}\n          errorComponent={routeErrorComponent}\n          onCatch={() => {\n            warning(false, `Error in route match: ${matchId}`)\n          }}\n        >\n          <MatchInner matchId={matchId!} pendingElement={pendingElement} />\n        </ResolvedCatchBoundary>\n      </ResolvedSuspenseBoundary>\n    </matchContext.Provider>\n  )\n}\n\nfunction MatchInner({\n  matchId,\n  pendingElement,\n}: {\n  matchId: string\n  pendingElement: any\n}): any {\n  const router = useRouter()\n  const routeId = useRouterState({\n    select: (s) =>\n      getRenderedMatches(s).find((d) => d.id === matchId)?.routeId as string,\n  })\n\n  const route = router.routesById[routeId]!\n\n  const match = useRouterState({\n    select: (s) =>\n      pick(getRenderedMatches(s).find((d) => d.id === matchId)!, [\n        'status',\n        'error',\n        'showPending',\n        'loadPromise',\n      ]),\n  })\n\n  if (match.status === 'error') {\n    throw match.error\n  }\n\n  if (match.status === 'pending') {\n    if (match.showPending) {\n      return pendingElement\n    }\n    throw match.loadPromise\n  }\n\n  if (match.status === 'success') {\n    let Comp = route.options.component ?? router.options.defaultComponent\n\n    if (Comp) {\n      return <Comp />\n    }\n\n    return <Outlet />\n  }\n\n  invariant(\n    false,\n    'Idle routeMatch status encountered during rendering! You should never see this. File an issue!',\n  )\n}\n\nexport const Outlet = React.memo(function Outlet() {\n  const matchId = React.useContext(matchContext)\n\n  const childMatchId = useRouterState({\n    select: (s) => {\n      const matches = getRenderedMatches(s)\n      const index = matches.findIndex((d) => d.id === matchId)\n      return matches[index + 1]?.id\n    },\n  })\n\n  if (!childMatchId) {\n    return null\n  }\n\n  return <Match matchId={childMatchId} />\n})\n\nexport interface MatchRouteOptions {\n  pending?: boolean\n  caseSensitive?: boolean\n  includeSearch?: boolean\n  fuzzy?: boolean\n}\n\nexport type UseMatchRouteOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ToOptions<AnyRoute, TFrom, TTo, TMaskFrom, TMaskTo> & MatchRouteOptions\n\nexport function useMatchRoute<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n>() {\n  useRouterState({ select: (s) => [s.location, s.resolvedLocation] })\n  const { matchRoute } = useRouter()\n\n  return React.useCallback(\n    <\n      TFrom extends RoutePaths<TRouteTree> = '/',\n      TTo extends string = '',\n      TMaskFrom extends RoutePaths<TRouteTree> = '/',\n      TMaskTo extends string = '',\n      TResolved extends string = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n    >(\n      opts: UseMatchRouteOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n    ): false | RouteById<TRouteTree, TResolved>['types']['allParams'] => {\n      const { pending, caseSensitive, ...rest } = opts\n\n      return matchRoute(rest as any, {\n        pending,\n        caseSensitive,\n      })\n    },\n    [],\n  )\n}\n\nexport type MakeMatchRouteOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ToOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> &\n  MatchRouteOptions & {\n    // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n    children?:\n      | ((\n          params?: RouteByPath<\n            TRouteTree,\n            ResolveRelativePath<TFrom, NoInfer<TTo>>\n          >['types']['allParams'],\n        ) => ReactNode)\n      | React.ReactNode\n  }\n\nexport function MatchRoute<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n>(\n  props: MakeMatchRouteOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n): any {\n  const matchRoute = useMatchRoute()\n  const params = matchRoute(props as any)\n\n  if (typeof props.children === 'function') {\n    return (props.children as any)(params)\n  }\n\n  return !!params ? props.children : null\n}\n\nfunction getRenderedMatches(state: RouterState) {\n  return state.pendingMatches?.some((d) => d.showPending)\n    ? state.pendingMatches\n    : state.matches\n}\n\nexport function useMatch<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TStrict extends boolean = true,\n  TRouteMatchState = RouteMatch<TRouteTree, TFrom>,\n  TSelected = TRouteMatchState,\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (match: TRouteMatchState) => TSelected\n  },\n): TStrict extends true ? TSelected : TSelected | undefined {\n  const router = useRouter()\n  const nearestMatchId = React.useContext(matchContext)\n\n  const nearestMatchRouteId = getRenderedMatches(router.state).find(\n    (d) => d.id === nearestMatchId,\n  )?.routeId\n\n  const matchRouteId = (() => {\n    const matches = getRenderedMatches(router.state)\n    const match = opts?.from\n      ? matches.find((d) => d.routeId === opts?.from)\n      : matches.find((d) => d.id === nearestMatchId)\n    return match!.routeId\n  })()\n\n  if (opts?.strict ?? true) {\n    invariant(\n      nearestMatchRouteId == matchRouteId,\n      `useMatch(\"${\n        matchRouteId as string\n      }\") is being called in a component that is meant to render the '${nearestMatchRouteId}' route. Did you mean to 'useMatch(\"${\n        matchRouteId as string\n      }\", { strict: false })' or 'useRoute(\"${\n        matchRouteId as string\n      }\")' instead?`,\n    )\n  }\n\n  const matchSelection = useRouterState({\n    select: (state) => {\n      const match = getRenderedMatches(state).find(\n        (d) => d.id === nearestMatchId,\n      )\n\n      invariant(\n        match,\n        `Could not find ${\n          opts?.from\n            ? `an active match from \"${opts.from}\"`\n            : 'a nearest match!'\n        }`,\n      )\n\n      return opts?.select ? opts.select(match as any) : match\n    },\n  })\n\n  return matchSelection as any\n}\n\nexport function useMatches<T = RouteMatch[]>(opts?: {\n  select?: (matches: RouteMatch[]) => T\n}): T {\n  return useRouterState({\n    select: (state) => {\n      let matches = getRenderedMatches(state)\n      return opts?.select ? opts.select(matches) : (matches as T)\n    },\n  })\n}\n\nexport function useParentMatches<T = RouteMatch[]>(opts?: {\n  select?: (matches: RouteMatch[]) => T\n}): T {\n  const contextMatchId = React.useContext(matchContext)\n\n  return useMatches({\n    select: (matches) => {\n      matches = matches.slice(matches.findIndex((d) => d.id === contextMatchId))\n      return opts?.select ? opts.select(matches) : (matches as T)\n    },\n  })\n}\n\nexport function useLoaderDeps<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TStrict extends boolean = true,\n  TRouteMatch extends RouteMatch<TRouteTree, TFrom> = RouteMatch<\n    TRouteTree,\n    TFrom\n  >,\n  TSelected = Required<TRouteMatch>['loaderDeps'],\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (match: TRouteMatch) => TSelected\n  },\n): TStrict extends true ? TSelected : TSelected | undefined {\n  return useMatch({\n    ...opts,\n    select: (s) => {\n      return typeof opts.select === 'function'\n        ? opts.select(s?.loaderDeps)\n        : s?.loaderDeps\n    },\n  })!\n}\n\nexport function useLoaderData<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TStrict extends boolean = true,\n  TRouteMatch extends RouteMatch<TRouteTree, TFrom> = RouteMatch<\n    TRouteTree,\n    TFrom\n  >,\n  TSelected = Required<TRouteMatch>['loaderData'],\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (match: TRouteMatch) => TSelected\n  },\n): TStrict extends true ? TSelected : TSelected | undefined {\n  return useMatch({\n    ...opts,\n    select: (s) => {\n      return typeof opts.select === 'function'\n        ? opts.select(s?.loaderData)\n        : s?.loaderData\n    },\n  })!\n}\n","import * as React from 'react'\nimport warning from 'tiny-warning'\nimport { useStore } from '@tanstack/react-store'\nimport { Matches } from './Matches'\nimport { NavigateOptions, ResolveRelativePath, ToOptions } from './link'\nimport { ParsedLocation } from './location'\nimport { AnyRoute } from './route'\nimport { RouteById, RoutePaths } from './routeInfo'\nimport {\n  BuildNextOptions,\n  RegisteredRouter,\n  Router,\n  RouterOptions,\n  RouterState,\n} from './router'\nimport { NoInfer, pick, useLayoutEffect } from './utils'\nimport { MatchRouteOptions } from './Matches'\nimport { RouteMatch } from './Matches'\n\nexport interface CommitLocationOptions {\n  replace?: boolean\n  resetScroll?: boolean\n  startTransition?: boolean\n}\n\nexport interface MatchLocation {\n  to?: string | number | null\n  fuzzy?: boolean\n  caseSensitive?: boolean\n  from?: string\n}\n\nexport type NavigateFn<TRouteTree extends AnyRoute> = <\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n>(\n  opts: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n) => Promise<void>\n\nexport type MatchRouteFn<TRouteTree extends AnyRoute> = <\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n>(\n  location: ToOptions<TRouteTree, TFrom, TTo>,\n  opts?: MatchRouteOptions,\n) => false | RouteById<TRouteTree, TResolved>['types']['allParams']\n\nexport type BuildLocationFn<TRouteTree extends AnyRoute> = (\n  opts: ToOptions<TRouteTree>,\n) => ParsedLocation\n\nexport type InjectedHtmlEntry = string | (() => Promise<string> | string)\n\nexport let routerContext = React.createContext<Router<any>>(null!)\n\nif (typeof document !== 'undefined') {\n  if (window.__TSR_ROUTER_CONTEXT__) {\n    routerContext = window.__TSR_ROUTER_CONTEXT__\n  } else {\n    window.__TSR_ROUTER_CONTEXT__ = routerContext as any\n  }\n}\n\nexport function RouterProvider<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TDehydrated extends Record<string, any> = Record<string, any>,\n>({ router, ...rest }: RouterProps<TRouteTree, TDehydrated>) {\n  // Allow the router to update options on the router instance\n  router.update({\n    ...router.options,\n    ...rest,\n    context: {\n      ...router.options.context,\n      ...rest?.context,\n    },\n  } as any)\n\n  const matches = router.options.InnerWrap ? (\n    <router.options.InnerWrap>\n      <Matches />\n    </router.options.InnerWrap>\n  ) : (\n    <Matches />\n  )\n\n  const provider = (\n    <routerContext.Provider value={router}>\n      {matches}\n      <Transitioner />\n    </routerContext.Provider>\n  )\n\n  if (router.options.Wrap) {\n    return <router.options.Wrap>{provider}</router.options.Wrap>\n  }\n\n  return provider\n}\n\nfunction Transitioner() {\n  const router = useRouter()\n  const routerState = useRouterState({\n    select: (s) =>\n      pick(s, ['isLoading', 'location', 'resolvedLocation', 'isTransitioning']),\n  })\n\n  const [isTransitioning, startReactTransition] = React.useTransition()\n\n  router.startReactTransition = startReactTransition\n\n  React.useEffect(() => {\n    if (isTransitioning) {\n      router.__store.setState((s) => ({\n        ...s,\n        isTransitioning,\n      }))\n    }\n  }, [isTransitioning])\n\n  const tryLoad = () => {\n    const apply = (cb: () => void) => {\n      if (!routerState.isTransitioning) {\n        startReactTransition(() => cb())\n      } else {\n        cb()\n      }\n    }\n\n    apply(() => {\n      try {\n        router.load()\n      } catch (err) {\n        console.error(err)\n      }\n    })\n  }\n\n  useLayoutEffect(() => {\n    const unsub = router.history.subscribe(() => {\n      router.latestLocation = router.parseLocation(router.latestLocation)\n      if (routerState.location !== router.latestLocation) {\n        tryLoad()\n      }\n    })\n\n    const nextLocation = router.buildLocation({\n      search: true,\n      params: true,\n      hash: true,\n      state: true,\n    })\n\n    if (routerState.location.href !== nextLocation.href) {\n      router.commitLocation({ ...nextLocation, replace: true })\n    }\n\n    return () => {\n      unsub()\n    }\n  }, [router.history])\n\n  useLayoutEffect(() => {\n    if (\n      routerState.isTransitioning &&\n      !isTransitioning &&\n      !routerState.isLoading &&\n      routerState.resolvedLocation !== routerState.location\n    ) {\n      router.emit({\n        type: 'onResolved',\n        fromLocation: routerState.resolvedLocation,\n        toLocation: routerState.location,\n        pathChanged:\n          routerState.location!.href !== routerState.resolvedLocation?.href,\n      })\n\n      if ((document as any).querySelector) {\n        if (routerState.location.hash !== '') {\n          const el = document.getElementById(\n            routerState.location.hash,\n          ) as HTMLElement | null\n          if (el) {\n            el.scrollIntoView()\n          }\n        }\n      }\n\n      router.__store.setState((s) => ({\n        ...s,\n        isTransitioning: false,\n        resolvedLocation: s.location,\n      }))\n    }\n  }, [\n    routerState.isTransitioning,\n    isTransitioning,\n    routerState.isLoading,\n    routerState.resolvedLocation,\n    routerState.location,\n  ])\n\n  useLayoutEffect(() => {\n    if (!window.__TSR_DEHYDRATED__) {\n      tryLoad()\n    }\n  }, [])\n\n  return null\n}\n\nexport function getRouteMatch<TRouteTree extends AnyRoute>(\n  state: RouterState<TRouteTree>,\n  id: string,\n): undefined | RouteMatch<TRouteTree> {\n  return [\n    ...state.cachedMatches,\n    ...(state.pendingMatches ?? []),\n    ...state.matches,\n  ].find((d) => d.id === id)\n}\n\nexport function useRouterState<\n  TSelected = RouterState<RegisteredRouter['routeTree']>,\n>(opts?: {\n  select: (state: RouterState<RegisteredRouter['routeTree']>) => TSelected\n}): TSelected {\n  const router = useRouter()\n  return useStore(router.__store, opts?.select as any)\n}\n\nexport type RouterProps<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> = Omit<RouterOptions<TRouteTree, TDehydrated>, 'context'> & {\n  router: Router<TRouteTree>\n  context?: Partial<RouterOptions<TRouteTree, TDehydrated>['context']>\n}\n\nexport function useRouter<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n>(): Router<TRouteTree> {\n  const resolvedContext =\n    typeof document !== 'undefined'\n      ? window.__TSR_ROUTER_CONTEXT__ || routerContext\n      : routerContext\n  const value = React.useContext(resolvedContext)\n  warning(value, 'useRouter must be used inside a <RouterProvider> component!')\n  return value as any\n}\n","export type DeferredPromiseState<T> = { uid: string } & (\n  | {\n      status: 'pending'\n      data?: T\n      error?: unknown\n    }\n  | {\n      status: 'success'\n      data: T\n    }\n  | {\n      status: 'error'\n      data?: T\n      error: unknown\n    }\n)\n\nexport type DeferredPromise<T> = Promise<T> & {\n  __deferredState: DeferredPromiseState<T>\n}\n\nexport function defer<T>(_promise: Promise<T>) {\n  const promise = _promise as DeferredPromise<T>\n\n  if (!promise.__deferredState) {\n    promise.__deferredState = {\n      uid: Math.random().toString(36).slice(2),\n      status: 'pending',\n    }\n\n    const state = promise.__deferredState\n\n    promise\n      .then((data) => {\n        state.status = 'success' as any\n        state.data = data\n      })\n      .catch((error) => {\n        state.status = 'error' as any\n        state.error = error\n      })\n  }\n\n  return promise\n}\n\nexport function isDehydratedDeferred(obj: any): boolean {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    !(obj instanceof Promise) &&\n    !obj.then &&\n    '__deferredState' in obj\n  )\n}\n","import { useRouter } from './RouterProvider'\nimport { DeferredPromise, isDehydratedDeferred } from './defer'\n\nexport type AwaitOptions<T> = {\n  promise: DeferredPromise<T>\n}\n\nexport function useAwaited<T>({ promise }: AwaitOptions<T>): [T] {\n  const router = useRouter()\n\n  let state = promise.__deferredState\n  const key = `__TSR__DEFERRED__${state.uid}`\n\n  if (isDehydratedDeferred(promise)) {\n    state = router.hydrateData(key)!\n    promise = Promise.resolve(state.data) as DeferredPromise<any>\n    promise.__deferredState = state\n  }\n\n  if (state.status === 'pending') {\n    throw new Promise((r) => setTimeout(r, 1)).then(() => promise)\n  }\n\n  if (state.status === 'error') {\n    throw state.error\n  }\n\n  router.dehydrateData(key, state)\n\n  return [state.data]\n}\n\nexport function Await<T>(\n  props: AwaitOptions<T> & {\n    children: (result: T) => JSX.Element\n  },\n) {\n  const awaited = useAwaited(props)\n  return props.children(...awaited)\n}\n","import { MatchLocation } from './RouterProvider'\nimport { AnyPathParams } from './route'\nimport { last } from './utils'\n\nexport interface Segment {\n  type: 'pathname' | 'param' | 'wildcard'\n  value: string\n}\n\nexport function joinPaths(paths: (string | undefined)[]) {\n  return cleanPath(paths.filter(Boolean).join('/'))\n}\n\nexport function cleanPath(path: string) {\n  // remove double slashes\n  return path.replace(/\\/{2,}/g, '/')\n}\n\nexport function trimPathLeft(path: string) {\n  return path === '/' ? path : path.replace(/^\\/{1,}/, '')\n}\n\nexport function trimPathRight(path: string) {\n  return path === '/' ? path : path.replace(/\\/{1,}$/, '')\n}\n\nexport function trimPath(path: string) {\n  return trimPathRight(trimPathLeft(path))\n}\n\nexport function resolvePath(basepath: string, base: string, to: string) {\n  base = base.replace(new RegExp(`^${basepath}`), '/')\n  to = to.replace(new RegExp(`^${basepath}`), '/')\n\n  let baseSegments = parsePathname(base)\n  const toSegments = parsePathname(to)\n\n  toSegments.forEach((toSegment, index) => {\n    if (toSegment.value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment]\n      } else if (index === toSegments.length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment)\n      } else {\n        // ignore inter-slashes\n      }\n    } else if (toSegment.value === '..') {\n      // Extra trailing slash? pop it off\n      if (baseSegments.length > 1 && last(baseSegments)?.value === '/') {\n        baseSegments.pop()\n      }\n      baseSegments.pop()\n    } else if (toSegment.value === '.') {\n      return\n    } else {\n      baseSegments.push(toSegment)\n    }\n  })\n\n  const joined = joinPaths([basepath, ...baseSegments.map((d) => d.value)])\n\n  return cleanPath(joined)\n}\n\nexport function parsePathname(pathname?: string): Segment[] {\n  if (!pathname) {\n    return []\n  }\n\n  pathname = cleanPath(pathname)\n\n  const segments: Segment[] = []\n\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!pathname) {\n    return segments\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean)\n\n  segments.push(\n    ...split.map((part): Segment => {\n      if (part === '$' || part === '*') {\n        return {\n          type: 'wildcard',\n          value: part,\n        }\n      }\n\n      if (part.charAt(0) === '$') {\n        return {\n          type: 'param',\n          value: part,\n        }\n      }\n\n      return {\n        type: 'pathname',\n        value: part,\n      }\n    }),\n  )\n\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  return segments\n}\n\nexport function interpolatePath(\n  path: string | undefined,\n  params: any,\n  leaveWildcards: boolean = false,\n) {\n  const interpolatedPathSegments = parsePathname(path)\n\n  return joinPaths(\n    interpolatedPathSegments.map((segment) => {\n      if (segment.type === 'wildcard') {\n        const value = params[segment.value]\n        if (leaveWildcards) return `${segment.value}${value ?? ''}`\n        return value\n      }\n\n      if (segment.type === 'param') {\n        return params![segment.value.substring(1)] ?? 'undefined'\n      }\n\n      return segment.value\n    }),\n  )\n}\n\nexport function matchPathname(\n  basepath: string,\n  currentPathname: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'fuzzy' | 'caseSensitive'>,\n): AnyPathParams | undefined {\n  const pathParams = matchByPath(basepath, currentPathname, matchLocation)\n  // const searchMatched = matchBySearch(location.search, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return\n  }\n\n  return pathParams ?? {}\n}\n\nexport function removeBasepath(basepath: string, pathname: string) {\n  return basepath != '/' ? pathname.substring(basepath.length) : pathname\n}\n\nexport function matchByPath(\n  basepath: string,\n  from: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'caseSensitive' | 'fuzzy'>,\n): Record<string, string> | undefined {\n  // Remove the base path from the pathname\n  from = removeBasepath(basepath, from)\n  // Default to to $ (wildcard)\n  const to = `${matchLocation.to ?? '$'}`\n  // Parse the from and to\n  const baseSegments = parsePathname(from)\n  const routeSegments = parsePathname(to)\n\n  if (!from.startsWith('/')) {\n    baseSegments.unshift({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!to.startsWith('/')) {\n    routeSegments.unshift({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  const params: Record<string, string> = {}\n\n  let isMatch = (() => {\n    for (\n      let i = 0;\n      i < Math.max(baseSegments.length, routeSegments.length);\n      i++\n    ) {\n      const baseSegment = baseSegments[i]\n      const routeSegment = routeSegments[i]\n\n      const isLastBaseSegment = i >= baseSegments.length - 1\n      const isLastRouteSegment = i >= routeSegments.length - 1\n\n      if (routeSegment) {\n        if (routeSegment.type === 'wildcard') {\n          if (baseSegment?.value) {\n            params['*'] = joinPaths(baseSegments.slice(i).map((d) => d.value))\n            return true\n          }\n          return false\n        }\n\n        if (routeSegment.type === 'pathname') {\n          if (routeSegment.value === '/' && !baseSegment?.value) {\n            return true\n          }\n\n          if (baseSegment) {\n            if (matchLocation.caseSensitive) {\n              if (routeSegment.value !== baseSegment.value) {\n                return false\n              }\n            } else if (\n              routeSegment.value.toLowerCase() !==\n              baseSegment.value.toLowerCase()\n            ) {\n              return false\n            }\n          }\n        }\n\n        if (!baseSegment) {\n          return false\n        }\n\n        if (routeSegment.type === 'param') {\n          if (baseSegment?.value === '/') {\n            return false\n          }\n          if (baseSegment.value.charAt(0) !== '$') {\n            params[routeSegment.value.substring(1)] = baseSegment.value\n          }\n        }\n      }\n\n      if (!isLastBaseSegment && isLastRouteSegment) {\n        params['**'] = joinPaths(baseSegments.slice(i + 1).map((d) => d.value))\n        return !!matchLocation.fuzzy && routeSegment?.value !== '/'\n      }\n    }\n\n    return true\n  })()\n\n  return isMatch ? (params as Record<string, string>) : undefined\n}\n","import { AnyRoute } from './route'\nimport { RouteIds, RouteById, AllParams } from './routeInfo'\nimport { RegisteredRouter } from './router'\nimport { last } from './utils'\nimport { useRouterState } from './RouterProvider'\nimport { StrictOrFrom } from './utils'\n\nexport function useParams<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TDefaultSelected = AllParams<TRouteTree> &\n    RouteById<TRouteTree, TFrom>['types']['allParams'],\n  TSelected = TDefaultSelected,\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (search: TDefaultSelected) => TSelected\n  },\n): TSelected {\n  return useRouterState({\n    select: (state: any) => {\n      const params = (last(state.matches) as any)?.params\n      return opts?.select ? opts.select(params) : params\n    },\n  })\n}\n","import { AnyRoute } from './route'\nimport { RouteIds, RouteById } from './routeInfo'\nimport { RegisteredRouter } from './router'\nimport { RouteMatch } from './Matches'\nimport { useMatch } from './Matches'\nimport { StrictOrFrom } from './utils'\n\nexport function useSearch<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TStrict extends boolean = true,\n  TSearch = RouteById<TRouteTree, TFrom>['types']['fullSearchSchema'],\n  TSelected = TSearch,\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (search: TSearch) => TSelected\n  },\n): TStrict extends true ? TSelected : TSelected | undefined {\n  return useMatch({\n    ...(opts as any),\n    select: (match: RouteMatch) => {\n      return opts?.select ? opts.select(match.search as TSearch) : match.search\n    },\n  })\n}\n","import * as React from 'react'\nimport invariant from 'tiny-invariant'\nimport { useLoaderData, useLoaderDeps, useMatch } from './Matches'\nimport { AnyRouteMatch } from './Matches'\nimport { NavigateOptions, ParsePathParams, ToSubOptions } from './link'\nimport { ParsedLocation } from './location'\nimport { joinPaths, trimPath } from './path'\nimport { RouteById, RouteIds, RoutePaths } from './routeInfo'\nimport { AnyRouter, RegisteredRouter } from './router'\nimport { useParams } from './useParams'\nimport { useSearch } from './useSearch'\nimport {\n  Assign,\n  Expand,\n  IsAny,\n  NoInfer,\n  PickRequired,\n  UnionToIntersection,\n} from './utils'\nimport { BuildLocationFn, NavigateFn } from './RouterProvider'\n\nexport const rootRouteId = '__root__' as const\nexport type RootRouteId = typeof rootRouteId\nexport type AnyPathParams = {}\n\nexport type AnySearchSchema = {}\n\nexport type AnyContext = {}\n\nexport interface RouteContext {}\n\nexport interface RouteMeta {}\n\nexport type PreloadableObj = { preload?: () => Promise<void> }\n\nexport type RoutePathOptions<TCustomId, TPath> =\n  | {\n      path: TPath\n    }\n  | {\n      id: TCustomId\n    }\n\nexport type RoutePathOptionsIntersection<TCustomId, TPath> =\n  UnionToIntersection<RoutePathOptions<TCustomId, TPath>>\n\nexport type MetaOptions = keyof PickRequired<RouteMeta> extends never\n  ? {\n      meta?: RouteMeta\n    }\n  : {\n      meta: RouteMeta\n    }\n\nexport type RouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TCustomId extends string = string,\n  TPath extends string = string,\n  TSearchSchema extends Record<string, any> = {},\n  TFullSearchSchema extends Record<string, any> = TSearchSchema,\n  TParams extends AnyPathParams = AnyPathParams,\n  TAllParams extends AnyPathParams = TParams,\n  TRouteContext extends RouteContext = RouteContext,\n  TAllContext extends Record<string, any> = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderData extends any = unknown,\n> = BaseRouteOptions<\n  TParentRoute,\n  TCustomId,\n  TPath,\n  TSearchSchema,\n  TFullSearchSchema,\n  TParams,\n  TAllParams,\n  TRouteContext,\n  TAllContext,\n  TLoaderDeps,\n  TLoaderData\n> &\n  UpdatableRouteOptions<NoInfer<TFullSearchSchema>>\n\nexport type ParamsFallback<\n  TPath extends string,\n  TParams,\n> = unknown extends TParams ? Record<ParsePathParams<TPath>, string> : TParams\n\nexport type BaseRouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TCustomId extends string = string,\n  TPath extends string = string,\n  TSearchSchema extends Record<string, any> = {},\n  TFullSearchSchema extends Record<string, any> = TSearchSchema,\n  TParams extends AnyPathParams = {},\n  TAllParams = ParamsFallback<TPath, TParams>,\n  TRouteContext extends RouteContext = RouteContext,\n  TAllContext extends Record<string, any> = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderData extends any = unknown,\n> = RoutePathOptions<TCustomId, TPath> & {\n  getParentRoute: () => TParentRoute\n  validateSearch?: SearchSchemaValidator<TSearchSchema>\n  shouldReload?:\n    | boolean\n    | ((\n        match: LoaderFnContext<\n          TAllParams,\n          TFullSearchSchema,\n          TAllContext,\n          TRouteContext\n        >,\n      ) => any)\n} & (keyof PickRequired<RouteContext> extends never\n    ? // This async function is called before a route is loaded.\n      // If an error is thrown here, the route's loader will not be called.\n      // If thrown during a navigation, the navigation will be cancelled and the error will be passed to the `onError` function.\n      // If thrown during a preload event, the error will be logged to the console.\n      {\n        beforeLoad?: BeforeLoadFn<\n          TFullSearchSchema,\n          TParentRoute,\n          TAllParams,\n          TRouteContext\n        >\n      }\n    : {\n        beforeLoad: BeforeLoadFn<\n          TFullSearchSchema,\n          TParentRoute,\n          TAllParams,\n          TRouteContext\n        >\n      }) & {\n    loaderDeps?: (opts: { search: TFullSearchSchema }) => TLoaderDeps\n    loader?: RouteLoaderFn<\n      TAllParams,\n      NoInfer<TLoaderDeps>,\n      NoInfer<TAllContext>,\n      NoInfer<TRouteContext>,\n      TLoaderData\n    >\n  } & (\n    | {\n        // Both or none\n        parseParams?: (\n          rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>,\n        ) => TParams extends Record<ParsePathParams<TPath>, any>\n          ? TParams\n          : 'parseParams must return an object'\n        stringifyParams?: (\n          params: NoInfer<ParamsFallback<TPath, TParams>>,\n        ) => Record<ParsePathParams<TPath>, string>\n      }\n    | {\n        stringifyParams?: never\n        parseParams?: never\n      }\n  )\n\ntype BeforeLoadFn<\n  TFullSearchSchema extends Record<string, any>,\n  TParentRoute extends AnyRoute,\n  TAllParams,\n  TRouteContext,\n> = (opts: {\n  search: TFullSearchSchema\n  abortController: AbortController\n  preload: boolean\n  params: TAllParams\n  context: TParentRoute['types']['allContext']\n  location: ParsedLocation\n  navigate: NavigateFn<AnyRoute>\n  buildLocation: BuildLocationFn<TParentRoute>\n  cause: 'preload' | 'enter' | 'stay'\n}) => Promise<TRouteContext> | TRouteContext | void\n\nexport type UpdatableRouteOptions<\n  TFullSearchSchema extends Record<string, any>,\n> = MetaOptions & {\n  // test?: (args: TAllContext) => void\n  // If true, this route will be matched as case-sensitive\n  caseSensitive?: boolean\n  // If true, this route will be forcefully wrapped in a suspense boundary\n  wrapInSuspense?: boolean\n  // The content to be rendered when the route is matched. If no component is provided, defaults to `<Outlet />`\n  component?: RouteComponent\n  errorComponent?: false | null | ErrorRouteComponent\n  pendingComponent?: RouteComponent\n  pendingMs?: number\n  pendingMinMs?: number\n  staleTime?: number\n  gcTime?: number\n  preloadStaleTime?: number\n  preloadGcTime?: number\n  // Filter functions that can manipulate search params *before* they are passed to links and navigate\n  // calls that match this route.\n  preSearchFilters?: SearchFilter<TFullSearchSchema>[]\n  // Filter functions that can manipulate search params *after* they are passed to links and navigate\n  // calls that match this route.\n  postSearchFilters?: SearchFilter<TFullSearchSchema>[]\n  onError?: (err: any) => void\n  // These functions are called as route matches are loaded, stick around and leave the active\n  // matches\n  onEnter?: (match: AnyRouteMatch) => void\n  onStay?: (match: AnyRouteMatch) => void\n  onLeave?: (match: AnyRouteMatch) => void\n}\n\nexport type ParseParamsOption<TPath extends string, TParams> = ParseParamsFn<\n  TPath,\n  TParams\n>\n\nexport type ParseParamsFn<TPath extends string, TParams> = (\n  rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>,\n) => TParams extends Record<ParsePathParams<TPath>, any>\n  ? TParams\n  : 'parseParams must return an object'\n\nexport type ParseParamsObj<TPath extends string, TParams> = {\n  parse?: ParseParamsFn<TPath, TParams>\n}\n\n// The parse type here allows a zod schema to be passed directly to the validator\nexport type SearchSchemaValidator<TReturn> =\n  | SearchSchemaValidatorObj<TReturn>\n  | SearchSchemaValidatorFn<TReturn>\n\nexport type SearchSchemaValidatorObj<TReturn> = {\n  parse?: SearchSchemaValidatorFn<TReturn>\n}\n\nexport type SearchSchemaValidatorFn<TReturn> = (\n  searchObj: Record<string, unknown>,\n) => TReturn\n\nexport type DefinedPathParamWarning =\n  'Path params cannot be redefined by child routes!'\n\nexport type ParentParams<TParentParams> = AnyPathParams extends TParentParams\n  ? {}\n  : {\n      [Key in keyof TParentParams]?: DefinedPathParamWarning\n    }\n\nexport type RouteLoaderFn<\n  TAllParams = {},\n  TLoaderDeps extends Record<string, any> = {},\n  TAllContext extends Record<string, any> = AnyContext,\n  TRouteContext extends Record<string, any> = AnyContext,\n  TLoaderData extends any = unknown,\n> = (\n  match: LoaderFnContext<TAllParams, TLoaderDeps, TAllContext, TRouteContext>,\n) => Promise<TLoaderData> | TLoaderData\n\nexport interface LoaderFnContext<\n  TAllParams = {},\n  TLoaderDeps extends Record<string, any> = {},\n  TAllContext extends Record<string, any> = AnyContext,\n  TRouteContext extends Record<string, any> = AnyContext,\n> {\n  abortController: AbortController\n  preload: boolean\n  params: TAllParams\n  deps: TLoaderDeps\n  context: Expand<Assign<TAllContext, TRouteContext>>\n  location: ParsedLocation // Do not supply search schema here so as to demotivate people from trying to shortcut loaderDeps\n  navigate: (opts: NavigateOptions<AnyRoute>) => Promise<void>\n  parentMatchPromise?: Promise<void>\n  cause: 'preload' | 'enter' | 'stay'\n}\n\nexport type SearchFilter<T, U = T> = (prev: T) => U\n\nexport type ResolveId<\n  TParentRoute,\n  TCustomId extends string,\n  TPath extends string,\n> = TParentRoute extends { id: infer TParentId extends string }\n  ? RoutePrefix<TParentId, string extends TCustomId ? TPath : TCustomId>\n  : RootRouteId\n\nexport type InferFullSearchSchema<TRoute> = TRoute extends {\n  types: {\n    fullSearchSchema: infer TFullSearchSchema\n  }\n}\n  ? TFullSearchSchema\n  : {}\n\nexport type ResolveFullSearchSchema<TParentRoute, TSearchSchema> = Expand<\n  Assign<InferFullSearchSchema<TParentRoute>, TSearchSchema>\n>\n\nexport interface AnyRoute\n  extends Route<\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  > {}\n\nexport type MergeFromFromParent<T, U> = IsAny<T, U, T & U>\n\nexport type ResolveAllParams<\n  TParentRoute extends AnyRoute,\n  TParams extends AnyPathParams,\n> = Record<never, string> extends TParentRoute['types']['allParams']\n  ? TParams\n  : Expand<\n      UnionToIntersection<TParentRoute['types']['allParams'] & TParams> & {}\n    >\n\nexport type RouteConstraints = {\n  TParentRoute: AnyRoute\n  TPath: string\n  TFullPath: string\n  TCustomId: string\n  TId: string\n  TSearchSchema: AnySearchSchema\n  TFullSearchSchema: AnySearchSchema\n  TParams: Record<string, any>\n  TAllParams: Record<string, any>\n  TParentContext: AnyContext\n  TRouteContext: RouteContext\n  TAllContext: AnyContext\n  TRouterContext: AnyContext\n  TChildren: unknown\n  TRouteTree: AnyRoute\n}\n\nexport class RouteApi<\n  TId extends RouteIds<RegisteredRouter['routeTree']>,\n  TRoute extends AnyRoute = RouteById<RegisteredRouter['routeTree'], TId>,\n  TFullSearchSchema extends Record<\n    string,\n    any\n  > = TRoute['types']['fullSearchSchema'],\n  TAllParams extends AnyPathParams = TRoute['types']['allParams'],\n  TAllContext extends Record<string, any> = TRoute['types']['allContext'],\n  TLoaderDeps extends Record<string, any> = TRoute['types']['loaderDeps'],\n  TLoaderData extends any = TRoute['types']['loaderData'],\n> {\n  id: TId\n\n  constructor({ id }: { id: TId }) {\n    this.id = id as any\n  }\n\n  useMatch = <TSelected = TAllContext>(opts?: {\n    select?: (s: TAllContext) => TSelected\n  }): TSelected => {\n    return useMatch({ ...opts, from: this.id }) as any\n  }\n\n  useRouteContext = <TSelected = TAllContext>(opts?: {\n    select?: (s: TAllContext) => TSelected\n  }): TSelected => {\n    return useMatch({\n      ...opts,\n      from: this.id,\n      select: (d: any) => (opts?.select ? opts.select(d.context) : d.context),\n    } as any)\n  }\n\n  useSearch = <TSelected = TFullSearchSchema>(opts?: {\n    select?: (s: TFullSearchSchema) => TSelected\n  }): TSelected => {\n    return useSearch({ ...opts, from: this.id } as any)\n  }\n\n  useParams = <TSelected = TAllParams>(opts?: {\n    select?: (s: TAllParams) => TSelected\n  }): TSelected => {\n    return useParams({ ...opts, from: this.id } as any)\n  }\n\n  useLoaderDeps = <TSelected = TLoaderDeps>(opts?: {\n    select?: (s: TLoaderDeps) => TSelected\n  }): TSelected => {\n    return useLoaderDeps({ ...opts, from: this.id } as any) as any\n  }\n\n  useLoaderData = <TSelected = TLoaderData>(opts?: {\n    select?: (s: TLoaderData) => TSelected\n  }): TSelected => {\n    return useLoaderData({ ...opts, from: this.id } as any) as any\n  }\n}\n\nexport class Route<\n  TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute,\n  TPath extends RouteConstraints['TPath'] = '/',\n  TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\n    TParentRoute,\n    TPath\n  >,\n  TCustomId extends RouteConstraints['TCustomId'] = string,\n  TId extends RouteConstraints['TId'] = ResolveId<\n    TParentRoute,\n    TCustomId,\n    TPath\n  >,\n  TSearchSchema extends RouteConstraints['TSearchSchema'] = {},\n  TFullSearchSchema extends\n    RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchema<\n    TParentRoute,\n    TSearchSchema\n  >,\n  TParams extends RouteConstraints['TParams'] = Expand<\n    Record<ParsePathParams<TPath>, string>\n  >,\n  TAllParams extends RouteConstraints['TAllParams'] = ResolveAllParams<\n    TParentRoute,\n    TParams\n  >,\n  TRouteContext extends RouteConstraints['TRouteContext'] = RouteContext,\n  TAllContext extends Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  > = Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  >,\n  TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderData extends any = unknown,\n  TChildren extends RouteConstraints['TChildren'] = unknown,\n  TRouteTree extends RouteConstraints['TRouteTree'] = AnyRoute,\n> {\n  isRoot: TParentRoute extends Route<any> ? true : false\n  options: RouteOptions<\n    TParentRoute,\n    TCustomId,\n    TPath,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContext,\n    TAllContext,\n    TLoaderDeps,\n    TLoaderData\n  >\n\n  test!: Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  >\n\n  // Set up in this.init()\n  parentRoute!: TParentRoute\n  id!: TId\n  // customId!: TCustomId\n  path!: TPath\n  fullPath!: TFullPath\n  to!: TrimPathRight<TFullPath>\n\n  // Optional\n  children?: TChildren\n  originalIndex?: number\n  router?: AnyRouter\n  rank!: number\n\n  constructor(\n    options: RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParams,\n      TAllParams,\n      TRouteContext,\n      TAllContext,\n      TLoaderDeps,\n      TLoaderData\n    >,\n  ) {\n    this.options = (options as any) || {}\n    this.isRoot = !options?.getParentRoute as any\n    invariant(\n      !((options as any)?.id && (options as any)?.path),\n      `Route cannot have both an 'id' and a 'path' option.`,\n    )\n    ;(this as any).$$typeof = Symbol.for('react.memo')\n  }\n\n  types!: {\n    parentRoute: TParentRoute\n    path: TPath\n    to: TrimPathRight<TFullPath>\n    fullPath: TFullPath\n    customId: TCustomId\n    id: TId\n    searchSchema: TSearchSchema\n    fullSearchSchema: TFullSearchSchema\n    params: TParams\n    allParams: TAllParams\n    routeContext: TRouteContext\n    allContext: TAllContext\n    children: TChildren\n    routeTree: TRouteTree\n    routerContext: TRouterContext\n    loaderData: TLoaderData\n    loaderDeps: TLoaderDeps\n  }\n\n  init = (opts: { originalIndex: number }) => {\n    this.originalIndex = opts.originalIndex\n\n    const options = this.options as RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParams,\n      TAllParams,\n      TRouteContext,\n      TAllContext,\n      TLoaderDeps,\n      TLoaderData\n    > &\n      RoutePathOptionsIntersection<TCustomId, TPath>\n\n    const isRoot = !options?.path && !options?.id\n\n    this.parentRoute = this.options?.getParentRoute?.()\n\n    if (isRoot) {\n      this.path = rootRouteId as TPath\n    } else {\n      invariant(\n        this.parentRoute,\n        `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`,\n      )\n    }\n\n    let path: undefined | string = isRoot ? rootRouteId : options.path\n\n    // If the path is anything other than an index path, trim it up\n    if (path && path !== '/') {\n      path = trimPath(path)\n    }\n\n    const customId = options?.id || path\n\n    // Strip the parentId prefix from the first level of children\n    let id = isRoot\n      ? rootRouteId\n      : joinPaths([\n          (this.parentRoute.id as any) === rootRouteId\n            ? ''\n            : this.parentRoute.id,\n          customId,\n        ])\n\n    if (path === rootRouteId) {\n      path = '/'\n    }\n\n    if (id !== rootRouteId) {\n      id = joinPaths(['/', id])\n    }\n\n    const fullPath =\n      id === rootRouteId ? '/' : joinPaths([this.parentRoute.fullPath, path])\n\n    this.path = path as TPath\n    this.id = id as TId\n    // this.customId = customId as TCustomId\n    this.fullPath = fullPath as TFullPath\n    this.to = fullPath as TrimPathRight<TFullPath>\n  }\n\n  addChildren = <TNewChildren extends AnyRoute[]>(\n    children: TNewChildren,\n  ): Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContext,\n    TAllContext,\n    TRouterContext,\n    TLoaderDeps,\n    TLoaderData,\n    TNewChildren,\n    TRouteTree\n  > => {\n    this.children = children as any\n    return this as any\n  }\n\n  update = (options: UpdatableRouteOptions<TFullSearchSchema>) => {\n    Object.assign(this.options, options)\n    return this\n  }\n\n  useMatch = <TSelected = TAllContext>(opts?: {\n    select?: (search: TAllContext) => TSelected\n  }): TSelected => {\n    return useMatch({ ...opts, from: this.id }) as any\n  }\n\n  useRouteContext = <TSelected = TAllContext>(opts?: {\n    select?: (search: TAllContext) => TSelected\n  }): TSelected => {\n    return useMatch({\n      ...opts,\n      from: this.id,\n      select: (d: any) => (opts?.select ? opts.select(d.context) : d.context),\n    } as any)\n  }\n\n  useSearch = <TSelected = TFullSearchSchema>(opts?: {\n    select?: (search: TFullSearchSchema) => TSelected\n  }): TSelected => {\n    return useSearch({ ...opts, from: this.id } as any)\n  }\n\n  useParams = <TSelected = TAllParams>(opts?: {\n    select?: (search: TAllParams) => TSelected\n  }): TSelected => {\n    return useParams({ ...opts, from: this.id } as any)\n  }\n\n  useLoaderDeps = <TSelected = TLoaderDeps>(opts?: {\n    select?: (s: TLoaderDeps) => TSelected\n  }): TSelected => {\n    return useLoaderDeps({ ...opts, from: this.id } as any) as any\n  }\n\n  useLoaderData = <TSelected = TLoaderData>(opts?: {\n    select?: (search: TLoaderData) => TSelected\n  }): TSelected => {\n    return useLoaderData({ ...opts, from: this.id } as any) as any\n  }\n}\n\nexport type AnyRootRoute = RootRoute<any, any, any, any>\n\nexport function rootRouteWithContext<TRouterContext extends {}>() {\n  return <\n    TSearchSchema extends Record<string, any> = {},\n    TRouteContext extends RouteContext = RouteContext,\n    TLoaderDeps extends Record<string, any> = {},\n    TLoaderData extends any = unknown,\n  >(\n    options?: Omit<\n      RouteOptions<\n        AnyRoute, // TParentRoute\n        RootRouteId, // TCustomId\n        '', // TPath\n        TSearchSchema, // TSearchSchema\n        TSearchSchema, // TFullSearchSchema\n        {}, // TParams\n        {}, // TAllParams\n        TRouteContext, // TRouteContext\n        Assign<TRouterContext, TRouteContext>, // TAllContext\n        TLoaderDeps,\n        TLoaderData // TLoaderData,\n      >,\n      | 'path'\n      | 'id'\n      | 'getParentRoute'\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n    >,\n  ): RootRoute<TSearchSchema, TRouteContext, TRouterContext> => {\n    return new RootRoute(options) as any\n  }\n}\n\nexport class RootRoute<\n  TSearchSchema extends Record<string, any> = {},\n  TRouteContext extends RouteContext = RouteContext,\n  TRouterContext extends {} = {},\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderData extends any = unknown,\n> extends Route<\n  any, // TParentRoute\n  '/', // TPath\n  '/', // TFullPath\n  string, // TCustomId\n  RootRouteId, // TId\n  TSearchSchema, // TSearchSchema\n  TSearchSchema, // TFullSearchSchema\n  {}, // TParams\n  {}, // TAllParams\n  TRouteContext, // TRouteContext\n  Expand<Assign<TRouterContext, TRouteContext>>, // TAllContext\n  TRouterContext, // TRouterContext\n  TLoaderDeps,\n  TLoaderData,\n  any, // TChildren\n  any // TRouteTree\n> {\n  constructor(\n    options?: Omit<\n      RouteOptions<\n        AnyRoute, // TParentRoute\n        RootRouteId, // TCustomId\n        '', // TPath\n        TSearchSchema, // TSearchSchema\n        TSearchSchema, // TFullSearchSchema\n        {}, // TParams\n        {}, // TAllParams\n        TRouteContext, // TRouteContext\n        Assign<TRouterContext, TRouteContext>, // TAllContext\n        TLoaderDeps,\n        TLoaderData\n      >,\n      | 'path'\n      | 'id'\n      | 'getParentRoute'\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n    >,\n  ) {\n    super(options as any)\n  }\n}\n\nexport type ResolveFullPath<\n  TParentRoute extends AnyRoute,\n  TPath extends string,\n  TPrefixed = RoutePrefix<TParentRoute['fullPath'], TPath>,\n> = TPrefixed extends RootRouteId ? '/' : TPrefixed\n\ntype RoutePrefix<\n  TPrefix extends string,\n  TPath extends string,\n> = string extends TPath\n  ? RootRouteId\n  : TPath extends string\n    ? TPrefix extends RootRouteId\n      ? TPath extends '/'\n        ? '/'\n        : `/${TrimPath<TPath>}`\n      : `${TPrefix}/${TPath}` extends '/'\n        ? '/'\n        : `/${TrimPathLeft<`${TrimPathRight<TPrefix>}/${TrimPath<TPath>}`>}`\n    : never\n\nexport type TrimPath<T extends string> = '' extends T\n  ? ''\n  : TrimPathRight<TrimPathLeft<T>>\n\nexport type TrimPathLeft<T extends string> =\n  T extends `${RootRouteId}/${infer U}`\n    ? TrimPathLeft<U>\n    : T extends `/${infer U}`\n      ? TrimPathLeft<U>\n      : T\nexport type TrimPathRight<T extends string> = T extends '/'\n  ? '/'\n  : T extends `${infer U}/`\n    ? TrimPathRight<U>\n    : T\n\nexport type RouteMask<TRouteTree extends AnyRoute> = {\n  routeTree: TRouteTree\n  from: RoutePaths<TRouteTree>\n  to?: any\n  params?: any\n  search?: any\n  hash?: any\n  state?: any\n  unmaskOnReload?: boolean\n}\n\nexport function createRouteMask<\n  TRouteTree extends AnyRoute,\n  TFrom extends RoutePaths<TRouteTree>,\n  TTo extends string,\n>(\n  opts: {\n    routeTree: TRouteTree\n  } & ToSubOptions<TRouteTree, TFrom, TTo>,\n): RouteMask<TRouteTree> {\n  return opts as any\n}\n\nexport type ErrorRouteProps = {\n  error: unknown\n  info: { componentStack: string }\n}\n//\n\nexport type ReactNode = any\n\nexport type SyncRouteComponent<TProps> =\n  | ((props: TProps) => ReactNode)\n  | React.LazyExoticComponent<(props: TProps) => ReactNode>\n\nexport type AsyncRouteComponent<TProps> = SyncRouteComponent<TProps> & {\n  preload?: () => Promise<void>\n}\n\nexport type RouteComponent<TProps = any> = SyncRouteComponent<TProps> &\n  AsyncRouteComponent<TProps>\n\nexport type ErrorRouteComponent = RouteComponent<ErrorRouteProps>\n\nexport class NotFoundRoute<\n  TParentRoute extends AnyRootRoute,\n  TSearchSchema extends RouteConstraints['TSearchSchema'] = {},\n  TFullSearchSchema extends\n    RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchema<\n    TParentRoute,\n    TSearchSchema\n  >,\n  TRouteContext extends RouteConstraints['TRouteContext'] = RouteContext,\n  TAllContext extends Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  > = Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  >,\n  TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderData extends any = unknown,\n  TChildren extends RouteConstraints['TChildren'] = unknown,\n  TRouteTree extends RouteConstraints['TRouteTree'] = AnyRoute,\n> extends Route<\n  TParentRoute,\n  '/404',\n  '/404',\n  '404',\n  '404',\n  TSearchSchema,\n  TFullSearchSchema,\n  {},\n  {},\n  TRouteContext,\n  TAllContext,\n  TRouterContext,\n  TLoaderDeps,\n  TLoaderData,\n  TChildren,\n  TRouteTree\n> {\n  constructor(\n    options: Omit<\n      RouteOptions<\n        TParentRoute,\n        string,\n        string,\n        TSearchSchema,\n        TFullSearchSchema,\n        {},\n        {},\n        TRouteContext,\n        TAllContext,\n        TLoaderDeps,\n        TLoaderData\n      >,\n      'caseSensitive' | 'parseParams' | 'stringifyParams' | 'path' | 'id'\n    >,\n  ) {\n    super({\n      ...(options as any),\n      id: '404',\n    })\n  }\n}\n","import { ParsePathParams } from './link'\nimport {\n  AnyRoute,\n  ResolveFullPath,\n  ResolveFullSearchSchema,\n  MergeFromFromParent,\n  RouteContext,\n  AnyContext,\n  RouteOptions,\n  UpdatableRouteOptions,\n  Route,\n  AnyPathParams,\n  RootRouteId,\n  TrimPathLeft,\n  RouteConstraints,\n} from './route'\nimport { Assign, Expand, IsAny } from './utils'\n\nexport interface FileRoutesByPath {\n  // '/': {\n  //   parentRoute: typeof rootRoute\n  // }\n}\n\ntype Replace<\n  S extends string,\n  From extends string,\n  To extends string,\n> = S extends `${infer Start}${From}${infer Rest}`\n  ? `${Start}${To}${Replace<Rest, From, To>}`\n  : S\n\nexport type TrimLeft<\n  T extends string,\n  S extends string,\n> = T extends `${S}${infer U}` ? U : T\n\nexport type TrimRight<\n  T extends string,\n  S extends string,\n> = T extends `${infer U}${S}` ? U : T\n\nexport type Trim<T extends string, S extends string> = TrimLeft<\n  TrimRight<T, S>,\n  S\n>\n\nexport type RemoveUnderScores<T extends string> = Replace<\n  Replace<TrimRight<TrimLeft<T, '/_'>, '_'>, '_/', '/'>,\n  '/_',\n  '/'\n>\n\nexport type ResolveFilePath<\n  TParentRoute extends AnyRoute,\n  TFilePath extends string,\n> = TParentRoute['id'] extends RootRouteId\n  ? TrimPathLeft<TFilePath>\n  : Replace<\n      TrimPathLeft<TFilePath>,\n      TrimPathLeft<TParentRoute['types']['customId']>,\n      ''\n    >\n\nexport type FileRoutePath<\n  TParentRoute extends AnyRoute,\n  TFilePath extends string,\n> = ResolveFilePath<TParentRoute, TFilePath> extends `_${infer _}`\n  ? string\n  : ResolveFilePath<TParentRoute, TFilePath>\n\nexport class FileRoute<\n  TFilePath extends keyof FileRoutesByPath,\n  TParentRoute extends AnyRoute = FileRoutesByPath[TFilePath]['parentRoute'],\n  TId extends RouteConstraints['TId'] = TFilePath,\n  TPath extends RouteConstraints['TPath'] = FileRoutePath<\n    TParentRoute,\n    TFilePath\n  >,\n  TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\n    TParentRoute,\n    RemoveUnderScores<TPath>\n  >,\n> {\n  constructor(public path: TFilePath) {}\n\n  createRoute = <\n    TSearchSchema extends RouteConstraints['TSearchSchema'] = {},\n    TFullSearchSchema extends\n      RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchema<\n      TParentRoute,\n      TSearchSchema\n    >,\n    TParams extends RouteConstraints['TParams'] = Expand<\n      Record<ParsePathParams<TPath>, string>\n    >,\n    TAllParams extends RouteConstraints['TAllParams'] = MergeFromFromParent<\n      TParentRoute['types']['allParams'],\n      TParams\n    >,\n    TRouteContext extends RouteConstraints['TRouteContext'] = RouteContext,\n    TContext extends Expand<\n      Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n    > = Expand<\n      Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n    >,\n    TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n    TLoaderDeps extends Record<string, any> = {},\n    TLoaderData extends any = unknown,\n    TChildren extends RouteConstraints['TChildren'] = unknown,\n    TRouteTree extends RouteConstraints['TRouteTree'] = AnyRoute,\n  >(\n    options?: Omit<\n      RouteOptions<\n        TParentRoute,\n        string,\n        TPath,\n        TSearchSchema,\n        TFullSearchSchema,\n        TParams,\n        TAllParams,\n        TRouteContext,\n        TContext,\n        TLoaderDeps,\n        TLoaderData\n      >,\n      'getParentRoute' | 'path' | 'id'\n    > &\n      UpdatableRouteOptions<TFullSearchSchema>,\n  ): Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TFilePath,\n    TId,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContext,\n    TContext,\n    TRouterContext,\n    TLoaderDeps,\n    TLoaderData,\n    TChildren,\n    TRouteTree\n  > => {\n    const route = new Route(options as any)\n    ;(route as any).isRoot = false\n    return route as any\n  }\n}\n","import * as React from 'react'\nimport { AsyncRouteComponent } from './route'\n\nexport function lazyRouteComponent<\n  T extends Record<string, any>,\n  TKey extends keyof T = 'default',\n>(\n  importer: () => Promise<T>,\n  exportName?: TKey,\n): T[TKey] extends (props: infer TProps) => any\n  ? AsyncRouteComponent<TProps>\n  : never {\n  let loadPromise: Promise<any>\n\n  const load = () => {\n    if (!loadPromise) {\n      loadPromise = importer()\n    }\n\n    return loadPromise\n  }\n\n  const lazyComp = React.lazy(async () => {\n    const moduleExports = await load()\n    const comp = moduleExports[exportName ?? 'default']\n    return {\n      default: comp,\n    }\n  })\n  ;(lazyComp as any).preload = load\n\n  return lazyComp as any\n}\n","import * as React from 'react'\nimport { useMatch } from './Matches'\nimport { useRouter, useRouterState } from './RouterProvider'\nimport { Trim } from './fileRoute'\nimport { AnyRoute, ReactNode } from './route'\nimport {\n  AllParams,\n  FullSearchSchema,\n  RouteByPath,\n  RouteIds,\n  RoutePaths,\n} from './routeInfo'\nimport { RegisteredRouter } from './router'\nimport { LinkProps, UseLinkPropsOptions } from './useNavigate'\nimport {\n  Expand,\n  NoInfer,\n  NonNullableUpdater,\n  PickRequired,\n  UnionToIntersection,\n  Updater,\n  deepEqual,\n  functionalUpdate,\n} from './utils'\nimport { HistoryState } from '@tanstack/history'\n\nexport type CleanPath<T extends string> = T extends `${infer L}//${infer R}`\n  ? CleanPath<`${CleanPath<L>}/${CleanPath<R>}`>\n  : T extends `${infer L}//`\n    ? `${CleanPath<L>}/`\n    : T extends `//${infer L}`\n      ? `/${CleanPath<L>}`\n      : T\n\nexport type Split<S, TIncludeTrailingSlash = true> = S extends unknown\n  ? string extends S\n    ? string[]\n    : S extends string\n      ? CleanPath<S> extends ''\n        ? []\n        : TIncludeTrailingSlash extends true\n          ? CleanPath<S> extends `${infer T}/`\n            ? [...Split<T>, '/']\n            : CleanPath<S> extends `/${infer U}`\n              ? Split<U>\n              : CleanPath<S> extends `${infer T}/${infer U}`\n                ? [...Split<T>, ...Split<U>]\n                : [S]\n          : CleanPath<S> extends `${infer T}/${infer U}`\n            ? [...Split<T>, ...Split<U>]\n            : S extends string\n              ? [S]\n              : never\n      : never\n  : never\n\nexport type ParsePathParams<T extends string> = keyof {\n  [K in Trim<Split<T>[number], '_'> as K extends `$${infer L}` ? L : never]: K\n}\n\nexport type Join<T, Delimiter extends string = '/'> = T extends []\n  ? ''\n  : T extends [infer L extends string]\n    ? L\n    : T extends [infer L extends string, ...infer Tail extends [...string[]]]\n      ? CleanPath<`${L}${Delimiter}${Join<Tail>}`>\n      : never\n\nexport type Last<T extends any[]> = T extends [...infer _, infer L] ? L : never\n\nexport type RelativeToPathAutoComplete<\n  AllPaths extends string,\n  TFrom extends string,\n  TTo extends string,\n  SplitPaths extends string[] = Split<AllPaths, false>,\n> = TTo extends `..${infer _}`\n  ? SplitPaths extends [\n      ...Split<ResolveRelativePath<TFrom, TTo>, false>,\n      ...infer TToRest,\n    ]\n    ? `${CleanPath<\n        Join<\n          [\n            ...Split<TTo, false>,\n            ...(\n              | TToRest\n              | (Split<\n                  ResolveRelativePath<TFrom, TTo>,\n                  false\n                >['length'] extends 1\n                  ? never\n                  : ['../'])\n            ),\n          ]\n        >\n      >}`\n    : never\n  : TTo extends `./${infer RestTTo}`\n    ? SplitPaths extends [\n        ...Split<TFrom, false>,\n        ...Split<RestTTo, false>,\n        ...infer RestPath,\n      ]\n      ? `${TTo}${Join<RestPath>}`\n      : never\n    :\n        | (TFrom extends `/`\n            ? never\n            : SplitPaths extends [...Split<TFrom, false>, ...infer RestPath]\n              ? Join<RestPath> extends { length: 0 }\n                ? never\n                : './'\n              : never)\n        | (TFrom extends `/` ? never : '../')\n        | AllPaths\n\nexport type NavigateOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n> = ToOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // `replace` is a boolean that determines whether the navigation should replace the current history entry or push a new one.\n  replace?: boolean\n  resetScroll?: boolean\n  // If set to `true`, the link's underlying navigate() call will be wrapped in a `React.startTransition` call. Defaults to `true`.\n  startTransition?: boolean\n}\n\nexport type ToOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ToSubOptions<TRouteTree, TFrom, TTo> & {\n  mask?: ToMaskOptions<TRouteTree, TMaskFrom, TMaskTo>\n}\n\nexport type ToMaskOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ToSubOptions<TRouteTree, TMaskFrom, TMaskTo> & {\n  unmaskOnReload?: boolean\n}\n\nexport type ToSubOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n> = {\n  to?: ToPathOption<TRouteTree, TFrom, TTo>\n  // The new has string or a function to update it\n  hash?: true | Updater<string>\n  // State to pass to the history stack\n  state?: true | NonNullableUpdater<HistoryState>\n  // The source route path. This is automatically set when using route-level APIs, but for type-safe relative routing on the router itself, this is required\n  from?: TFrom\n  // // When using relative route paths, this option forces resolution from the current path, instead of the route API's path or `from` path\n} & CheckPath<TRouteTree, NoInfer<TResolved>, {}> &\n  SearchParamOptions<TRouteTree, TFrom, TTo, TResolved> &\n  PathParamOptions<TRouteTree, TFrom, TResolved>\n\nexport type SearchParamOptions<\n  TRouteTree extends AnyRoute,\n  TFrom,\n  TTo,\n  TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n  TFromSearchEnsured = '/' extends TFrom\n    ? FullSearchSchema<TRouteTree>\n    : Expand<\n          PickRequired<\n            RouteByPath<TRouteTree, TFrom>['types']['fullSearchSchema']\n          >\n      >,\n  TFromSearchOptional = Omit<\n    FullSearchSchema<TRouteTree>,\n    keyof TFromSearchEnsured\n  >,\n  TFromSearch = Expand<TFromSearchEnsured & TFromSearchOptional>,\n  TToSearch = '' extends TTo\n    ? FullSearchSchema<TRouteTree>\n    : Expand<RouteByPath<TRouteTree, TResolved>['types']['fullSearchSchema']>,\n> = keyof PickRequired<TToSearch> extends never\n  ? {\n      search?: true | SearchReducer<TFromSearch, TToSearch>\n    }\n  : {\n      search: TFromSearchEnsured extends PickRequired<TToSearch>\n        ? true | SearchReducer<TFromSearch, TToSearch>\n        : SearchReducer<TFromSearch, TToSearch>\n    }\n\ntype SearchReducer<TFrom, TTo> = TTo | ((current: TFrom) => TTo)\n\nexport type PathParamOptions<\n  TRouteTree extends AnyRoute,\n  TFrom,\n  TTo,\n  TFromParamsEnsured = Expand<\n    UnionToIntersection<\n      PickRequired<RouteByPath<TRouteTree, TFrom>['types']['allParams']>\n    >\n  >,\n  TFromParamsOptional = Omit<AllParams<TRouteTree>, keyof TFromParamsEnsured>,\n  TFromParams = Expand<TFromParamsOptional & TFromParamsEnsured>,\n  TToParams = Expand<RouteByPath<TRouteTree, TTo>['types']['allParams']>,\n> = never extends TToParams\n  ? {\n      params?: true | ParamsReducer<Partial<TFromParams>, Partial<TFromParams>>\n    }\n  : keyof PickRequired<TToParams> extends never\n    ? {\n        params?: true | ParamsReducer<TFromParams, TToParams>\n      }\n    : {\n        params: TFromParamsEnsured extends PickRequired<TToParams>\n          ? true | ParamsReducer<TFromParams, TToParams>\n          : ParamsReducer<TFromParams, TToParams>\n      }\n\ntype ParamsReducer<TFrom, TTo> = TTo | ((current: TFrom) => TTo)\n\nexport type ToPathOption<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n> =\n  | TTo\n  | RelativeToPathAutoComplete<\n      RoutePaths<TRouteTree>,\n      NoInfer<TFrom> extends string ? NoInfer<TFrom> : '',\n      NoInfer<TTo> & string\n    >\n\nexport type ToIdOption<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n> =\n  | TTo\n  | RelativeToPathAutoComplete<\n      RouteIds<TRouteTree>,\n      NoInfer<TFrom> extends string ? NoInfer<TFrom> : '',\n      NoInfer<TTo> & string\n    >\n\nexport interface ActiveOptions {\n  exact?: boolean\n  includeHash?: boolean\n  includeSearch?: boolean\n}\n\nexport type LinkOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n> = NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // The standard anchor tag target attribute\n  target?: HTMLAnchorElement['target']\n  // Defaults to `{ exact: false, includeHash: false }`\n  activeOptions?: ActiveOptions\n  // If set, will preload the linked route on hover and cache it for this many milliseconds in hopes that the user will eventually navigate there.\n  preload?: false | 'intent'\n  // Delay intent preloading by this many milliseconds. If the intent exits before this delay, the preload will be cancelled.\n  preloadDelay?: number\n  // If true, will render the link without the href attribute\n  disabled?: boolean\n}\n\nexport type CheckRelativePath<\n  TRouteTree extends AnyRoute,\n  TFrom,\n  TTo,\n> = TTo extends string\n  ? TFrom extends string\n    ? ResolveRelativePath<TFrom, TTo> extends RoutePaths<TRouteTree>\n      ? {}\n      : {\n          Error: `${TFrom} + ${TTo} resolves to ${ResolveRelativePath<\n            TFrom,\n            TTo\n          >}, which is not a valid route path.`\n          'Valid Route Paths': RoutePaths<TRouteTree>\n        }\n    : {}\n  : {}\n\nexport type CheckPath<TRouteTree extends AnyRoute, TPath, TPass> = Exclude<\n  TPath,\n  RoutePaths<TRouteTree>\n> extends never\n  ? TPass\n  : CheckPathError<TRouteTree, Exclude<TPath, RoutePaths<TRouteTree>>>\n\nexport type CheckPathError<TRouteTree extends AnyRoute, TInvalids> = {\n  to: RoutePaths<TRouteTree>\n}\n\nexport type CheckId<TRouteTree extends AnyRoute, TPath, TPass> = Exclude<\n  TPath,\n  RouteIds<TRouteTree>\n> extends never\n  ? TPass\n  : CheckIdError<TRouteTree, Exclude<TPath, RouteIds<TRouteTree>>>\n\nexport type CheckIdError<TRouteTree extends AnyRoute, TInvalids> = {\n  Error: `${TInvalids extends string\n    ? TInvalids\n    : never} is not a valid route ID.`\n  'Valid Route IDs': RouteIds<TRouteTree>\n}\n\nexport type ResolveRelativePath<TFrom, TTo = '.'> = TFrom extends string\n  ? TTo extends string\n    ? TTo extends '.'\n      ? TFrom\n      : TTo extends `./`\n        ? Join<[TFrom, '/']>\n        : TTo extends `./${infer TRest}`\n          ? ResolveRelativePath<TFrom, TRest>\n          : TTo extends `/${infer TRest}`\n            ? TTo\n            : Split<TTo> extends ['..', ...infer ToRest]\n              ? Split<TFrom> extends [...infer FromRest, infer FromTail]\n                ? ToRest extends ['/']\n                  ? Join<[...FromRest, '/']>\n                  : ResolveRelativePath<Join<FromRest>, Join<ToRest>>\n                : never\n              : Split<TTo> extends ['.', ...infer ToRest]\n                ? ToRest extends ['/']\n                  ? Join<[TFrom, '/']>\n                  : ResolveRelativePath<TFrom, Join<ToRest>>\n                : CleanPath<Join<['/', ...Split<TFrom>, ...Split<TTo>]>>\n    : never\n  : never\n\ntype LinkCurrentTargetElement = {\n  preloadTimeout?: null | ReturnType<typeof setTimeout>\n}\n\nconst preloadWarning = 'Error preloading route! â˜ï¸'\n\nexport function useLinkProps<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n>(\n  options: UseLinkPropsOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n): React.AnchorHTMLAttributes<HTMLAnchorElement> {\n  const router = useRouter()\n  const matchPathname = useMatch({\n    strict: false,\n    select: (s) => s.pathname,\n  })\n\n  const {\n    // custom props\n    children,\n    target,\n    activeProps = () => ({ className: 'active' }),\n    inactiveProps = () => ({}),\n    activeOptions,\n    disabled,\n    hash,\n    search,\n    params,\n    to,\n    state,\n    mask,\n    preload: userPreload,\n    preloadDelay: userPreloadDelay,\n    replace,\n    startTransition,\n    resetScroll,\n    // element props\n    style,\n    className,\n    onClick,\n    onFocus,\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart,\n    ...rest\n  } = options\n\n  // If this link simply reloads the current route,\n  // make sure it has a new key so it will trigger a data refresh\n\n  // If this `to` is a valid external URL, return\n  // null for LinkUtils\n\n  const dest = {\n    from: options.to ? matchPathname : undefined,\n    ...options,\n  }\n\n  let type: 'internal' | 'external' = 'internal'\n\n  try {\n    new URL(`${to}`)\n    type = 'external'\n  } catch {}\n\n  if (type === 'external') {\n    return {\n      href: to,\n    }\n  }\n\n  const next = router.buildLocation(dest as any)\n\n  const preload = userPreload ?? router.options.defaultPreload\n  const preloadDelay =\n    userPreloadDelay ?? router.options.defaultPreloadDelay ?? 0\n\n  const isActive = useRouterState({\n    select: (s) => {\n      // Compare path/hash for matches\n      const currentPathSplit = s.location.pathname.split('/')\n      const nextPathSplit = next.pathname.split('/')\n      const pathIsFuzzyEqual = nextPathSplit.every(\n        (d, i) => d === currentPathSplit[i],\n      )\n      // Combine the matches based on user router.options\n      const pathTest = activeOptions?.exact\n        ? s.location.pathname === next.pathname\n        : pathIsFuzzyEqual\n      const hashTest = activeOptions?.includeHash\n        ? s.location.hash === next.hash\n        : true\n      const searchTest =\n        activeOptions?.includeSearch ?? true\n          ? deepEqual(s.location.search, next.search, !activeOptions?.exact)\n          : true\n\n      // The final \"active\" test\n      return pathTest && hashTest && searchTest\n    },\n  })\n\n  // The click handler\n  const handleClick = (e: MouseEvent) => {\n    if (\n      !disabled &&\n      !isCtrlEvent(e) &&\n      !e.defaultPrevented &&\n      (!target || target === '_self') &&\n      e.button === 0\n    ) {\n      e.preventDefault()\n\n      // All is well? Navigate!\n      router.commitLocation({ ...next, replace, resetScroll, startTransition })\n    }\n  }\n\n  // The click handler\n  const handleFocus = (e: MouseEvent) => {\n    if (preload) {\n      router.preloadRoute(dest as any).catch((err) => {\n        console.warn(err)\n        console.warn(preloadWarning)\n      })\n    }\n  }\n\n  const handleTouchStart = (e: TouchEvent) => {\n    if (preload) {\n      router.preloadRoute(dest as any).catch((err) => {\n        console.warn(err)\n        console.warn(preloadWarning)\n      })\n    }\n  }\n\n  const handleEnter = (e: MouseEvent) => {\n    const target = (e.target || {}) as LinkCurrentTargetElement\n\n    if (preload) {\n      if (target.preloadTimeout) {\n        return\n      }\n\n      target.preloadTimeout = setTimeout(() => {\n        target.preloadTimeout = null\n        router.preloadRoute(dest as any).catch((err) => {\n          console.warn(err)\n          console.warn(preloadWarning)\n        })\n      }, preloadDelay)\n    }\n  }\n\n  const handleLeave = (e: MouseEvent) => {\n    const target = (e.target || {}) as LinkCurrentTargetElement\n\n    if (target.preloadTimeout) {\n      clearTimeout(target.preloadTimeout)\n      target.preloadTimeout = null\n    }\n  }\n\n  const composeHandlers =\n    (handlers: (undefined | ((e: any) => void))[]) =>\n    (e: React.SyntheticEvent) => {\n      if (e.persist) e.persist()\n      handlers.filter(Boolean).forEach((handler) => {\n        if (e.defaultPrevented) return\n        handler!(e)\n      })\n    }\n\n  // Get the active props\n  const resolvedActiveProps: React.HTMLAttributes<HTMLAnchorElement> = isActive\n    ? functionalUpdate(activeProps as any, {}) ?? {}\n    : {}\n\n  // Get the inactive props\n  const resolvedInactiveProps: React.HTMLAttributes<HTMLAnchorElement> =\n    isActive ? {} : functionalUpdate(inactiveProps, {}) ?? {}\n\n  return {\n    ...resolvedActiveProps,\n    ...resolvedInactiveProps,\n    ...rest,\n    href: disabled\n      ? undefined\n      : next.maskedLocation\n        ? next.maskedLocation.href\n        : next.href,\n    onClick: composeHandlers([onClick, handleClick]),\n    onFocus: composeHandlers([onFocus, handleFocus]),\n    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),\n    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),\n    onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),\n    target,\n    style: {\n      ...style,\n      ...resolvedActiveProps.style,\n      ...resolvedInactiveProps.style,\n    },\n    className:\n      [\n        className,\n        resolvedActiveProps.className,\n        resolvedInactiveProps.className,\n      ]\n        .filter(Boolean)\n        .join(' ') || undefined,\n    ...(disabled\n      ? {\n          role: 'link',\n          'aria-disabled': true,\n        }\n      : undefined),\n    ['data-status']: isActive ? 'active' : undefined,\n  }\n}\n\nexport interface LinkComponent<TProps extends Record<string, any> = {}> {\n  <\n    TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n    TFrom extends RoutePaths<TRouteTree> = '/',\n    TTo extends string = '',\n    TMaskFrom extends RoutePaths<TRouteTree> = '/',\n    TMaskTo extends string = '',\n  >(\n    props: LinkProps<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> &\n      TProps &\n      React.RefAttributes<HTMLAnchorElement>,\n  ): ReactNode\n}\n\nexport const Link: LinkComponent = React.forwardRef((props: any, ref) => {\n  const linkProps = useLinkProps(props)\n\n  return (\n    <a\n      {...{\n        ref: ref as any,\n        ...linkProps,\n        children:\n          typeof props.children === 'function'\n            ? props.children({\n                isActive: (linkProps as any)['data-status'] === 'active',\n              })\n            : props.children,\n      }}\n    />\n  )\n}) as any\n\nfunction isCtrlEvent(e: MouseEvent) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n}\n","// @ts-nocheck\n\n// qss has been slightly modified and inlined here for our use cases (and compression's sake). We've included it as a hard dependency for MIT license attribution.\n\nexport function encode(obj, pfx?: string) {\n  var k,\n    i,\n    tmp,\n    str = ''\n\n  for (k in obj) {\n    if ((tmp = obj[k]) !== void 0) {\n      if (Array.isArray(tmp)) {\n        for (i = 0; i < tmp.length; i++) {\n          str && (str += '&')\n          str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp[i])\n        }\n      } else {\n        str && (str += '&')\n        str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp)\n      }\n    }\n  }\n\n  return (pfx || '') + str\n}\n\nfunction toValue(mix) {\n  if (!mix) return ''\n  var str = decodeURIComponent(mix)\n  if (str === 'false') return false\n  if (str === 'true') return true\n  return +str * 0 === 0 && +str + '' === str ? +str : str\n}\n\nexport function decode(str) {\n  var tmp,\n    k,\n    out = {},\n    arr = str.split('&')\n\n  while ((tmp = arr.shift())) {\n    tmp = tmp.split('=')\n    k = tmp.shift()\n    if (out[k] !== void 0) {\n      out[k] = [].concat(out[k], toValue(tmp.shift()))\n    } else {\n      out[k] = toValue(tmp.shift())\n    }\n  }\n\n  return out\n}\n","import { NavigateOptions } from './link'\nimport { AnyRoute } from './route'\nimport { RoutePaths } from './routeInfo'\nimport { RegisteredRouter } from './router'\n\n// Detect if we're in the DOM\n\nexport type AnyRedirect = Redirect<any, any, any, any, any>\n\nexport type Redirect<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n> = {\n  code?: number\n  throw?: any\n} & NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>\n\nexport function redirect<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n>(\n  opts: Redirect<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n): Redirect<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> {\n  ;(opts as any).isRedirect = true\n  if (opts.throw) {\n    throw opts\n  }\n  return opts\n}\n\nexport function isRedirect(obj: any): obj is AnyRedirect {\n  return !!obj?.isRedirect\n}\n","import { decode, encode } from './qss'\nimport { AnySearchSchema } from './route'\n\nexport const defaultParseSearch = parseSearchWith(JSON.parse)\nexport const defaultStringifySearch = stringifySearchWith(\n  JSON.stringify,\n  JSON.parse,\n)\n\nexport function parseSearchWith(parser: (str: string) => any) {\n  return (searchStr: string): AnySearchSchema => {\n    if (searchStr.substring(0, 1) === '?') {\n      searchStr = searchStr.substring(1)\n    }\n\n    let query: Record<string, unknown> = decode(searchStr)\n\n    // Try to parse any query params that might be json\n    for (let key in query) {\n      const value = query[key]\n      if (typeof value === 'string') {\n        try {\n          query[key] = parser(value)\n        } catch (err) {\n          //\n        }\n      }\n    }\n\n    return query\n  }\n}\n\nexport function stringifySearchWith(\n  stringify: (search: any) => string,\n  parser?: (str: string) => any,\n) {\n  function stringifyValue(val: any) {\n    if (typeof val === 'object' && val !== null) {\n      try {\n        return stringify(val)\n      } catch (err) {\n        // silent\n      }\n    } else if (typeof val === 'string' && typeof parser === 'function') {\n      try {\n        // Check if it's a valid parseable string.\n        // If it is, then stringify it again.\n        parser(val)\n        return stringify(val)\n      } catch (err) {\n        // silent\n      }\n    }\n    return val\n  }\n\n  return (search: Record<string, any>) => {\n    search = { ...search }\n\n    if (search) {\n      Object.keys(search).forEach((key) => {\n        const val = search[key]\n        if (typeof val === 'undefined' || val === undefined) {\n          delete search[key]\n        } else {\n          search[key] = stringifyValue(val)\n        }\n      })\n    }\n\n    const searchStr = encode(search as Record<string, string>).toString()\n\n    return searchStr ? `?${searchStr}` : ''\n  }\n}\n\nexport type SearchSerializer = (searchObj: Record<string, any>) => string\nexport type SearchParser = (searchStr: string) => Record<string, any>\n","import {\n  HistoryLocation,\n  HistoryState,\n  RouterHistory,\n  createBrowserHistory,\n  createMemoryHistory,\n} from '@tanstack/history'\nimport { Store } from '@tanstack/store'\n\n//\n\nimport {\n  AnySearchSchema,\n  AnyRoute,\n  AnyContext,\n  AnyPathParams,\n  RouteMask,\n  Route,\n  LoaderFnContext,\n} from './route'\nimport { FullSearchSchema, RoutesById, RoutesByPath } from './routeInfo'\nimport { defaultParseSearch, defaultStringifySearch } from './searchParams'\nimport {\n  PickAsRequired,\n  Updater,\n  NonNullableUpdater,\n  replaceEqualDeep,\n  deepEqual,\n  escapeJSON,\n  functionalUpdate,\n  last,\n  pick,\n  Timeout,\n} from './utils'\nimport { RouteComponent } from './route'\nimport { AnyRouteMatch, RouteMatch } from './Matches'\nimport { ParsedLocation } from './location'\nimport { SearchSerializer, SearchParser } from './searchParams'\nimport {\n  BuildLocationFn,\n  CommitLocationOptions,\n  InjectedHtmlEntry,\n  MatchRouteFn,\n  NavigateFn,\n  getRouteMatch,\n} from './RouterProvider'\n\nimport {\n  cleanPath,\n  interpolatePath,\n  joinPaths,\n  matchPathname,\n  parsePathname,\n  removeBasepath,\n  resolvePath,\n  trimPath,\n  trimPathLeft,\n  trimPathRight,\n} from './path'\nimport invariant from 'tiny-invariant'\nimport { isRedirect } from './redirects'\nimport { ToOptions } from './link'\n// import warning from 'tiny-warning'\n\n//\n\ndeclare global {\n  interface Window {\n    __TSR_DEHYDRATED__?: HydrationCtx\n    __TSR_ROUTER_CONTEXT__?: React.Context<Router<any>>\n  }\n}\n\nexport interface Register {\n  // router: Router\n}\n\nexport type AnyRouter = Router<AnyRoute, any>\n\nexport type RegisteredRouter = Register extends {\n  router: infer TRouter extends AnyRouter\n}\n  ? TRouter\n  : AnyRouter\n\nexport type HydrationCtx = {\n  router: DehydratedRouter\n  payload: Record<string, any>\n}\n\nexport type RouterContextOptions<TRouteTree extends AnyRoute> =\n  AnyContext extends TRouteTree['types']['routerContext']\n    ? {\n        context?: TRouteTree['types']['routerContext']\n      }\n    : {\n        context: TRouteTree['types']['routerContext']\n      }\n\nexport interface RouterOptions<\n  TRouteTree extends AnyRoute,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> {\n  history?: RouterHistory\n  stringifySearch?: SearchSerializer\n  parseSearch?: SearchParser\n  defaultPreload?: false | 'intent'\n  defaultPreloadDelay?: number\n  defaultComponent?: RouteComponent\n  defaultErrorComponent?: RouteComponent\n  defaultPendingComponent?: RouteComponent\n  defaultPendingMs?: number\n  defaultPendingMinMs?: number\n  defaultStaleTime?: number\n  defaultPreloadStaleTime?: number\n  defaultPreloadGcTime?: number\n  defaultGcTime?: number\n  caseSensitive?: boolean\n  routeTree?: TRouteTree\n  basepath?: string\n  context?: TRouteTree['types']['routerContext']\n  dehydrate?: () => TDehydrated\n  hydrate?: (dehydrated: TDehydrated) => void\n  routeMasks?: RouteMask<TRouteTree>[]\n  unmaskOnReload?: boolean\n  Wrap?: (props: { children: any }) => JSX.Element\n  InnerWrap?: (props: { children: any }) => JSX.Element\n  notFoundRoute?: AnyRoute\n}\n\nexport interface RouterState<TRouteTree extends AnyRoute = AnyRoute> {\n  status: 'pending' | 'idle'\n  isLoading: boolean\n  isTransitioning: boolean\n  matches: RouteMatch<TRouteTree>[]\n  pendingMatches?: RouteMatch<TRouteTree>[]\n  cachedMatches: RouteMatch<TRouteTree>[]\n  location: ParsedLocation<FullSearchSchema<TRouteTree>>\n  resolvedLocation: ParsedLocation<FullSearchSchema<TRouteTree>>\n  lastUpdated: number\n}\n\nexport type ListenerFn<TEvent extends RouterEvent> = (event: TEvent) => void\n\nexport interface BuildNextOptions {\n  to?: string | number | null\n  params?: true | Updater<unknown>\n  search?: true | Updater<unknown>\n  hash?: true | Updater<string>\n  state?: true | NonNullableUpdater<HistoryState>\n  mask?: {\n    to?: string | number | null\n    params?: true | Updater<unknown>\n    search?: true | Updater<unknown>\n    hash?: true | Updater<string>\n    state?: true | NonNullableUpdater<HistoryState>\n    unmaskOnReload?: boolean\n  }\n  from?: string\n}\n\nexport interface DehydratedRouterState {\n  dehydratedMatches: DehydratedRouteMatch[]\n}\n\nexport type DehydratedRouteMatch = Pick<\n  RouteMatch,\n  'id' | 'status' | 'updatedAt'\n>\n\nexport interface DehydratedRouter {\n  state: DehydratedRouterState\n}\n\nexport type RouterConstructorOptions<\n  TRouteTree extends AnyRoute,\n  TDehydrated extends Record<string, any>,\n> = Omit<RouterOptions<TRouteTree, TDehydrated>, 'context'> &\n  RouterContextOptions<TRouteTree>\n\nexport const componentTypes = [\n  'component',\n  'errorComponent',\n  'pendingComponent',\n] as const\n\nexport type RouterEvents = {\n  onBeforeLoad: {\n    type: 'onBeforeLoad'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n  onLoad: {\n    type: 'onLoad'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n  onResolved: {\n    type: 'onResolved'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n}\n\nexport type RouterEvent = RouterEvents[keyof RouterEvents]\n\nexport type RouterListener<TRouterEvent extends RouterEvent> = {\n  eventType: TRouterEvent['type']\n  fn: ListenerFn<TRouterEvent>\n}\n\nexport class Router<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> {\n  // Option-independent properties\n  tempLocationKey: string | undefined = `${Math.round(\n    Math.random() * 10000000,\n  )}`\n  resetNextScroll: boolean = true\n  navigateTimeout: Timeout | null = null\n  latestLoadPromise: Promise<void> = Promise.resolve()\n  subscribers = new Set<RouterListener<RouterEvent>>()\n  injectedHtml: InjectedHtmlEntry[] = []\n  dehydratedData?: TDehydrated\n\n  // Must build in constructor\n  __store!: Store<RouterState<TRouteTree>>\n  options!: PickAsRequired<\n    RouterOptions<TRouteTree, TDehydrated>,\n    'stringifySearch' | 'parseSearch' | 'context'\n  >\n  history!: RouterHistory\n  latestLocation!: ParsedLocation\n  basepath!: string\n  routeTree!: TRouteTree\n  routesById!: RoutesById<TRouteTree>\n  routesByPath!: RoutesByPath<TRouteTree>\n  flatRoutes!: AnyRoute[]\n\n  constructor(options: RouterConstructorOptions<TRouteTree, TDehydrated>) {\n    this.update({\n      defaultPreloadDelay: 50,\n      defaultPendingMs: 1000,\n      defaultPendingMinMs: 500,\n      context: undefined!,\n      ...options,\n      stringifySearch: options?.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options?.parseSearch ?? defaultParseSearch,\n    })\n  }\n\n  // These are default implementations that can optionally be overridden\n  // by the router provider once rendered. We provide these so that the\n  // router can be used in a non-react environment if necessary\n  startReactTransition: (fn: () => void) => void = (fn) => fn()\n\n  update = (newOptions: RouterConstructorOptions<TRouteTree, TDehydrated>) => {\n    this.options = {\n      ...this.options,\n      ...newOptions,\n    }\n\n    this.basepath = `/${trimPath(newOptions.basepath ?? '') ?? ''}`\n\n    if (\n      !this.history ||\n      (this.options.history && this.options.history !== this.history)\n    ) {\n      this.history =\n        this.options.history ??\n        (typeof document !== 'undefined'\n          ? createBrowserHistory()\n          : createMemoryHistory())\n      this.latestLocation = this.parseLocation()\n    }\n\n    if (this.options.routeTree !== this.routeTree) {\n      this.routeTree = this.options.routeTree as TRouteTree\n      this.buildRouteTree()\n    }\n\n    if (!this.__store) {\n      this.__store = new Store(getInitialRouterState(this.latestLocation), {\n        onUpdate: () => {\n          this.__store.state = {\n            ...this.state,\n            status:\n              this.state.isTransitioning || this.state.isLoading\n                ? 'pending'\n                : 'idle',\n          }\n        },\n      })\n    }\n  }\n\n  get state() {\n    return this.__store.state\n  }\n\n  buildRouteTree = () => {\n    this.routesById = {} as RoutesById<TRouteTree>\n    this.routesByPath = {} as RoutesByPath<TRouteTree>\n\n    const notFoundRoute = this.options.notFoundRoute\n    if (notFoundRoute) {\n      notFoundRoute.init({ originalIndex: 99999999999 })\n      ;(this.routesById as any)[notFoundRoute.id] = notFoundRoute\n    }\n\n    const recurseRoutes = (childRoutes: AnyRoute[]) => {\n      childRoutes.forEach((childRoute, i) => {\n        childRoute.init({ originalIndex: i })\n\n        const existingRoute = (this.routesById as any)[childRoute.id]\n\n        invariant(\n          !existingRoute,\n          `Duplicate routes found with id: ${String(childRoute.id)}`,\n        )\n        ;(this.routesById as any)[childRoute.id] = childRoute\n\n        if (!childRoute.isRoot && childRoute.path) {\n          const trimmedFullPath = trimPathRight(childRoute.fullPath)\n          if (\n            !(this.routesByPath as any)[trimmedFullPath] ||\n            childRoute.fullPath.endsWith('/')\n          ) {\n            ;(this.routesByPath as any)[trimmedFullPath] = childRoute\n          }\n        }\n\n        const children = childRoute.children as Route[]\n\n        if (children?.length) {\n          recurseRoutes(children)\n        }\n      })\n    }\n\n    recurseRoutes([this.routeTree])\n\n    const scoredRoutes: {\n      child: AnyRoute\n      trimmed: string\n      parsed: ReturnType<typeof parsePathname>\n      index: number\n      scores: number[]\n    }[] = []\n\n    ;(Object.values(this.routesById) as AnyRoute[]).forEach((d, i) => {\n      if (d.isRoot || !d.path) {\n        return\n      }\n\n      const trimmed = trimPathLeft(d.fullPath)\n      const parsed = parsePathname(trimmed)\n\n      while (parsed.length > 1 && parsed[0]?.value === '/') {\n        parsed.shift()\n      }\n\n      const scores = parsed.map((d) => {\n        if (d.value === '/') {\n          return 0.75\n        }\n\n        if (d.type === 'param') {\n          return 0.5\n        }\n\n        if (d.type === 'wildcard') {\n          return 0.25\n        }\n\n        return 1\n      })\n\n      scoredRoutes.push({ child: d, trimmed, parsed, index: i, scores })\n    })\n\n    this.flatRoutes = scoredRoutes\n      .sort((a, b) => {\n        const minLength = Math.min(a.scores.length, b.scores.length)\n\n        // Sort by min available score\n        for (let i = 0; i < minLength; i++) {\n          if (a.scores[i] !== b.scores[i]) {\n            return b.scores[i]! - a.scores[i]!\n          }\n        }\n\n        // Sort by length of score\n        if (a.scores.length !== b.scores.length) {\n          return b.scores.length - a.scores.length\n        }\n\n        // Sort by min available parsed value\n        for (let i = 0; i < minLength; i++) {\n          if (a.parsed[i]!.value !== b.parsed[i]!.value) {\n            return a.parsed[i]!.value! > b.parsed[i]!.value! ? 1 : -1\n          }\n        }\n\n        // Sort by original index\n        return a.index - b.index\n      })\n      .map((d, i) => {\n        d.child.rank = i\n        return d.child\n      })\n  }\n\n  subscribe = <TType extends keyof RouterEvents>(\n    eventType: TType,\n    fn: ListenerFn<RouterEvents[TType]>,\n  ) => {\n    const listener: RouterListener<any> = {\n      eventType,\n      fn,\n    }\n\n    this.subscribers.add(listener)\n\n    return () => {\n      this.subscribers.delete(listener)\n    }\n  }\n\n  emit = (routerEvent: RouterEvent) => {\n    this.subscribers.forEach((listener) => {\n      if (listener.eventType === routerEvent.type) {\n        listener.fn(routerEvent)\n      }\n    })\n  }\n\n  checkLatest = (promise: Promise<void>): undefined | Promise<void> => {\n    return this.latestLoadPromise !== promise\n      ? this.latestLoadPromise\n      : undefined\n  }\n\n  parseLocation = (\n    previousLocation?: ParsedLocation,\n  ): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n    const parse = ({\n      pathname,\n      search,\n      hash,\n      state,\n    }: HistoryLocation): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n      const parsedSearch = this.options.parseSearch(search)\n\n      return {\n        pathname: pathname,\n        searchStr: search,\n        search: replaceEqualDeep(previousLocation?.search, parsedSearch) as any,\n        hash: hash.split('#').reverse()[0] ?? '',\n        href: `${pathname}${search}${hash}`,\n        state: replaceEqualDeep(previousLocation?.state, state) as HistoryState,\n      }\n    }\n\n    const location = parse(this.history.location)\n\n    let { __tempLocation, __tempKey } = location.state\n\n    if (__tempLocation && (!__tempKey || __tempKey === this.tempLocationKey)) {\n      // Sync up the location keys\n      const parsedTempLocation = parse(__tempLocation) as any\n      parsedTempLocation.state.key = location.state.key\n\n      delete parsedTempLocation.state.__tempLocation\n\n      return {\n        ...parsedTempLocation,\n        maskedLocation: location,\n      }\n    }\n\n    return location\n  }\n\n  resolvePathWithBase = (from: string, path: string) => {\n    return resolvePath(this.basepath!, from, cleanPath(path))\n  }\n\n  get looseRoutesById() {\n    return this.routesById as Record<string, AnyRoute>\n  }\n\n  matchRoutes = <TRouteTree extends AnyRoute>(\n    pathname: string,\n    locationSearch: AnySearchSchema,\n    opts?: { throwOnError?: boolean; debug?: boolean },\n  ): RouteMatch<TRouteTree>[] => {\n    let routeParams: Record<string, string> = {}\n\n    let foundRoute = this.flatRoutes.find((route) => {\n      const matchedParams = matchPathname(\n        this.basepath,\n        trimPathRight(pathname),\n        {\n          to: route.fullPath,\n          caseSensitive:\n            route.options.caseSensitive ?? this.options.caseSensitive,\n          fuzzy: true,\n        },\n      )\n\n      if (matchedParams) {\n        routeParams = matchedParams\n        return true\n      }\n\n      return false\n    })\n\n    let routeCursor: AnyRoute =\n      foundRoute || (this.routesById as any)['__root__']\n\n    let matchedRoutes: AnyRoute[] = [routeCursor]\n\n    // Check to see if the route needs a 404 entry\n    if (\n      // If we found a route, and it's not an index route and we have left over path\n      (foundRoute\n        ? foundRoute.path !== '/' && routeParams['**']\n        : // Or if we didn't find a route and we have left over path\n          trimPathRight(pathname)) &&\n      // And we have a 404 route configured\n      this.options.notFoundRoute\n    ) {\n      matchedRoutes.push(this.options.notFoundRoute)\n    }\n\n    while (routeCursor?.parentRoute) {\n      routeCursor = routeCursor.parentRoute\n      if (routeCursor) matchedRoutes.unshift(routeCursor)\n    }\n\n    // Existing matches are matches that are already loaded along with\n    // pending matches that are still loading\n\n    const parseErrors = matchedRoutes.map((route) => {\n      let parsedParamsError\n\n      if (route.options.parseParams) {\n        try {\n          const parsedParams = route.options.parseParams(routeParams)\n          // Add the parsed params to the accumulated params bag\n          Object.assign(routeParams, parsedParams)\n        } catch (err: any) {\n          parsedParamsError = new PathParamError(err.message, {\n            cause: err,\n          })\n\n          if (opts?.throwOnError) {\n            throw parsedParamsError\n          }\n\n          return parsedParamsError\n        }\n      }\n\n      return\n    })\n\n    const matches: AnyRouteMatch[] = []\n\n    matchedRoutes.forEach((route, index) => {\n      // Take each matched route and resolve + validate its search params\n      // This has to happen serially because each route's search params\n      // can depend on the parent route's search params\n      // It must also happen before we create the match so that we can\n      // pass the search params to the route's potential key function\n      // which is used to uniquely identify the route match in state\n\n      const parentMatch = matches[index - 1]\n\n      const [preMatchSearch, searchError]: [Record<string, any>, any] = (() => {\n        // Validate the search params and stabilize them\n        const parentSearch = parentMatch?.search ?? locationSearch\n\n        try {\n          const validator =\n            typeof route.options.validateSearch === 'object'\n              ? route.options.validateSearch.parse\n              : route.options.validateSearch\n\n          let search = validator?.(parentSearch) ?? {}\n\n          return [\n            {\n              ...parentSearch,\n              ...search,\n            },\n            undefined,\n          ]\n        } catch (err: any) {\n          const searchError = new SearchParamError(err.message, {\n            cause: err,\n          })\n\n          if (opts?.throwOnError) {\n            throw searchError\n          }\n\n          return [parentSearch, searchError]\n        }\n      })()\n\n      // This is where we need to call route.options.loaderDeps() to get any additional\n      // deps that the route's loader function might need to run. We need to do this\n      // before we create the match so that we can pass the deps to the route's\n      // potential key function which is used to uniquely identify the route match in state\n\n      const loaderDeps =\n        route.options.loaderDeps?.({\n          search: preMatchSearch,\n        }) ?? ''\n\n      const loaderDepsHash = loaderDeps ? JSON.stringify(loaderDeps) : ''\n\n      const interpolatedPath = interpolatePath(route.fullPath, routeParams)\n      const matchId =\n        interpolatePath(route.id, routeParams, true) + loaderDepsHash\n\n      // Waste not, want not. If we already have a match for this route,\n      // reuse it. This is important for layout routes, which might stick\n      // around between navigation actions that only change leaf routes.\n      const existingMatch = getRouteMatch(this.state, matchId)\n\n      const cause = this.state.matches.find((d) => d.id === matchId)\n        ? 'stay'\n        : 'enter'\n\n      // Create a fresh route match\n      const hasLoaders = !!(\n        route.options.loader ||\n        componentTypes.some((d) => (route.options[d] as any)?.preload)\n      )\n\n      const match: AnyRouteMatch = existingMatch\n        ? { ...existingMatch, cause }\n        : {\n            id: matchId,\n            routeId: route.id,\n            params: routeParams,\n            pathname: joinPaths([this.basepath, interpolatedPath]),\n            updatedAt: Date.now(),\n            search: {} as any,\n            searchError: undefined,\n            status: hasLoaders ? 'pending' : 'success',\n            showPending: false,\n            isFetching: false,\n            error: undefined,\n            paramsError: parseErrors[index],\n            loadPromise: Promise.resolve(),\n            routeContext: undefined!,\n            context: undefined!,\n            abortController: new AbortController(),\n            fetchCount: 0,\n            cause,\n            loaderDeps,\n            invalid: false,\n            preload: false,\n          }\n\n      // Regardless of whether we're reusing an existing match or creating\n      // a new one, we need to update the match's search params\n      match.search = replaceEqualDeep(match.search, preMatchSearch)\n      // And also update the searchError if there is one\n      match.searchError = searchError\n\n      matches.push(match)\n    })\n\n    return matches as any\n  }\n\n  cancelMatch = (id: string) => {\n    getRouteMatch(this.state, id)?.abortController?.abort()\n  }\n\n  cancelMatches = () => {\n    this.state.pendingMatches?.forEach((match) => {\n      this.cancelMatch(match.id)\n    })\n  }\n\n  buildLocation: BuildLocationFn<TRouteTree> = (opts) => {\n    const build = (\n      dest: BuildNextOptions & {\n        unmaskOnReload?: boolean\n      } = {},\n      matches?: AnyRouteMatch[],\n    ): ParsedLocation => {\n      const from = this.latestLocation\n      const fromSearch =\n        (this.state.pendingMatches || this.state.matches).at(-1)?.search ||\n        from.search\n      const fromPathname = dest.from ?? from.pathname\n\n      let pathname = this.resolvePathWithBase(fromPathname, `${dest.to ?? ''}`)\n\n      const fromMatches = this.matchRoutes(fromPathname, fromSearch)\n      const stayingMatches = matches?.filter(\n        (d) => fromMatches?.find((e) => e.routeId === d.routeId),\n      )\n\n      const prevParams = { ...last(fromMatches)?.params }\n\n      let nextParams =\n        (dest.params ?? true) === true\n          ? prevParams\n          : functionalUpdate(dest.params!, prevParams)\n\n      if (nextParams) {\n        matches\n          ?.map((d) => this.looseRoutesById[d.routeId]!.options.stringifyParams)\n          .filter(Boolean)\n          .forEach((fn) => {\n            nextParams = { ...nextParams!, ...fn!(nextParams!) }\n          })\n      }\n\n      pathname = interpolatePath(pathname, nextParams ?? {})\n\n      const preSearchFilters =\n        stayingMatches\n          ?.map(\n            (match) =>\n              this.looseRoutesById[match.routeId]!.options.preSearchFilters ??\n              [],\n          )\n          .flat()\n          .filter(Boolean) ?? []\n\n      const postSearchFilters =\n        stayingMatches\n          ?.map(\n            (match) =>\n              this.looseRoutesById[match.routeId]!.options.postSearchFilters ??\n              [],\n          )\n          .flat()\n          .filter(Boolean) ?? []\n\n      // Pre filters first\n      const preFilteredSearch = preSearchFilters?.length\n        ? preSearchFilters?.reduce(\n            (prev, next) => next(prev) as any,\n            fromSearch,\n          )\n        : fromSearch\n\n      // Then the link/navigate function\n      const destSearch =\n        dest.search === true\n          ? preFilteredSearch // Preserve resolvedFrom true\n          : dest.search\n            ? functionalUpdate(dest.search, preFilteredSearch) ?? {} // Updater\n            : preSearchFilters?.length\n              ? preFilteredSearch // Preserve resolvedFrom filters\n              : {}\n\n      // Then post filters\n      const postFilteredSearch = postSearchFilters?.length\n        ? postSearchFilters.reduce((prev, next) => next(prev), destSearch)\n        : destSearch\n\n      const search = replaceEqualDeep(fromSearch, postFilteredSearch)\n\n      const searchStr = this.options.stringifySearch(search)\n\n      const hash =\n        dest.hash === true\n          ? from.hash\n          : dest.hash\n            ? functionalUpdate(dest.hash!, from.hash)\n            : from.hash\n\n      const hashStr = hash ? `#${hash}` : ''\n\n      let nextState =\n        dest.state === true\n          ? from.state\n          : dest.state\n            ? functionalUpdate(dest.state, from.state)\n            : from.state\n\n      nextState = replaceEqualDeep(from.state, nextState)\n\n      return {\n        pathname,\n        search,\n        searchStr,\n        state: nextState as any,\n        hash,\n        href: `${pathname}${searchStr}${hashStr}`,\n        unmaskOnReload: dest.unmaskOnReload,\n      }\n    }\n\n    const buildWithMatches = (\n      dest: BuildNextOptions = {},\n      maskedDest?: BuildNextOptions,\n    ) => {\n      let next = build(dest)\n      let maskedNext = maskedDest ? build(maskedDest) : undefined\n\n      if (!maskedNext) {\n        let params = {}\n\n        let foundMask = this.options.routeMasks?.find((d) => {\n          const match = matchPathname(this.basepath, next.pathname, {\n            to: d.from,\n            caseSensitive: false,\n            fuzzy: false,\n          })\n\n          if (match) {\n            params = match\n            return true\n          }\n\n          return false\n        })\n\n        if (foundMask) {\n          foundMask = {\n            ...foundMask,\n            from: interpolatePath(foundMask.from, params) as any,\n          }\n          maskedDest = foundMask\n          maskedNext = build(maskedDest)\n        }\n      }\n\n      const nextMatches = this.matchRoutes(next.pathname, next.search)\n      const maskedMatches = maskedNext\n        ? this.matchRoutes(maskedNext.pathname, maskedNext.search)\n        : undefined\n      const maskedFinal = maskedNext\n        ? build(maskedDest, maskedMatches)\n        : undefined\n\n      const final = build(dest, nextMatches)\n\n      if (maskedFinal) {\n        final.maskedLocation = maskedFinal\n      }\n\n      return final\n    }\n\n    if (opts.mask) {\n      return buildWithMatches(opts, {\n        ...pick(opts, ['from']),\n        ...opts.mask,\n      })\n    }\n\n    return buildWithMatches(opts)\n  }\n\n  commitLocation = async ({\n    startTransition,\n    ...next\n  }: ParsedLocation & CommitLocationOptions) => {\n    if (this.navigateTimeout) clearTimeout(this.navigateTimeout)\n\n    const isSameUrl = this.latestLocation.href === next.href\n\n    // If the next urls are the same and we're not replacing,\n    // do nothing\n    if (!isSameUrl || !next.replace) {\n      let { maskedLocation, ...nextHistory } = next\n\n      if (maskedLocation) {\n        nextHistory = {\n          ...maskedLocation,\n          state: {\n            ...maskedLocation.state,\n            __tempKey: undefined,\n            __tempLocation: {\n              ...nextHistory,\n              search: nextHistory.searchStr,\n              state: {\n                ...nextHistory.state,\n                __tempKey: undefined!,\n                __tempLocation: undefined!,\n                key: undefined!,\n              },\n            },\n          },\n        }\n\n        if (\n          nextHistory.unmaskOnReload ??\n          this.options.unmaskOnReload ??\n          false\n        ) {\n          nextHistory.state.__tempKey = this.tempLocationKey\n        }\n      }\n\n      const apply = () => {\n        this.history[next.replace ? 'replace' : 'push'](\n          nextHistory.href,\n          nextHistory.state,\n        )\n      }\n\n      if (startTransition ?? true) {\n        this.startReactTransition(apply)\n      } else {\n        apply()\n      }\n    }\n\n    this.resetNextScroll = next.resetScroll ?? true\n\n    return this.latestLoadPromise\n  }\n\n  buildAndCommitLocation = ({\n    replace,\n    resetScroll,\n    startTransition,\n    ...rest\n  }: BuildNextOptions & CommitLocationOptions = {}) => {\n    const location = this.buildLocation(rest as any)\n    return this.commitLocation({\n      ...location,\n      startTransition,\n      replace,\n      resetScroll,\n    })\n  }\n\n  navigate: NavigateFn<TRouteTree> = ({ from, to = '', ...rest }) => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n    const toString = String(to)\n    const fromString = typeof from === 'undefined' ? from : String(from)\n    let isExternal\n\n    try {\n      new URL(`${toString}`)\n      isExternal = true\n    } catch (e) {}\n\n    invariant(\n      !isExternal,\n      'Attempting to navigate to external url with this.navigate!',\n    )\n\n    return this.buildAndCommitLocation({\n      ...rest,\n      from: fromString,\n      to: toString,\n    })\n  }\n\n  loadMatches = async ({\n    checkLatest,\n    matches,\n    preload,\n  }: {\n    checkLatest: () => Promise<void> | undefined\n    matches: AnyRouteMatch[]\n    preload?: boolean\n  }): Promise<RouteMatch[]> => {\n    let latestPromise\n    let firstBadMatchIndex: number | undefined\n\n    const updateMatch = (match: AnyRouteMatch) => {\n      // const isPreload = this.state.cachedMatches.find((d) => d.id === match.id)\n      const isPending = this.state.pendingMatches?.find(\n        (d) => d.id === match.id,\n      )\n\n      const isMatched = this.state.matches.find((d) => d.id === match.id)\n\n      const matchesKey = isPending\n        ? 'pendingMatches'\n        : isMatched\n          ? 'matches'\n          : 'cachedMatches'\n\n      this.__store.setState((s) => ({\n        ...s,\n        [matchesKey]: s[matchesKey]?.map((d) =>\n          d.id === match.id ? match : d,\n        ),\n      }))\n    }\n\n    // Check each match middleware to see if the route can be accessed\n    try {\n      for (let [index, match] of matches.entries()) {\n        const parentMatch = matches[index - 1]\n        const route = this.looseRoutesById[match.routeId]!\n        const abortController = new AbortController()\n\n        const handleErrorAndRedirect = (err: any, code: string) => {\n          err.routerCode = code\n          firstBadMatchIndex = firstBadMatchIndex ?? index\n\n          if (isRedirect(err)) {\n            throw err\n          }\n\n          try {\n            route.options.onError?.(err)\n          } catch (errorHandlerErr) {\n            err = errorHandlerErr\n\n            if (isRedirect(errorHandlerErr)) {\n              throw errorHandlerErr\n            }\n          }\n\n          matches[index] = match = {\n            ...match,\n            error: err,\n            status: 'error',\n            updatedAt: Date.now(),\n            abortController: new AbortController(),\n          }\n        }\n\n        try {\n          if (match.paramsError) {\n            handleErrorAndRedirect(match.paramsError, 'PARSE_PARAMS')\n          }\n\n          if (match.searchError) {\n            handleErrorAndRedirect(match.searchError, 'VALIDATE_SEARCH')\n          }\n\n          const parentContext =\n            parentMatch?.context ?? this.options.context ?? {}\n\n          const beforeLoadContext =\n            (await route.options.beforeLoad?.({\n              search: match.search,\n              abortController,\n              params: match.params,\n              preload: !!preload,\n              context: parentContext,\n              location: this.state.location,\n              // TOOD: just expose state and router, etc\n              navigate: (opts) =>\n                this.navigate({ ...opts, from: match.pathname } as any),\n              buildLocation: this.buildLocation,\n              cause: preload ? 'preload' : match.cause,\n            })) ?? ({} as any)\n\n          if (isRedirect(beforeLoadContext)) {\n            throw beforeLoadContext\n          }\n\n          const context = {\n            ...parentContext,\n            ...beforeLoadContext,\n          }\n\n          matches[index] = match = {\n            ...match,\n            routeContext: replaceEqualDeep(\n              match.routeContext,\n              beforeLoadContext,\n            ),\n            context: replaceEqualDeep(match.context, context),\n            abortController,\n          }\n        } catch (err) {\n          handleErrorAndRedirect(err, 'BEFORE_LOAD')\n          break\n        }\n      }\n    } catch (err) {\n      if (isRedirect(err)) {\n        if (!preload) this.navigate(err as any)\n        return matches\n      }\n\n      throw err\n    }\n\n    const validResolvedMatches = matches.slice(0, firstBadMatchIndex)\n    const matchPromises: Promise<any>[] = []\n\n    validResolvedMatches.forEach((match, index) => {\n      matchPromises.push(\n        new Promise<void>(async (resolve) => {\n          const parentMatchPromise = matchPromises[index - 1]\n          const route = this.looseRoutesById[match.routeId]!\n\n          const handleErrorAndRedirect = (err: any) => {\n            if (isRedirect(err)) {\n              if (!preload) {\n                this.navigate(err as any)\n              }\n              return true\n            }\n            return false\n          }\n\n          let loadPromise: Promise<void> | undefined\n\n          matches[index] = match = {\n            ...match,\n            showPending: false,\n          }\n\n          let didShowPending = false\n          const pendingMs =\n            route.options.pendingMs ?? this.options.defaultPendingMs\n          const pendingMinMs =\n            route.options.pendingMinMs ?? this.options.defaultPendingMinMs\n          const shouldPending =\n            !preload &&\n            pendingMs &&\n            (route.options.pendingComponent ??\n              this.options.defaultPendingComponent)\n\n          const loaderContext: LoaderFnContext = {\n            params: match.params,\n            deps: match.loaderDeps,\n            preload: !!preload,\n            parentMatchPromise,\n            abortController: match.abortController,\n            context: match.context,\n            location: this.state.location,\n            navigate: (opts) =>\n              this.navigate({ ...opts, from: match.pathname } as any),\n            cause: preload ? 'preload' : match.cause,\n          }\n\n          const fetch = async () => {\n            if (match.isFetching) {\n              loadPromise = getRouteMatch(this.state, match.id)?.loadPromise\n            } else {\n              // If the user doesn't want the route to reload, just\n              // resolve with the existing loader data\n\n              if (match.fetchCount && match.status === 'success') {\n                resolve()\n              }\n\n              // Otherwise, load the route\n              matches[index] = match = {\n                ...match,\n                isFetching: true,\n                fetchCount: match.fetchCount + 1,\n              }\n\n              const componentsPromise = Promise.all(\n                componentTypes.map(async (type) => {\n                  const component = route.options[type]\n\n                  if ((component as any)?.preload) {\n                    await (component as any).preload()\n                  }\n                }),\n              )\n\n              const loaderPromise = route.options.loader?.(loaderContext)\n\n              loadPromise = Promise.all([\n                componentsPromise,\n                loaderPromise,\n              ]).then((d) => d[1])\n            }\n\n            matches[index] = match = {\n              ...match,\n              loadPromise,\n            }\n\n            updateMatch(match)\n\n            try {\n              const loaderData = await loadPromise\n              if ((latestPromise = checkLatest())) return await latestPromise\n\n              if (isRedirect(loaderData)) {\n                if (handleErrorAndRedirect(loaderData)) return\n              }\n\n              if (didShowPending && pendingMinMs) {\n                await new Promise((r) => setTimeout(r, pendingMinMs))\n              }\n\n              if ((latestPromise = checkLatest())) return await latestPromise\n\n              matches[index] = match = {\n                ...match,\n                error: undefined,\n                status: 'success',\n                isFetching: false,\n                updatedAt: Date.now(),\n                loaderData,\n                loadPromise: undefined,\n              }\n            } catch (error) {\n              if ((latestPromise = checkLatest())) return await latestPromise\n              if (handleErrorAndRedirect(error)) return\n\n              try {\n                route.options.onError?.(error)\n              } catch (onErrorError) {\n                error = onErrorError\n                if (handleErrorAndRedirect(onErrorError)) return\n              }\n\n              matches[index] = match = {\n                ...match,\n                error,\n                status: 'error',\n                isFetching: false,\n              }\n            }\n\n            updateMatch(match)\n          }\n\n          // This is where all of the stale-while-revalidate magic happens\n          const age = Date.now() - match.updatedAt\n\n          let staleAge = preload\n            ? route.options.preloadStaleTime ??\n              this.options.defaultPreloadStaleTime ??\n              30_000 // 30 seconds for preloads by default\n            : route.options.staleTime ?? this.options.defaultStaleTime ?? 0\n\n          // Default to reloading the route all the time\n          let shouldReload\n\n          const shouldReloadOption = route.options.shouldReload\n\n          // Allow shouldReload to get the last say,\n          // if provided.\n          shouldReload =\n            typeof shouldReloadOption === 'function'\n              ? shouldReloadOption(loaderContext)\n              : shouldReloadOption\n\n          matches[index] = match = {\n            ...match,\n            preload:\n              !!preload && !this.state.matches.find((d) => d.id === match.id),\n          }\n\n          if (match.status !== 'success') {\n            // If we need to potentially show the pending component,\n            // start a timer to show it after the pendingMs\n            if (shouldPending) {\n              new Promise((r) => setTimeout(r, pendingMs)).then(async () => {\n                if ((latestPromise = checkLatest())) return latestPromise\n\n                didShowPending = true\n                matches[index] = match = {\n                  ...match,\n                  showPending: true,\n                }\n\n                updateMatch(match)\n                resolve()\n              })\n            }\n\n            // Critical Fetching, we need to await\n            await fetch()\n          } else if (match.invalid || (shouldReload ?? age > staleAge)) {\n            // Background Fetching, no need to wait\n            fetch()\n          }\n\n          resolve()\n        }),\n      )\n    })\n\n    await Promise.all(matchPromises)\n    return matches\n  }\n\n  invalidate = () => {\n    const invalidate = (d: any) => ({\n      ...d,\n      invalid: true,\n    })\n\n    this.__store.setState((s) => ({\n      ...s,\n      matches: s.matches.map(invalidate),\n      cachedMatches: s.cachedMatches.map(invalidate),\n      pendingMatches: s.pendingMatches?.map(invalidate),\n    }))\n\n    this.load()\n  }\n\n  load = async (): Promise<void> => {\n    const promise = new Promise<void>(async (resolve, reject) => {\n      const next = this.latestLocation\n      const prevLocation = this.state.resolvedLocation\n      const pathDidChange = prevLocation!.href !== next.href\n      let latestPromise: Promise<void> | undefined | null\n\n      // Cancel any pending matches\n      this.cancelMatches()\n\n      this.emit({\n        type: 'onBeforeLoad',\n        fromLocation: prevLocation,\n        toLocation: next,\n        pathChanged: pathDidChange,\n      })\n\n      let pendingMatches!: RouteMatch<any, any>[]\n      const previousMatches = this.state.matches\n\n      this.__store.batch(() => {\n        this.cleanCache()\n\n        // Match the routes\n        pendingMatches = this.matchRoutes(next.pathname, next.search, {\n          debug: true,\n        })\n\n        // Ingest the new matches\n        // If a cached moved to pendingMatches, remove it from cachedMatches\n        this.__store.setState((s) => ({\n          ...s,\n          isLoading: true,\n          location: next,\n          pendingMatches,\n          cachedMatches: s.cachedMatches.filter((d) => {\n            return !pendingMatches.find((e) => e.id === d.id)\n          }),\n        }))\n      })\n\n      try {\n        try {\n          // Load the matches\n          await this.loadMatches({\n            matches: pendingMatches,\n            checkLatest: () => this.checkLatest(promise),\n          })\n        } catch (err) {\n          // swallow this error, since we'll display the\n          // errors on the route components\n        }\n\n        // Only apply the latest transition\n        if ((latestPromise = this.checkLatest(promise))) {\n          return latestPromise\n        }\n\n        const exitingMatches = previousMatches.filter(\n          (match) => !pendingMatches.find((d) => d.id === match.id),\n        )\n        const enteringMatches = pendingMatches.filter(\n          (match) => !previousMatches.find((d) => d.id === match.id),\n        )\n        const stayingMatches = previousMatches.filter((match) =>\n          pendingMatches.find((d) => d.id === match.id),\n        )\n\n        // Commit the pending matches. If a previous match was\n        // removed, place it in the cachedMatches\n        this.__store.batch(() => {\n          this.__store.setState((s) => ({\n            ...s,\n            isLoading: false,\n            matches: s.pendingMatches!,\n            pendingMatches: undefined,\n            cachedMatches: [\n              ...s.cachedMatches,\n              ...exitingMatches.filter((d) => d.status !== 'error'),\n            ],\n          }))\n          this.cleanCache()\n        })\n\n        //\n        ;(\n          [\n            [exitingMatches, 'onLeave'],\n            [enteringMatches, 'onEnter'],\n            [stayingMatches, 'onStay'],\n          ] as const\n        ).forEach(([matches, hook]) => {\n          matches.forEach((match) => {\n            this.looseRoutesById[match.routeId]!.options[hook]?.(match)\n          })\n        })\n\n        this.emit({\n          type: 'onLoad',\n          fromLocation: prevLocation,\n          toLocation: next,\n          pathChanged: pathDidChange,\n        })\n\n        resolve()\n      } catch (err) {\n        // Only apply the latest transition\n        if ((latestPromise = this.checkLatest(promise))) {\n          return latestPromise\n        }\n\n        reject(err)\n      }\n    })\n\n    this.latestLoadPromise = promise\n\n    return this.latestLoadPromise\n  }\n\n  cleanCache = () => {\n    // This is where all of the garbage collection magic happens\n    this.__store.setState((s) => {\n      return {\n        ...s,\n        cachedMatches: s.cachedMatches.filter((d) => {\n          const route = this.looseRoutesById[d.routeId]!\n\n          if (!route.options.loader) {\n            return false\n          }\n\n          // If the route was preloaded, use the preloadGcTime\n          // otherwise, use the gcTime\n          const gcTime =\n            (d.preload\n              ? route.options.preloadGcTime ?? this.options.defaultPreloadGcTime\n              : route.options.gcTime ?? this.options.defaultGcTime) ??\n            5 * 60 * 1000\n\n          return d.status !== 'error' && Date.now() - d.updatedAt < gcTime\n        }),\n      }\n    })\n  }\n\n  preloadRoute = async (\n    navigateOpts: ToOptions<TRouteTree> = this.state.location as any,\n  ) => {\n    let next = this.buildLocation(navigateOpts as any)\n\n    let matches = this.matchRoutes(next.pathname, next.search, {\n      throwOnError: true,\n    })\n\n    const loadedMatchIds = Object.fromEntries(\n      [\n        ...this.state.matches,\n        ...(this.state.pendingMatches ?? []),\n        ...this.state.cachedMatches,\n      ]?.map((d) => [d.id, true]),\n    )\n\n    this.__store.batch(() => {\n      matches.forEach((match) => {\n        if (!loadedMatchIds[match.id]) {\n          this.__store.setState((s) => ({\n            ...s,\n            cachedMatches: [...(s.cachedMatches as any), match],\n          }))\n        }\n      })\n    })\n\n    matches = await this.loadMatches({\n      matches,\n      preload: true,\n      checkLatest: () => undefined,\n    })\n\n    return matches\n  }\n\n  matchRoute: MatchRouteFn<TRouteTree> = (location, opts) => {\n    location = {\n      ...location,\n      to: location.to\n        ? this.resolvePathWithBase((location.from || '') as string, location.to)\n        : undefined,\n    } as any\n\n    const next = this.buildLocation(location as any)\n\n    if (opts?.pending && this.state.status !== 'pending') {\n      return false\n    }\n\n    const baseLocation = opts?.pending\n      ? this.latestLocation\n      : this.state.resolvedLocation\n\n    if (!baseLocation) {\n      return false\n    }\n\n    const match = matchPathname(this.basepath, baseLocation.pathname, {\n      ...opts,\n      to: next.pathname,\n    }) as any\n\n    if (!match) {\n      return false\n    }\n\n    if (match && (opts?.includeSearch ?? true)) {\n      return deepEqual(baseLocation.search, next.search, true) ? match : false\n    }\n\n    return match\n  }\n\n  injectHtml = async (html: string | (() => Promise<string> | string)) => {\n    this.injectedHtml.push(html)\n  }\n\n  dehydrateData = <T>(key: any, getData: T | (() => Promise<T> | T)) => {\n    if (typeof document === 'undefined') {\n      const strKey = typeof key === 'string' ? key : JSON.stringify(key)\n\n      this.injectHtml(async () => {\n        const id = `__TSR_DEHYDRATED__${strKey}`\n        const data =\n          typeof getData === 'function' ? await (getData as any)() : getData\n        return `<script id='${id}' suppressHydrationWarning>window[\"__TSR_DEHYDRATED__${escapeJSON(\n          strKey,\n        )}\"] = ${JSON.stringify(data)}\n          ;(() => {\n            var el = document.getElementById('${id}')\n            el.parentElement.removeChild(el)\n          })()\n          </script>`\n      })\n\n      return () => this.hydrateData<T>(key)\n    }\n\n    return () => undefined\n  }\n\n  hydrateData = <T extends any = unknown>(key: any) => {\n    if (typeof document !== 'undefined') {\n      const strKey = typeof key === 'string' ? key : JSON.stringify(key)\n\n      return window[`__TSR_DEHYDRATED__${strKey}` as any] as T\n    }\n\n    return undefined\n  }\n\n  dehydrate = (): DehydratedRouter => {\n    return {\n      state: {\n        dehydratedMatches: this.state.matches.map((d) =>\n          pick(d, ['id', 'status', 'updatedAt', 'loaderData']),\n        ),\n      },\n    }\n  }\n\n  hydrate = async (__do_not_use_server_ctx?: HydrationCtx) => {\n    let _ctx = __do_not_use_server_ctx\n    // Client hydrates from window\n    if (typeof document !== 'undefined') {\n      _ctx = window.__TSR_DEHYDRATED__\n    }\n\n    invariant(\n      _ctx,\n      'Expected to find a __TSR_DEHYDRATED__ property on window... but we did not. Did you forget to render <DehydrateRouter /> in your app?',\n    )\n\n    const ctx = _ctx\n    this.dehydratedData = ctx.payload as any\n    this.options.hydrate?.(ctx.payload as any)\n    const dehydratedState = ctx.router.state\n\n    let matches = this.matchRoutes(\n      this.state.location.pathname,\n      this.state.location.search,\n    ).map((match) => {\n      const dehydratedMatch = dehydratedState.dehydratedMatches.find(\n        (d) => d.id === match.id,\n      )\n\n      invariant(\n        dehydratedMatch,\n        `Could not find a client-side match for dehydrated match with id: ${match.id}!`,\n      )\n\n      if (dehydratedMatch) {\n        return {\n          ...match,\n          ...dehydratedMatch,\n        }\n      }\n      return match\n    })\n\n    this.__store.setState((s) => {\n      return {\n        ...s,\n        matches: matches as any,\n      }\n    })\n  }\n\n  // resolveMatchPromise = (matchId: string, key: string, value: any) => {\n  //   state.matches\n  //     .find((d) => d.id === matchId)\n  //     ?.__promisesByKey[key]?.resolve(value)\n  // }\n}\n\n// A function that takes an import() argument which is a function and returns a new function that will\n// proxy arguments from the caller to the imported function, retaining all type\n// information along the way\nexport function lazyFn<\n  T extends Record<string, (...args: any[]) => any>,\n  TKey extends keyof T = 'default',\n>(fn: () => Promise<T>, key?: TKey) {\n  return async (...args: Parameters<T[TKey]>): Promise<ReturnType<T[TKey]>> => {\n    const imported = await fn()\n    return imported[key || 'default'](...args)\n  }\n}\n\nexport class SearchParamError extends Error {}\n\nexport class PathParamError extends Error {}\n\nexport function getInitialRouterState(\n  location: ParsedLocation,\n): RouterState<any> {\n  return {\n    isLoading: false,\n    isTransitioning: false,\n    status: 'idle',\n    resolvedLocation: { ...location },\n    location,\n    matches: [],\n    pendingMatches: [],\n    cachedMatches: [],\n    lastUpdated: Date.now(),\n  }\n}\n","import * as React from 'react'\n\nconst useLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\nimport { ParsedLocation } from './location'\nimport { useRouter } from './RouterProvider'\nimport { NonNullableUpdater, functionalUpdate } from './utils'\n\nconst windowKey = 'window'\nconst delimiter = '___'\n\nlet weakScrolledElements = new WeakSet<any>()\n\ntype CacheValue = Record<string, { scrollX: number; scrollY: number }>\ntype CacheState = {\n  cached: CacheValue\n  next: CacheValue\n}\n\ntype Cache = {\n  state: CacheState\n  set: (updater: NonNullableUpdater<CacheState>) => void\n}\n\nconst sessionsStorage = typeof window !== 'undefined' && window.sessionStorage\n\nlet cache: Cache = sessionsStorage\n  ? (() => {\n      const storageKey = 'tsr-scroll-restoration-v2'\n\n      const state: CacheState = JSON.parse(\n        window.sessionStorage.getItem(storageKey) || 'null',\n      ) || { cached: {}, next: {} }\n\n      return {\n        state,\n        set: (updater) => {\n          cache.state = functionalUpdate(updater, cache.state)\n          window.sessionStorage.setItem(storageKey, JSON.stringify(cache.state))\n        },\n      }\n    })()\n  : (undefined as any)\n\nexport type ScrollRestorationOptions = {\n  getKey?: (location: ParsedLocation) => string\n}\n\nconst defaultGetKey = (location: ParsedLocation) => location.state.key!\n\nexport function useScrollRestoration(options?: ScrollRestorationOptions) {\n  const router = useRouter()\n\n  useLayoutEffect(() => {\n    const getKey = options?.getKey || defaultGetKey\n\n    const { history } = window\n    if (history.scrollRestoration) {\n      history.scrollRestoration = 'manual'\n    }\n\n    const onScroll = (event: Event) => {\n      if (weakScrolledElements.has(event.target)) return\n      weakScrolledElements.add(event.target)\n\n      let elementSelector = ''\n\n      if (event.target === document || event.target === window) {\n        elementSelector = windowKey\n      } else {\n        const attrId = (event.target as Element).getAttribute(\n          'data-scroll-restoration-id',\n        )\n\n        if (attrId) {\n          elementSelector = `[data-scroll-restoration-id=\"${attrId}\"]`\n        } else {\n          elementSelector = getCssSelector(event.target)\n        }\n      }\n\n      if (!cache.state.next[elementSelector]) {\n        cache.set((c) => ({\n          ...c,\n          next: {\n            ...c.next,\n            [elementSelector]: {\n              scrollX: NaN,\n              scrollY: NaN,\n            },\n          },\n        }))\n      }\n    }\n\n    if (typeof document !== 'undefined') {\n      document.addEventListener('scroll', onScroll, true)\n    }\n\n    const unsubOnBeforeLoad = router.subscribe('onBeforeLoad', (event) => {\n      if (event.pathChanged) {\n        const restoreKey = getKey(event.fromLocation)\n        for (const elementSelector in cache.state.next) {\n          const entry = cache.state.next[elementSelector]!\n          if (elementSelector === windowKey) {\n            entry.scrollX = window.scrollX || 0\n            entry.scrollY = window.scrollY || 0\n          } else if (elementSelector) {\n            const element = document.querySelector(elementSelector)\n            entry.scrollX = element?.scrollLeft || 0\n            entry.scrollY = element?.scrollTop || 0\n          }\n\n          cache.set((c) => {\n            const next = { ...c.next }\n            delete next[elementSelector]\n\n            return {\n              ...c,\n              next,\n              cached: {\n                ...c.cached,\n                [[restoreKey, elementSelector].join(delimiter)]: entry,\n              },\n            }\n          })\n        }\n      }\n    })\n\n    const unsubOnResolved = router.subscribe('onResolved', (event) => {\n      if (event.pathChanged) {\n        if (!router.resetNextScroll) {\n          return\n        }\n\n        router.resetNextScroll = true\n\n        const getKey = options?.getKey || defaultGetKey\n\n        const restoreKey = getKey(event.toLocation)\n        let windowRestored = false\n\n        for (const cacheKey in cache.state.cached) {\n          const entry = cache.state.cached[cacheKey]!\n          const [key, elementSelector] = cacheKey.split(delimiter)\n          if (key === restoreKey) {\n            if (elementSelector === windowKey) {\n              windowRestored = true\n              window.scrollTo(entry.scrollX, entry.scrollY)\n            } else if (elementSelector) {\n              const element = document.querySelector(elementSelector)\n              if (element) {\n                element.scrollLeft = entry.scrollX\n                element.scrollTop = entry.scrollY\n              }\n            }\n          }\n        }\n\n        if (!windowRestored) {\n          window.scrollTo(0, 0)\n        }\n\n        cache.set((c) => ({ ...c, next: {} }))\n        weakScrolledElements = new WeakSet<any>()\n      }\n    })\n\n    return () => {\n      document.removeEventListener('scroll', onScroll)\n      unsubOnBeforeLoad()\n      unsubOnResolved()\n    }\n  }, [])\n}\n\nexport function ScrollRestoration(props: ScrollRestorationOptions) {\n  useScrollRestoration(props)\n  return null\n}\n\nexport function useElementScrollRestoration(\n  options: (\n    | {\n        id: string\n        getElement?: () => Element | undefined | null\n      }\n    | {\n        id?: string\n        getElement: () => Element | undefined | null\n      }\n  ) & {\n    getKey?: (location: ParsedLocation) => string\n  },\n) {\n  const router = useRouter()\n  const getKey = options?.getKey || defaultGetKey\n\n  let elementSelector = ''\n\n  if (options.id) {\n    elementSelector = `[data-scroll-restoration-id=\"${options.id}\"]`\n  } else {\n    const element = options.getElement?.()\n    if (!element) {\n      return\n    }\n    elementSelector = getCssSelector(element)\n  }\n\n  const restoreKey = getKey(router.latestLocation)\n  const cacheKey = [restoreKey, elementSelector].join(delimiter)\n  return cache.state.cached[cacheKey]\n}\n\nfunction getCssSelector(el: any): string {\n  let path = [],\n    parent\n  while ((parent = el.parentNode)) {\n    path.unshift(\n      `${el.tagName}:nth-child(${\n        ([].indexOf as any).call(parent.children, el) + 1\n      })`,\n    )\n    el = parent\n  }\n  return `${path.join(' > ')}`.toLowerCase()\n}\n","import * as React from 'react'\nimport { ReactNode } from './route'\nimport { useRouter } from './RouterProvider'\nimport { BlockerFn } from '@tanstack/history'\n\nexport function useBlocker(\n  blockerFn: BlockerFn,\n  condition: boolean | any = true,\n): void {\n  const { history } = useRouter()\n\n  React.useEffect(() => {\n    if (!condition) return\n    return history.block(blockerFn)\n  })\n}\n\nexport function Block({ blocker, condition, children }: PromptProps) {\n  useBlocker(blocker, condition)\n  return (children ?? null) as ReactNode\n}\n\nexport type PromptProps = {\n  blocker: BlockerFn\n  condition?: boolean | any\n  children?: ReactNode\n}\n","import * as React from 'react'\nimport { useMatch } from './Matches'\nimport { useRouter } from './RouterProvider'\nimport { LinkOptions, NavigateOptions } from './link'\nimport { AnyRoute } from './route'\nimport { RoutePaths } from './routeInfo'\nimport { RegisteredRouter } from './router'\nimport { useLayoutEffect } from './utils'\n\nexport function useNavigate<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TDefaultFrom extends RoutePaths<TRouteTree> = '/',\n>(defaultOpts?: { from?: TDefaultFrom }) {\n  const { navigate } = useRouter()\n  const matchPathname = useMatch({\n    strict: false,\n    select: (s) => s.pathname,\n  })\n  return React.useCallback(\n    <\n      TFrom extends RoutePaths<TRouteTree> = TDefaultFrom,\n      TTo extends string = '',\n      TMaskFrom extends RoutePaths<TRouteTree> = '/',\n      TMaskTo extends string = '',\n    >(\n      opts?: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n    ) => {\n      return navigate({\n        from: opts?.to ? matchPathname : undefined,\n        ...defaultOpts,\n        ...(opts as any),\n      })\n    },\n    [],\n  )\n}\n\n// NOTE: I don't know of anyone using this. It's undocumented, so let's wait until someone needs it\n// export function typedNavigate<\n//   TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n//   TDefaultFrom extends RoutePaths<TRouteTree> = '/',\n// >(navigate: (opts: NavigateOptions<any>) => Promise<void>) {\n//   return navigate as <\n//     TFrom extends RoutePaths<TRouteTree> = TDefaultFrom,\n//     TTo extends string = '',\n//     TMaskFrom extends RoutePaths<TRouteTree> = '/',\n//     TMaskTo extends string = '',\n//   >(\n//     opts?: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n//   ) => Promise<void>\n// } //\n\nexport function Navigate<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n>(props: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>): null {\n  const { navigate } = useRouter()\n  const match = useMatch({ strict: false })\n\n  React.useEffect(() => {\n    navigate({\n      from: props.to ? match.pathname : undefined,\n      ...props,\n    } as any)\n  }, [])\n\n  return null\n}\n\nexport type UseLinkPropsOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ActiveLinkOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> &\n  React.AnchorHTMLAttributes<HTMLAnchorElement>\n\nexport type LinkProps<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ActiveLinkOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> &\n  Omit<React.AnchorHTMLAttributes<HTMLAnchorElement>, 'children'> & {\n    // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n    children?:\n      | React.ReactNode\n      | ((state: { isActive: boolean }) => React.ReactNode)\n  }\n\nexport type ActiveLinkOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = LinkOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // A function that returns additional props for the `active` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n  activeProps?:\n    | React.AnchorHTMLAttributes<HTMLAnchorElement>\n    | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>)\n  // A function that returns additional props for the `inactive` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n  inactiveProps?:\n    | React.AnchorHTMLAttributes<HTMLAnchorElement>\n    | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>)\n}\n"],"names":["CatchBoundary","props","errorComponent","ErrorComponent","React","createElement","CatchBoundaryImpl","getResetKey","onCatch","children","error","Component","state","getDerivedStateFromProps","resetKey","getDerivedStateFromError","componentDidUpdate","prevProps","prevState","setState","componentDidCatch","console","render","show","setShow","useState","process","env","NODE_ENV","style","padding","maxWidth","display","alignItems","gap","fontSize","appearance","border","fontWeight","borderRadius","onClick","d","height","color","overflow","message","isServer","document","last","arr","length","isFunction","functionalUpdate","updater","previous","pick","parent","keys","reduce","obj","key","replaceEqualDeep","prev","_next","next","array","Array","isArray","isPlainObject","prevSize","Object","nextItems","nextSize","copy","equalItems","i","o","hasObjectPrototype","ctor","constructor","prot","prototype","hasOwnProperty","toString","call","deepEqual","a","b","partial","aKeys","bKeys","some","item","index","useStableCallback","fn","fnRef","useRef","current","ref","args","shallow","objA","objB","is","keysA","useRouteContext","opts","useMatch","select","match","context","useLayoutEffect","window","useEffect","escapeJSON","jsonString","replace","matchContext","createContext","undefined","Matches","router","useRouter","matchId","useRouterState","s","getRenderedMatches","id","Provider","value","resolvedLocation","warning","Match","SafeFragment","Fragment","routeId","find","invariant","route","routesById","PendingComponent","options","pendingComponent","defaultPendingComponent","pendingElement","routeErrorComponent","defaultErrorComponent","ResolvedSuspenseBoundary","wrapInSuspense","component","preload","Suspense","ResolvedCatchBoundary","fallback","MatchInner","status","showPending","loadPromise","Comp","defaultComponent","Outlet","memo","useContext","childMatchId","matches","findIndex","useMatchRoute","location","matchRoute","useCallback","pending","caseSensitive","rest","MatchRoute","params","pendingMatches","nearestMatchId","nearestMatchRouteId","matchRouteId","from","strict","matchSelection","useMatches","useParentMatches","contextMatchId","slice","useLoaderDeps","loaderDeps","useLoaderData","loaderData","routerContext","__TSR_ROUTER_CONTEXT__","RouterProvider","update","InnerWrap","provider","Transitioner","Wrap","routerState","isTransitioning","startReactTransition","useTransition","__store","tryLoad","apply","cb","load","err","unsub","history","subscribe","latestLocation","parseLocation","nextLocation","buildLocation","search","hash","href","commitLocation","isLoading","emit","type","fromLocation","toLocation","pathChanged","querySelector","el","getElementById","scrollIntoView","__TSR_DEHYDRATED__","getRouteMatch","cachedMatches","useStore","resolvedContext","defer","_promise","promise","__deferredState","uid","Math","random","then","data","catch","isDehydratedDeferred","Promise","useAwaited","hydrateData","resolve","r","setTimeout","dehydrateData","Await","awaited","joinPaths","paths","cleanPath","filter","Boolean","join","path","trimPathLeft","trimPathRight","trimPath","resolvePath","basepath","base","to","RegExp","baseSegments","parsePathname","toSegments","forEach","toSegment","push","pop","joined","map","pathname","segments","substring","split","part","charAt","interpolatePath","leaveWildcards","interpolatedPathSegments","segment","matchPathname","currentPathname","matchLocation","pathParams","matchByPath","removeBasepath","routeSegments","startsWith","unshift","isMatch","max","baseSegment","routeSegment","isLastBaseSegment","isLastRouteSegment","toLowerCase","fuzzy","useParams","useSearch","rootRouteId","RouteApi","Route","isRoot","getParentRoute","$$typeof","Symbol","for","init","originalIndex","parentRoute","customId","fullPath","addChildren","assign","rootRouteWithContext","RootRoute","createRouteMask","NotFoundRoute","FileRoute","createRoute","lazyRouteComponent","importer","exportName","lazyComp","lazy","moduleExports","comp","default","preloadWarning","useLinkProps","target","activeProps","className","inactiveProps","activeOptions","disabled","mask","userPreload","preloadDelay","userPreloadDelay","startTransition","resetScroll","onFocus","onMouseEnter","onMouseLeave","onTouchStart","dest","URL","defaultPreload","defaultPreloadDelay","isActive","currentPathSplit","nextPathSplit","pathIsFuzzyEqual","every","pathTest","exact","hashTest","includeHash","searchTest","includeSearch","handleClick","e","isCtrlEvent","defaultPrevented","button","preventDefault","handleFocus","preloadRoute","warn","handleTouchStart","handleEnter","preloadTimeout","handleLeave","clearTimeout","composeHandlers","handlers","persist","handler","resolvedActiveProps","resolvedInactiveProps","maskedLocation","role","Link","forwardRef","linkProps","_extends","metaKey","altKey","ctrlKey","shiftKey","encode","pfx","k","tmp","str","encodeURIComponent","toValue","mix","decodeURIComponent","decode","out","shift","concat","redirect","isRedirect","throw","defaultParseSearch","parseSearchWith","JSON","parse","defaultStringifySearch","stringifySearchWith","stringify","parser","searchStr","query","stringifyValue","val","componentTypes","Router","tempLocationKey","round","resetNextScroll","navigateTimeout","latestLoadPromise","subscribers","Set","injectedHtml","defaultPendingMs","defaultPendingMinMs","stringifySearch","parseSearch","newOptions","createBrowserHistory","createMemoryHistory","routeTree","buildRouteTree","Store","getInitialRouterState","onUpdate","routesByPath","notFoundRoute","recurseRoutes","childRoutes","childRoute","existingRoute","String","trimmedFullPath","endsWith","scoredRoutes","values","trimmed","parsed","scores","child","flatRoutes","sort","minLength","min","rank","eventType","listener","add","delete","routerEvent","checkLatest","previousLocation","parsedSearch","reverse","__tempLocation","__tempKey","parsedTempLocation","resolvePathWithBase","looseRoutesById","matchRoutes","locationSearch","routeParams","foundRoute","matchedParams","routeCursor","matchedRoutes","parseErrors","parsedParamsError","parseParams","parsedParams","PathParamError","cause","throwOnError","parentMatch","preMatchSearch","searchError","parentSearch","validator","validateSearch","SearchParamError","loaderDepsHash","interpolatedPath","existingMatch","hasLoaders","loader","updatedAt","Date","now","isFetching","paramsError","routeContext","abortController","AbortController","fetchCount","invalid","cancelMatch","abort","cancelMatches","build","fromSearch","at","fromPathname","fromMatches","stayingMatches","prevParams","nextParams","stringifyParams","preSearchFilters","flat","postSearchFilters","preFilteredSearch","destSearch","postFilteredSearch","hashStr","nextState","unmaskOnReload","buildWithMatches","maskedDest","maskedNext","foundMask","routeMasks","nextMatches","maskedMatches","maskedFinal","final","isSameUrl","nextHistory","buildAndCommitLocation","navigate","fromString","isExternal","loadMatches","latestPromise","firstBadMatchIndex","updateMatch","isPending","isMatched","matchesKey","entries","handleErrorAndRedirect","code","routerCode","onError","errorHandlerErr","parentContext","beforeLoadContext","beforeLoad","validResolvedMatches","matchPromises","parentMatchPromise","didShowPending","pendingMs","pendingMinMs","shouldPending","loaderContext","deps","fetch","componentsPromise","all","loaderPromise","onErrorError","age","staleAge","preloadStaleTime","defaultPreloadStaleTime","staleTime","defaultStaleTime","shouldReload","shouldReloadOption","invalidate","reject","prevLocation","pathDidChange","previousMatches","batch","cleanCache","debug","exitingMatches","enteringMatches","hook","gcTime","preloadGcTime","defaultPreloadGcTime","defaultGcTime","navigateOpts","loadedMatchIds","fromEntries","baseLocation","injectHtml","html","getData","strKey","dehydrate","dehydratedMatches","hydrate","__do_not_use_server_ctx","_ctx","ctx","dehydratedData","payload","dehydratedState","dehydratedMatch","lazyFn","imported","Error","lastUpdated","windowKey","delimiter","weakScrolledElements","WeakSet","sessionsStorage","sessionStorage","cache","storageKey","getItem","cached","set","setItem","defaultGetKey","useScrollRestoration","getKey","scrollRestoration","onScroll","event","has","elementSelector","attrId","getAttribute","getCssSelector","c","scrollX","NaN","scrollY","addEventListener","unsubOnBeforeLoad","restoreKey","entry","element","scrollLeft","scrollTop","unsubOnResolved","windowRestored","cacheKey","scrollTo","removeEventListener","ScrollRestoration","useElementScrollRestoration","getElement","parentNode","tagName","indexOf","useBlocker","blockerFn","condition","block","Block","blocker","useNavigate","defaultOpts","Navigate"],"mappings":"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"}