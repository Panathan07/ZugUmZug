import * as React from 'react';
import { AnyRouteMatch } from './Matches';
import { NavigateOptions, ParsePathParams, ToSubOptions } from './link';
import { ParsedLocation } from './location';
import { RouteById, RouteIds, RoutePaths } from './routeInfo';
import { AnyRouter, RegisteredRouter } from './router';
import { Assign, Expand, IsAny, NoInfer, PickRequired, UnionToIntersection } from './utils';
import { BuildLocationFn, NavigateFn } from './RouterProvider';
export declare const rootRouteId: "__root__";
export type RootRouteId = typeof rootRouteId;
export type AnyPathParams = {};
export type AnySearchSchema = {};
export type AnyContext = {};
export interface RouteContext {
}
export interface RouteMeta {
}
export type PreloadableObj = {
    preload?: () => Promise<void>;
};
export type RoutePathOptions<TCustomId, TPath> = {
    path: TPath;
} | {
    id: TCustomId;
};
export type RoutePathOptionsIntersection<TCustomId, TPath> = UnionToIntersection<RoutePathOptions<TCustomId, TPath>>;
export type MetaOptions = keyof PickRequired<RouteMeta> extends never ? {
    meta?: RouteMeta;
} : {
    meta: RouteMeta;
};
export type RouteOptions<TParentRoute extends AnyRoute = AnyRoute, TCustomId extends string = string, TPath extends string = string, TSearchSchema extends Record<string, any> = {}, TFullSearchSchema extends Record<string, any> = TSearchSchema, TParams extends AnyPathParams = AnyPathParams, TAllParams extends AnyPathParams = TParams, TRouteContext extends RouteContext = RouteContext, TAllContext extends Record<string, any> = AnyContext, TLoaderDeps extends Record<string, any> = {}, TLoaderData extends any = unknown> = BaseRouteOptions<TParentRoute, TCustomId, TPath, TSearchSchema, TFullSearchSchema, TParams, TAllParams, TRouteContext, TAllContext, TLoaderDeps, TLoaderData> & UpdatableRouteOptions<NoInfer<TFullSearchSchema>>;
export type ParamsFallback<TPath extends string, TParams> = unknown extends TParams ? Record<ParsePathParams<TPath>, string> : TParams;
export type BaseRouteOptions<TParentRoute extends AnyRoute = AnyRoute, TCustomId extends string = string, TPath extends string = string, TSearchSchema extends Record<string, any> = {}, TFullSearchSchema extends Record<string, any> = TSearchSchema, TParams extends AnyPathParams = {}, TAllParams = ParamsFallback<TPath, TParams>, TRouteContext extends RouteContext = RouteContext, TAllContext extends Record<string, any> = AnyContext, TLoaderDeps extends Record<string, any> = {}, TLoaderData extends any = unknown> = RoutePathOptions<TCustomId, TPath> & {
    getParentRoute: () => TParentRoute;
    validateSearch?: SearchSchemaValidator<TSearchSchema>;
    shouldReload?: boolean | ((match: LoaderFnContext<TAllParams, TFullSearchSchema, TAllContext, TRouteContext>) => any);
} & (keyof PickRequired<RouteContext> extends never ? {
    beforeLoad?: BeforeLoadFn<TFullSearchSchema, TParentRoute, TAllParams, TRouteContext>;
} : {
    beforeLoad: BeforeLoadFn<TFullSearchSchema, TParentRoute, TAllParams, TRouteContext>;
}) & {
    loaderDeps?: (opts: {
        search: TFullSearchSchema;
    }) => TLoaderDeps;
    loader?: RouteLoaderFn<TAllParams, NoInfer<TLoaderDeps>, NoInfer<TAllContext>, NoInfer<TRouteContext>, TLoaderData>;
} & ({
    parseParams?: (rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>) => TParams extends Record<ParsePathParams<TPath>, any> ? TParams : 'parseParams must return an object';
    stringifyParams?: (params: NoInfer<ParamsFallback<TPath, TParams>>) => Record<ParsePathParams<TPath>, string>;
} | {
    stringifyParams?: never;
    parseParams?: never;
});
type BeforeLoadFn<TFullSearchSchema extends Record<string, any>, TParentRoute extends AnyRoute, TAllParams, TRouteContext> = (opts: {
    search: TFullSearchSchema;
    abortController: AbortController;
    preload: boolean;
    params: TAllParams;
    context: TParentRoute['types']['allContext'];
    location: ParsedLocation;
    navigate: NavigateFn<AnyRoute>;
    buildLocation: BuildLocationFn<TParentRoute>;
    cause: 'preload' | 'enter' | 'stay';
}) => Promise<TRouteContext> | TRouteContext | void;
export type UpdatableRouteOptions<TFullSearchSchema extends Record<string, any>> = MetaOptions & {
    caseSensitive?: boolean;
    wrapInSuspense?: boolean;
    component?: RouteComponent;
    errorComponent?: false | null | ErrorRouteComponent;
    pendingComponent?: RouteComponent;
    pendingMs?: number;
    pendingMinMs?: number;
    staleTime?: number;
    gcTime?: number;
    preloadStaleTime?: number;
    preloadGcTime?: number;
    preSearchFilters?: SearchFilter<TFullSearchSchema>[];
    postSearchFilters?: SearchFilter<TFullSearchSchema>[];
    onError?: (err: any) => void;
    onEnter?: (match: AnyRouteMatch) => void;
    onStay?: (match: AnyRouteMatch) => void;
    onLeave?: (match: AnyRouteMatch) => void;
};
export type ParseParamsOption<TPath extends string, TParams> = ParseParamsFn<TPath, TParams>;
export type ParseParamsFn<TPath extends string, TParams> = (rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>) => TParams extends Record<ParsePathParams<TPath>, any> ? TParams : 'parseParams must return an object';
export type ParseParamsObj<TPath extends string, TParams> = {
    parse?: ParseParamsFn<TPath, TParams>;
};
export type SearchSchemaValidator<TReturn> = SearchSchemaValidatorObj<TReturn> | SearchSchemaValidatorFn<TReturn>;
export type SearchSchemaValidatorObj<TReturn> = {
    parse?: SearchSchemaValidatorFn<TReturn>;
};
export type SearchSchemaValidatorFn<TReturn> = (searchObj: Record<string, unknown>) => TReturn;
export type DefinedPathParamWarning = 'Path params cannot be redefined by child routes!';
export type ParentParams<TParentParams> = AnyPathParams extends TParentParams ? {} : {
    [Key in keyof TParentParams]?: DefinedPathParamWarning;
};
export type RouteLoaderFn<TAllParams = {}, TLoaderDeps extends Record<string, any> = {}, TAllContext extends Record<string, any> = AnyContext, TRouteContext extends Record<string, any> = AnyContext, TLoaderData extends any = unknown> = (match: LoaderFnContext<TAllParams, TLoaderDeps, TAllContext, TRouteContext>) => Promise<TLoaderData> | TLoaderData;
export interface LoaderFnContext<TAllParams = {}, TLoaderDeps extends Record<string, any> = {}, TAllContext extends Record<string, any> = AnyContext, TRouteContext extends Record<string, any> = AnyContext> {
    abortController: AbortController;
    preload: boolean;
    params: TAllParams;
    deps: TLoaderDeps;
    context: Expand<Assign<TAllContext, TRouteContext>>;
    location: ParsedLocation;
    navigate: (opts: NavigateOptions<AnyRoute>) => Promise<void>;
    parentMatchPromise?: Promise<void>;
    cause: 'preload' | 'enter' | 'stay';
}
export type SearchFilter<T, U = T> = (prev: T) => U;
export type ResolveId<TParentRoute, TCustomId extends string, TPath extends string> = TParentRoute extends {
    id: infer TParentId extends string;
} ? RoutePrefix<TParentId, string extends TCustomId ? TPath : TCustomId> : RootRouteId;
export type InferFullSearchSchema<TRoute> = TRoute extends {
    types: {
        fullSearchSchema: infer TFullSearchSchema;
    };
} ? TFullSearchSchema : {};
export type ResolveFullSearchSchema<TParentRoute, TSearchSchema> = Expand<Assign<InferFullSearchSchema<TParentRoute>, TSearchSchema>>;
export interface AnyRoute extends Route<any, any, any, any, any, any, any, any, any, any, any, any, any, any, any, any> {
}
export type MergeFromFromParent<T, U> = IsAny<T, U, T & U>;
export type ResolveAllParams<TParentRoute extends AnyRoute, TParams extends AnyPathParams> = Record<never, string> extends TParentRoute['types']['allParams'] ? TParams : Expand<UnionToIntersection<TParentRoute['types']['allParams'] & TParams> & {}>;
export type RouteConstraints = {
    TParentRoute: AnyRoute;
    TPath: string;
    TFullPath: string;
    TCustomId: string;
    TId: string;
    TSearchSchema: AnySearchSchema;
    TFullSearchSchema: AnySearchSchema;
    TParams: Record<string, any>;
    TAllParams: Record<string, any>;
    TParentContext: AnyContext;
    TRouteContext: RouteContext;
    TAllContext: AnyContext;
    TRouterContext: AnyContext;
    TChildren: unknown;
    TRouteTree: AnyRoute;
};
export declare class RouteApi<TId extends RouteIds<RegisteredRouter['routeTree']>, TRoute extends AnyRoute = RouteById<RegisteredRouter['routeTree'], TId>, TFullSearchSchema extends Record<string, any> = TRoute['types']['fullSearchSchema'], TAllParams extends AnyPathParams = TRoute['types']['allParams'], TAllContext extends Record<string, any> = TRoute['types']['allContext'], TLoaderDeps extends Record<string, any> = TRoute['types']['loaderDeps'], TLoaderData extends any = TRoute['types']['loaderData']> {
    id: TId;
    constructor({ id }: {
        id: TId;
    });
    useMatch: <TSelected = TAllContext>(opts?: {
        select?: ((s: TAllContext) => TSelected) | undefined;
    } | undefined) => TSelected;
    useRouteContext: <TSelected = TAllContext>(opts?: {
        select?: ((s: TAllContext) => TSelected) | undefined;
    } | undefined) => TSelected;
    useSearch: <TSelected = TFullSearchSchema>(opts?: {
        select?: ((s: TFullSearchSchema) => TSelected) | undefined;
    } | undefined) => TSelected;
    useParams: <TSelected = TAllParams>(opts?: {
        select?: ((s: TAllParams) => TSelected) | undefined;
    } | undefined) => TSelected;
    useLoaderDeps: <TSelected = TLoaderDeps>(opts?: {
        select?: ((s: TLoaderDeps) => TSelected) | undefined;
    } | undefined) => TSelected;
    useLoaderData: <TSelected = TLoaderData>(opts?: {
        select?: ((s: TLoaderData) => TSelected) | undefined;
    } | undefined) => TSelected;
}
export declare class Route<TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute, TPath extends RouteConstraints['TPath'] = '/', TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<TParentRoute, TPath>, TCustomId extends RouteConstraints['TCustomId'] = string, TId extends RouteConstraints['TId'] = ResolveId<TParentRoute, TCustomId, TPath>, TSearchSchema extends RouteConstraints['TSearchSchema'] = {}, TFullSearchSchema extends RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchema<TParentRoute, TSearchSchema>, TParams extends RouteConstraints['TParams'] = Expand<Record<ParsePathParams<TPath>, string>>, TAllParams extends RouteConstraints['TAllParams'] = ResolveAllParams<TParentRoute, TParams>, TRouteContext extends RouteConstraints['TRouteContext'] = RouteContext, TAllContext extends Expand<Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>> = Expand<Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>>, TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext, TLoaderDeps extends Record<string, any> = {}, TLoaderData extends any = unknown, TChildren extends RouteConstraints['TChildren'] = unknown, TRouteTree extends RouteConstraints['TRouteTree'] = AnyRoute> {
    isRoot: TParentRoute extends Route<any> ? true : false;
    options: RouteOptions<TParentRoute, TCustomId, TPath, TSearchSchema, TFullSearchSchema, TParams, TAllParams, TRouteContext, TAllContext, TLoaderDeps, TLoaderData>;
    test: Expand<Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>>;
    parentRoute: TParentRoute;
    id: TId;
    path: TPath;
    fullPath: TFullPath;
    to: TrimPathRight<TFullPath>;
    children?: TChildren;
    originalIndex?: number;
    router?: AnyRouter;
    rank: number;
    constructor(options: RouteOptions<TParentRoute, TCustomId, TPath, TSearchSchema, TFullSearchSchema, TParams, TAllParams, TRouteContext, TAllContext, TLoaderDeps, TLoaderData>);
    types: {
        parentRoute: TParentRoute;
        path: TPath;
        to: TrimPathRight<TFullPath>;
        fullPath: TFullPath;
        customId: TCustomId;
        id: TId;
        searchSchema: TSearchSchema;
        fullSearchSchema: TFullSearchSchema;
        params: TParams;
        allParams: TAllParams;
        routeContext: TRouteContext;
        allContext: TAllContext;
        children: TChildren;
        routeTree: TRouteTree;
        routerContext: TRouterContext;
        loaderData: TLoaderData;
        loaderDeps: TLoaderDeps;
    };
    init: (opts: {
        originalIndex: number;
    }) => void;
    addChildren: <TNewChildren extends AnyRoute[]>(children: TNewChildren) => Route<TParentRoute, TPath, TFullPath, TCustomId, TId, TSearchSchema, TFullSearchSchema, TParams, TAllParams, TRouteContext, TAllContext, TRouterContext, TLoaderDeps, TLoaderData, TNewChildren, TRouteTree>;
    update: (options: UpdatableRouteOptions<TFullSearchSchema>) => this;
    useMatch: <TSelected = TAllContext>(opts?: {
        select?: ((search: TAllContext) => TSelected) | undefined;
    } | undefined) => TSelected;
    useRouteContext: <TSelected = TAllContext>(opts?: {
        select?: ((search: TAllContext) => TSelected) | undefined;
    } | undefined) => TSelected;
    useSearch: <TSelected = TFullSearchSchema>(opts?: {
        select?: ((search: TFullSearchSchema) => TSelected) | undefined;
    } | undefined) => TSelected;
    useParams: <TSelected = TAllParams>(opts?: {
        select?: ((search: TAllParams) => TSelected) | undefined;
    } | undefined) => TSelected;
    useLoaderDeps: <TSelected = TLoaderDeps>(opts?: {
        select?: ((s: TLoaderDeps) => TSelected) | undefined;
    } | undefined) => TSelected;
    useLoaderData: <TSelected = TLoaderData>(opts?: {
        select?: ((search: TLoaderData) => TSelected) | undefined;
    } | undefined) => TSelected;
}
export type AnyRootRoute = RootRoute<any, any, any, any>;
export declare function rootRouteWithContext<TRouterContext extends {}>(): <TSearchSchema extends Record<string, any> = {}, TRouteContext extends RouteContext = RouteContext, TLoaderDeps extends Record<string, any> = {}, TLoaderData extends unknown = unknown>(options?: Omit<RouteOptions<AnyRoute, "__root__", "", TSearchSchema, TSearchSchema, {}, {}, TRouteContext, Assign<TRouterContext, TRouteContext>, TLoaderDeps, TLoaderData>, "path" | "id" | "getParentRoute" | "stringifyParams" | "parseParams" | "caseSensitive"> | undefined) => RootRoute<TSearchSchema, TRouteContext, TRouterContext, {}, unknown>;
export declare class RootRoute<TSearchSchema extends Record<string, any> = {}, TRouteContext extends RouteContext = RouteContext, TRouterContext extends {} = {}, TLoaderDeps extends Record<string, any> = {}, TLoaderData extends any = unknown> extends Route<any, // TParentRoute
'/', // TPath
'/', // TFullPath
string, // TCustomId
RootRouteId, // TId
TSearchSchema, // TSearchSchema
TSearchSchema, // TFullSearchSchema
{}, // TParams
{}, // TAllParams
TRouteContext, // TRouteContext
Expand<Assign<TRouterContext, TRouteContext>>, // TAllContext
TRouterContext, // TRouterContext
TLoaderDeps, TLoaderData, any, // TChildren
any> {
    constructor(options?: Omit<RouteOptions<AnyRoute, // TParentRoute
    RootRouteId, // TCustomId
    '', // TPath
    TSearchSchema, // TSearchSchema
    TSearchSchema, // TFullSearchSchema
    {}, // TParams
    {}, // TAllParams
    TRouteContext, // TRouteContext
    Assign<TRouterContext, TRouteContext>, // TAllContext
    TLoaderDeps, TLoaderData>, 'path' | 'id' | 'getParentRoute' | 'caseSensitive' | 'parseParams' | 'stringifyParams'>);
}
export type ResolveFullPath<TParentRoute extends AnyRoute, TPath extends string, TPrefixed = RoutePrefix<TParentRoute['fullPath'], TPath>> = TPrefixed extends RootRouteId ? '/' : TPrefixed;
type RoutePrefix<TPrefix extends string, TPath extends string> = string extends TPath ? RootRouteId : TPath extends string ? TPrefix extends RootRouteId ? TPath extends '/' ? '/' : `/${TrimPath<TPath>}` : `${TPrefix}/${TPath}` extends '/' ? '/' : `/${TrimPathLeft<`${TrimPathRight<TPrefix>}/${TrimPath<TPath>}`>}` : never;
export type TrimPath<T extends string> = '' extends T ? '' : TrimPathRight<TrimPathLeft<T>>;
export type TrimPathLeft<T extends string> = T extends `${RootRouteId}/${infer U}` ? TrimPathLeft<U> : T extends `/${infer U}` ? TrimPathLeft<U> : T;
export type TrimPathRight<T extends string> = T extends '/' ? '/' : T extends `${infer U}/` ? TrimPathRight<U> : T;
export type RouteMask<TRouteTree extends AnyRoute> = {
    routeTree: TRouteTree;
    from: RoutePaths<TRouteTree>;
    to?: any;
    params?: any;
    search?: any;
    hash?: any;
    state?: any;
    unmaskOnReload?: boolean;
};
export declare function createRouteMask<TRouteTree extends AnyRoute, TFrom extends RoutePaths<TRouteTree>, TTo extends string>(opts: {
    routeTree: TRouteTree;
} & ToSubOptions<TRouteTree, TFrom, TTo>): RouteMask<TRouteTree>;
export type ErrorRouteProps = {
    error: unknown;
    info: {
        componentStack: string;
    };
};
export type ReactNode = any;
export type SyncRouteComponent<TProps> = ((props: TProps) => ReactNode) | React.LazyExoticComponent<(props: TProps) => ReactNode>;
export type AsyncRouteComponent<TProps> = SyncRouteComponent<TProps> & {
    preload?: () => Promise<void>;
};
export type RouteComponent<TProps = any> = SyncRouteComponent<TProps> & AsyncRouteComponent<TProps>;
export type ErrorRouteComponent = RouteComponent<ErrorRouteProps>;
export declare class NotFoundRoute<TParentRoute extends AnyRootRoute, TSearchSchema extends RouteConstraints['TSearchSchema'] = {}, TFullSearchSchema extends RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchema<TParentRoute, TSearchSchema>, TRouteContext extends RouteConstraints['TRouteContext'] = RouteContext, TAllContext extends Expand<Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>> = Expand<Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>>, TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext, TLoaderDeps extends Record<string, any> = {}, TLoaderData extends any = unknown, TChildren extends RouteConstraints['TChildren'] = unknown, TRouteTree extends RouteConstraints['TRouteTree'] = AnyRoute> extends Route<TParentRoute, '/404', '/404', '404', '404', TSearchSchema, TFullSearchSchema, {}, {}, TRouteContext, TAllContext, TRouterContext, TLoaderDeps, TLoaderData, TChildren, TRouteTree> {
    constructor(options: Omit<RouteOptions<TParentRoute, string, string, TSearchSchema, TFullSearchSchema, {}, {}, TRouteContext, TAllContext, TLoaderDeps, TLoaderData>, 'caseSensitive' | 'parseParams' | 'stringifyParams' | 'path' | 'id'>);
}
export {};
