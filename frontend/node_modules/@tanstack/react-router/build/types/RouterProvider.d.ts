import * as React from 'react';
import { NavigateOptions, ResolveRelativePath, ToOptions } from './link';
import { ParsedLocation } from './location';
import { AnyRoute } from './route';
import { RouteById, RoutePaths } from './routeInfo';
import { RegisteredRouter, Router, RouterOptions, RouterState } from './router';
import { NoInfer } from './utils';
import { MatchRouteOptions } from './Matches';
import { RouteMatch } from './Matches';
export interface CommitLocationOptions {
    replace?: boolean;
    resetScroll?: boolean;
    startTransition?: boolean;
}
export interface MatchLocation {
    to?: string | number | null;
    fuzzy?: boolean;
    caseSensitive?: boolean;
    from?: string;
}
export type NavigateFn<TRouteTree extends AnyRoute> = <TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = TFrom, TMaskTo extends string = ''>(opts: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>) => Promise<void>;
export type MatchRouteFn<TRouteTree extends AnyRoute> = <TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>>(location: ToOptions<TRouteTree, TFrom, TTo>, opts?: MatchRouteOptions) => false | RouteById<TRouteTree, TResolved>['types']['allParams'];
export type BuildLocationFn<TRouteTree extends AnyRoute> = (opts: ToOptions<TRouteTree>) => ParsedLocation;
export type InjectedHtmlEntry = string | (() => Promise<string> | string);
export declare let routerContext: React.Context<Router<any, Record<string, any>>>;
export declare function RouterProvider<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TDehydrated extends Record<string, any> = Record<string, any>>({ router, ...rest }: RouterProps<TRouteTree, TDehydrated>): React.JSX.Element;
export declare function getRouteMatch<TRouteTree extends AnyRoute>(state: RouterState<TRouteTree>, id: string): undefined | RouteMatch<TRouteTree>;
export declare function useRouterState<TSelected = RouterState<RegisteredRouter['routeTree']>>(opts?: {
    select: (state: RouterState<RegisteredRouter['routeTree']>) => TSelected;
}): TSelected;
export type RouterProps<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TDehydrated extends Record<string, any> = Record<string, any>> = Omit<RouterOptions<TRouteTree, TDehydrated>, 'context'> & {
    router: Router<TRouteTree>;
    context?: Partial<RouterOptions<TRouteTree, TDehydrated>['context']>;
};
export declare function useRouter<TRouteTree extends AnyRoute = RegisteredRouter['routeTree']>(): Router<TRouteTree>;
