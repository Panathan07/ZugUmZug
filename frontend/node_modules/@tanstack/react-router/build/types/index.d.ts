/**
 * @tanstack/react-router/src/index.tsx
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
import { HistoryState, RouterHistory, HistoryLocation, BlockerFn } from '@tanstack/history';
export * from '@tanstack/history';
export { default as invariant } from 'tiny-invariant';
export { default as warning } from 'tiny-warning';
import * as React$1 from 'react';
import { Store } from '@tanstack/store';

type DeferredPromiseState<T> = {
    uid: string;
} & ({
    status: 'pending';
    data?: T;
    error?: unknown;
} | {
    status: 'success';
    data: T;
} | {
    status: 'error';
    data?: T;
    error: unknown;
});
type DeferredPromise<T> = Promise<T> & {
    __deferredState: DeferredPromiseState<T>;
};
declare function defer<T>(_promise: Promise<T>): DeferredPromise<T>;
declare function isDehydratedDeferred(obj: any): boolean;

type AwaitOptions<T> = {
    promise: DeferredPromise<T>;
};
declare function useAwaited<T>({ promise }: AwaitOptions<T>): [T];
declare function Await<T>(props: AwaitOptions<T> & {
    children: (result: T) => JSX.Element;
}): JSX.Element;

declare function CatchBoundary(props: {
    getResetKey: () => string;
    children: any;
    errorComponent?: any;
    onCatch: (error: any) => void;
}): React$1.JSX.Element;
declare class CatchBoundaryImpl extends React$1.Component<{
    getResetKey: () => string;
    children: (props: {
        error: any;
        reset: () => void;
    }) => any;
    onCatch?: (error: any) => void;
}> {
    state: any;
    static getDerivedStateFromProps(props: any): {
        resetKey: any;
    };
    static getDerivedStateFromError(error: any): {
        error: any;
    };
    componentDidUpdate(prevProps: Readonly<{
        getResetKey: () => string;
        children: (props: {
            error: any;
            reset: () => void;
        }) => any;
        onCatch?: ((error: any, info: any) => void) | undefined;
    }>, prevState: any): void;
    componentDidCatch(error: any): void;
    render(): any;
}
declare function ErrorComponent({ error }: {
    error: any;
}): React$1.JSX.Element;

interface ParsedLocation<TSearchObj extends AnySearchSchema = {}> {
    href: string;
    pathname: string;
    search: TSearchObj;
    searchStr: string;
    state: HistoryState;
    hash: string;
    maskedLocation?: ParsedLocation<TSearchObj>;
    unmaskOnReload?: boolean;
}

declare const defaultParseSearch: (searchStr: string) => AnySearchSchema;
declare const defaultStringifySearch: (search: Record<string, any>) => string;
declare function parseSearchWith(parser: (str: string) => any): (searchStr: string) => AnySearchSchema;
declare function stringifySearchWith(stringify: (search: any) => string, parser?: (str: string) => any): (search: Record<string, any>) => string;
type SearchSerializer = (searchObj: Record<string, any>) => string;
type SearchParser = (searchStr: string) => Record<string, any>;

interface CommitLocationOptions {
    replace?: boolean;
    resetScroll?: boolean;
    startTransition?: boolean;
}
interface MatchLocation {
    to?: string | number | null;
    fuzzy?: boolean;
    caseSensitive?: boolean;
    from?: string;
}
type NavigateFn<TRouteTree extends AnyRoute> = <TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = TFrom, TMaskTo extends string = ''>(opts: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>) => Promise<void>;
type MatchRouteFn<TRouteTree extends AnyRoute> = <TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>>(location: ToOptions<TRouteTree, TFrom, TTo>, opts?: MatchRouteOptions) => false | RouteById<TRouteTree, TResolved>['types']['allParams'];
type BuildLocationFn<TRouteTree extends AnyRoute> = (opts: ToOptions<TRouteTree>) => ParsedLocation;
type InjectedHtmlEntry = string | (() => Promise<string> | string);
declare let routerContext: React$1.Context<Router<any, Record<string, any>>>;
declare function RouterProvider<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TDehydrated extends Record<string, any> = Record<string, any>>({ router, ...rest }: RouterProps<TRouteTree, TDehydrated>): React$1.JSX.Element;
declare function getRouteMatch<TRouteTree extends AnyRoute>(state: RouterState<TRouteTree>, id: string): undefined | RouteMatch<TRouteTree>;
declare function useRouterState<TSelected = RouterState<RegisteredRouter['routeTree']>>(opts?: {
    select: (state: RouterState<RegisteredRouter['routeTree']>) => TSelected;
}): TSelected;
type RouterProps<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TDehydrated extends Record<string, any> = Record<string, any>> = Omit<RouterOptions<TRouteTree, TDehydrated>, 'context'> & {
    router: Router<TRouteTree>;
    context?: Partial<RouterOptions<TRouteTree, TDehydrated>['context']>;
};
declare function useRouter<TRouteTree extends AnyRoute = RegisteredRouter['routeTree']>(): Router<TRouteTree>;

declare global {
    interface Window {
        __TSR_DEHYDRATED__?: HydrationCtx;
        __TSR_ROUTER_CONTEXT__?: React.Context<Router<any>>;
    }
}
interface Register {
}
type AnyRouter = Router<AnyRoute, any>;
type RegisteredRouter = Register extends {
    router: infer TRouter extends AnyRouter;
} ? TRouter : AnyRouter;
type HydrationCtx = {
    router: DehydratedRouter;
    payload: Record<string, any>;
};
type RouterContextOptions<TRouteTree extends AnyRoute> = AnyContext extends TRouteTree['types']['routerContext'] ? {
    context?: TRouteTree['types']['routerContext'];
} : {
    context: TRouteTree['types']['routerContext'];
};
interface RouterOptions<TRouteTree extends AnyRoute, TDehydrated extends Record<string, any> = Record<string, any>> {
    history?: RouterHistory;
    stringifySearch?: SearchSerializer;
    parseSearch?: SearchParser;
    defaultPreload?: false | 'intent';
    defaultPreloadDelay?: number;
    defaultComponent?: RouteComponent;
    defaultErrorComponent?: RouteComponent;
    defaultPendingComponent?: RouteComponent;
    defaultPendingMs?: number;
    defaultPendingMinMs?: number;
    defaultStaleTime?: number;
    defaultPreloadStaleTime?: number;
    defaultPreloadGcTime?: number;
    defaultGcTime?: number;
    caseSensitive?: boolean;
    routeTree?: TRouteTree;
    basepath?: string;
    context?: TRouteTree['types']['routerContext'];
    dehydrate?: () => TDehydrated;
    hydrate?: (dehydrated: TDehydrated) => void;
    routeMasks?: RouteMask<TRouteTree>[];
    unmaskOnReload?: boolean;
    Wrap?: (props: {
        children: any;
    }) => JSX.Element;
    InnerWrap?: (props: {
        children: any;
    }) => JSX.Element;
    notFoundRoute?: AnyRoute;
}
interface RouterState<TRouteTree extends AnyRoute = AnyRoute> {
    status: 'pending' | 'idle';
    isLoading: boolean;
    isTransitioning: boolean;
    matches: RouteMatch<TRouteTree>[];
    pendingMatches?: RouteMatch<TRouteTree>[];
    cachedMatches: RouteMatch<TRouteTree>[];
    location: ParsedLocation<FullSearchSchema<TRouteTree>>;
    resolvedLocation: ParsedLocation<FullSearchSchema<TRouteTree>>;
    lastUpdated: number;
}
type ListenerFn<TEvent extends RouterEvent> = (event: TEvent) => void;
interface BuildNextOptions {
    to?: string | number | null;
    params?: true | Updater<unknown>;
    search?: true | Updater<unknown>;
    hash?: true | Updater<string>;
    state?: true | NonNullableUpdater<HistoryState>;
    mask?: {
        to?: string | number | null;
        params?: true | Updater<unknown>;
        search?: true | Updater<unknown>;
        hash?: true | Updater<string>;
        state?: true | NonNullableUpdater<HistoryState>;
        unmaskOnReload?: boolean;
    };
    from?: string;
}
interface DehydratedRouterState {
    dehydratedMatches: DehydratedRouteMatch[];
}
type DehydratedRouteMatch = Pick<RouteMatch, 'id' | 'status' | 'updatedAt'>;
interface DehydratedRouter {
    state: DehydratedRouterState;
}
type RouterConstructorOptions<TRouteTree extends AnyRoute, TDehydrated extends Record<string, any>> = Omit<RouterOptions<TRouteTree, TDehydrated>, 'context'> & RouterContextOptions<TRouteTree>;
declare const componentTypes: readonly ["component", "errorComponent", "pendingComponent"];
type RouterEvents = {
    onBeforeLoad: {
        type: 'onBeforeLoad';
        fromLocation: ParsedLocation;
        toLocation: ParsedLocation;
        pathChanged: boolean;
    };
    onLoad: {
        type: 'onLoad';
        fromLocation: ParsedLocation;
        toLocation: ParsedLocation;
        pathChanged: boolean;
    };
    onResolved: {
        type: 'onResolved';
        fromLocation: ParsedLocation;
        toLocation: ParsedLocation;
        pathChanged: boolean;
    };
};
type RouterEvent = RouterEvents[keyof RouterEvents];
type RouterListener<TRouterEvent extends RouterEvent> = {
    eventType: TRouterEvent['type'];
    fn: ListenerFn<TRouterEvent>;
};
declare class Router<TRouteTree extends AnyRoute = AnyRoute, TDehydrated extends Record<string, any> = Record<string, any>> {
    tempLocationKey: string | undefined;
    resetNextScroll: boolean;
    navigateTimeout: Timeout | null;
    latestLoadPromise: Promise<void>;
    subscribers: Set<RouterListener<RouterEvent>>;
    injectedHtml: InjectedHtmlEntry[];
    dehydratedData?: TDehydrated;
    __store: Store<RouterState<TRouteTree>>;
    options: PickAsRequired<RouterOptions<TRouteTree, TDehydrated>, 'stringifySearch' | 'parseSearch' | 'context'>;
    history: RouterHistory;
    latestLocation: ParsedLocation;
    basepath: string;
    routeTree: TRouteTree;
    routesById: RoutesById<TRouteTree>;
    routesByPath: RoutesByPath<TRouteTree>;
    flatRoutes: AnyRoute[];
    constructor(options: RouterConstructorOptions<TRouteTree, TDehydrated>);
    startReactTransition: (fn: () => void) => void;
    update: (newOptions: RouterConstructorOptions<TRouteTree, TDehydrated>) => void;
    get state(): RouterState<TRouteTree>;
    buildRouteTree: () => void;
    subscribe: <TType extends keyof RouterEvents>(eventType: TType, fn: ListenerFn<RouterEvents[TType]>) => () => void;
    emit: (routerEvent: RouterEvent) => void;
    checkLatest: (promise: Promise<void>) => undefined | Promise<void>;
    parseLocation: (previousLocation?: ParsedLocation) => ParsedLocation<FullSearchSchema<TRouteTree>>;
    resolvePathWithBase: (from: string, path: string) => string;
    get looseRoutesById(): Record<string, AnyRoute>;
    matchRoutes: <TRouteTree_1 extends AnyRoute>(pathname: string, locationSearch: AnySearchSchema, opts?: {
        throwOnError?: boolean;
        debug?: boolean;
    }) => RouteMatch<TRouteTree_1, ParseRoute<TRouteTree_1>["id"]>[];
    cancelMatch: (id: string) => void;
    cancelMatches: () => void;
    buildLocation: BuildLocationFn<TRouteTree>;
    commitLocation: ({ startTransition, ...next }: ParsedLocation & CommitLocationOptions) => Promise<void>;
    buildAndCommitLocation: ({ replace, resetScroll, startTransition, ...rest }?: BuildNextOptions & CommitLocationOptions) => Promise<void>;
    navigate: NavigateFn<TRouteTree>;
    loadMatches: ({ checkLatest, matches, preload, }: {
        checkLatest: () => Promise<void> | undefined;
        matches: AnyRouteMatch[];
        preload?: boolean | undefined;
    }) => Promise<RouteMatch[]>;
    invalidate: () => void;
    load: () => Promise<void>;
    cleanCache: () => void;
    preloadRoute: (navigateOpts?: ToOptions<TRouteTree>) => Promise<RouteMatch<AnyRoute, any>[]>;
    matchRoute: MatchRouteFn<TRouteTree>;
    injectHtml: (html: string | (() => Promise<string> | string)) => Promise<void>;
    dehydrateData: <T>(key: any, getData: T | (() => T | Promise<T>)) => () => T | undefined;
    hydrateData: <T extends unknown = unknown>(key: any) => T | undefined;
    dehydrate: () => DehydratedRouter;
    hydrate: (__do_not_use_server_ctx?: HydrationCtx) => Promise<void>;
}
declare function lazyFn<T extends Record<string, (...args: any[]) => any>, TKey extends keyof T = 'default'>(fn: () => Promise<T>, key?: TKey): (...args: Parameters<T[TKey]>) => Promise<ReturnType<T[TKey]>>;
declare class SearchParamError extends Error {
}
declare class PathParamError extends Error {
}
declare function getInitialRouterState(location: ParsedLocation): RouterState<any>;

type NoInfer<T> = [T][T extends any ? 0 : never];
type IsAny<T, Y, N = T> = 1 extends 0 & T ? Y : N;
type IsAnyBoolean<T> = 1 extends 0 & T ? true : false;
type IsKnown<T, Y, N> = unknown extends T ? N : Y;
type PickAsRequired<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;
type PickAsPartial<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
type PickUnsafe<T, K> = K extends keyof T ? Pick<T, K> : never;
type PickExtra<T, K> = {
    [TKey in keyof K as string extends TKey ? never : TKey extends keyof T ? never : TKey]: K[TKey];
};
type PickRequired<T> = {
    [K in keyof T as undefined extends T[K] ? never : K]: T[K];
};
type Expand<T> = T extends object ? T extends infer O ? {
    [K in keyof O]: O[K];
} : never : T;
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => any ? I : never;
type Assign<Left, Right> = Omit<Left, keyof Right> & Right;
type AssignAll<T extends any[]> = T extends [infer Left, ...infer Right] ? Right extends any[] ? Assign<Left, AssignAll<Right>> : Left : {};
type Values<O> = O[ValueKeys<O>];
type ValueKeys<O> = Extract<keyof O, PropertyKey>;
type DeepAwaited<T> = T extends Promise<infer A> ? DeepAwaited<A> : T extends Record<infer A, Promise<infer B>> ? {
    [K in A]: DeepAwaited<B>;
} : T;
type PathParamMask<TRoutePath extends string> = TRoutePath extends `${infer L}/$${infer C}/${infer R}` ? PathParamMask<`${L}/${string}/${R}`> : TRoutePath extends `${infer L}/$${infer C}` ? PathParamMask<`${L}/${string}`> : TRoutePath;
type Timeout = ReturnType<typeof setTimeout>;
type Updater<TPrevious, TResult = TPrevious> = TResult | ((prev?: TPrevious) => TResult);
type NonNullableUpdater<TPrevious, TResult = TPrevious> = TResult | ((prev: TPrevious) => TResult);
type PickExtract<T, U> = {
    [K in keyof T as T[K] extends U ? K : never]: T[K];
};
type PickExclude<T, U> = {
    [K in keyof T as T[K] extends U ? never : K]: T[K];
};
type LastInUnion<U> = UnionToIntersection<U extends unknown ? (x: U) => 0 : never> extends (x: infer L) => 0 ? L : never;
type UnionToTuple<U, Last = LastInUnion<U>> = [U] extends [never] ? [] : [...UnionToTuple<Exclude<U, Last>>, Last];
declare const isServer: boolean;
declare function last<T>(arr: T[]): T | undefined;
declare function functionalUpdate<TResult>(updater: Updater<TResult> | NonNullableUpdater<TResult>, previous: TResult): TResult;
declare function pick<T, K extends keyof T>(parent: T, keys: K[]): Pick<T, K>;
/**
 * This function returns `a` if `b` is deeply equal.
 * If not, it will replace any deeply equal children of `b` with those of `a`.
 * This can be used for structural sharing between immutable JSON values for example.
 * Do not use this with signals
 */
declare function replaceEqualDeep<T>(prev: any, _next: T): T;
declare function isPlainObject(o: any): boolean;
declare function deepEqual(a: any, b: any, partial?: boolean): boolean;
declare function useStableCallback<T extends (...args: any[]) => any>(fn: T): T;
declare function shallow<T>(objA: T, objB: T): boolean;
type StrictOrFrom<TFrom> = {
    from: TFrom;
    strict?: true;
} | {
    from?: never;
    strict: false;
};
type RouteFromIdOrRoute<T, TRouteTree extends AnyRoute = RegisteredRouter['routeTree']> = T extends ParseRoute<TRouteTree> ? T : T extends RouteIds<TRouteTree> ? RoutesById<TRouteTree>[T] : T extends string ? RouteIds<TRouteTree> : never;
declare function useRouteContext<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>, TStrict extends boolean = true, TRouteContext = RouteById<TRouteTree, TFrom>['types']['allContext'], TSelected = TRouteContext>(opts: StrictOrFrom<TFrom> & {
    select?: (search: TRouteContext) => TSelected;
}): TStrict extends true ? TSelected : TSelected | undefined;
declare const useLayoutEffect: typeof React$1.useLayoutEffect;
declare function escapeJSON(jsonString: string): string;

type ParseRoute<TRouteTree extends AnyRoute> = TRouteTree | ParseRouteChildren<TRouteTree>;
type ParseRouteChildren<TRouteTree extends AnyRoute> = TRouteTree extends Route<any, any, any, any, any, any, any, any, any, any, any, any, any, any, infer TChildren, any> ? unknown extends TChildren ? never : TChildren extends AnyRoute[] ? {
    [TId in TChildren[number]['id'] as string]: ParseRoute<TChildren[number]>;
}[string] : never : never;
type RoutesById<TRouteTree extends AnyRoute> = {
    [K in ParseRoute<TRouteTree> as K['id']]: K;
};
type RouteById<TRouteTree extends AnyRoute, TId> = Extract<ParseRoute<TRouteTree>, {
    id: TId;
}>;
type RouteIds<TRouteTree extends AnyRoute> = ParseRoute<TRouteTree>['id'];
type RoutesByPath<TRouteTree extends AnyRoute> = {
    [K in ParseRoute<TRouteTree> as K['fullPath']]: K;
};
type RouteByPath<TRouteTree extends AnyRoute, TPath> = Extract<ParseRoute<TRouteTree>, {
    fullPath: TPath;
}>;
type RoutePaths<TRouteTree extends AnyRoute> = ParseRoute<TRouteTree>['fullPath'] | '/';
type UnionizeCollisions<T, U> = {
    [P in keyof T & keyof U]: T[P] extends U[P] ? T[P] : T[P] | U[P];
};
type Reducer<T, U, C = UnionizeCollisions<T, U>> = C & Omit<T, keyof C> & Omit<U, keyof C>;
type Reduce<T extends any[], Result = unknown> = T extends [
    infer First,
    ...infer Rest
] ? Reduce<Rest, Reducer<Result, First>> : Result;
type FullSearchSchema<TRouteTree extends AnyRoute> = Partial<Expand<Reduce<UnionToTuple<ParseRoute<TRouteTree>['types']['fullSearchSchema']>>>>;
type AllParams<TRouteTree extends AnyRoute> = Expand<UnionToIntersection<ParseRoute<TRouteTree>['types']['allParams']>>;

declare const rootRouteId: "__root__";
type RootRouteId = typeof rootRouteId;
type AnyPathParams = {};
type AnySearchSchema = {};
type AnyContext = {};
interface RouteContext {
}
interface RouteMeta {
}
type PreloadableObj = {
    preload?: () => Promise<void>;
};
type RoutePathOptions<TCustomId, TPath> = {
    path: TPath;
} | {
    id: TCustomId;
};
type RoutePathOptionsIntersection<TCustomId, TPath> = UnionToIntersection<RoutePathOptions<TCustomId, TPath>>;
type MetaOptions = keyof PickRequired<RouteMeta> extends never ? {
    meta?: RouteMeta;
} : {
    meta: RouteMeta;
};
type RouteOptions<TParentRoute extends AnyRoute = AnyRoute, TCustomId extends string = string, TPath extends string = string, TSearchSchema extends Record<string, any> = {}, TFullSearchSchema extends Record<string, any> = TSearchSchema, TParams extends AnyPathParams = AnyPathParams, TAllParams extends AnyPathParams = TParams, TRouteContext extends RouteContext = RouteContext, TAllContext extends Record<string, any> = AnyContext, TLoaderDeps extends Record<string, any> = {}, TLoaderData extends any = unknown> = BaseRouteOptions<TParentRoute, TCustomId, TPath, TSearchSchema, TFullSearchSchema, TParams, TAllParams, TRouteContext, TAllContext, TLoaderDeps, TLoaderData> & UpdatableRouteOptions<NoInfer<TFullSearchSchema>>;
type ParamsFallback<TPath extends string, TParams> = unknown extends TParams ? Record<ParsePathParams<TPath>, string> : TParams;
type BaseRouteOptions<TParentRoute extends AnyRoute = AnyRoute, TCustomId extends string = string, TPath extends string = string, TSearchSchema extends Record<string, any> = {}, TFullSearchSchema extends Record<string, any> = TSearchSchema, TParams extends AnyPathParams = {}, TAllParams = ParamsFallback<TPath, TParams>, TRouteContext extends RouteContext = RouteContext, TAllContext extends Record<string, any> = AnyContext, TLoaderDeps extends Record<string, any> = {}, TLoaderData extends any = unknown> = RoutePathOptions<TCustomId, TPath> & {
    getParentRoute: () => TParentRoute;
    validateSearch?: SearchSchemaValidator<TSearchSchema>;
    shouldReload?: boolean | ((match: LoaderFnContext<TAllParams, TFullSearchSchema, TAllContext, TRouteContext>) => any);
} & (keyof PickRequired<RouteContext> extends never ? {
    beforeLoad?: BeforeLoadFn<TFullSearchSchema, TParentRoute, TAllParams, TRouteContext>;
} : {
    beforeLoad: BeforeLoadFn<TFullSearchSchema, TParentRoute, TAllParams, TRouteContext>;
}) & {
    loaderDeps?: (opts: {
        search: TFullSearchSchema;
    }) => TLoaderDeps;
    loader?: RouteLoaderFn<TAllParams, NoInfer<TLoaderDeps>, NoInfer<TAllContext>, NoInfer<TRouteContext>, TLoaderData>;
} & ({
    parseParams?: (rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>) => TParams extends Record<ParsePathParams<TPath>, any> ? TParams : 'parseParams must return an object';
    stringifyParams?: (params: NoInfer<ParamsFallback<TPath, TParams>>) => Record<ParsePathParams<TPath>, string>;
} | {
    stringifyParams?: never;
    parseParams?: never;
});
type BeforeLoadFn<TFullSearchSchema extends Record<string, any>, TParentRoute extends AnyRoute, TAllParams, TRouteContext> = (opts: {
    search: TFullSearchSchema;
    abortController: AbortController;
    preload: boolean;
    params: TAllParams;
    context: TParentRoute['types']['allContext'];
    location: ParsedLocation;
    navigate: NavigateFn<AnyRoute>;
    buildLocation: BuildLocationFn<TParentRoute>;
    cause: 'preload' | 'enter' | 'stay';
}) => Promise<TRouteContext> | TRouteContext | void;
type UpdatableRouteOptions<TFullSearchSchema extends Record<string, any>> = MetaOptions & {
    caseSensitive?: boolean;
    wrapInSuspense?: boolean;
    component?: RouteComponent;
    errorComponent?: false | null | ErrorRouteComponent;
    pendingComponent?: RouteComponent;
    pendingMs?: number;
    pendingMinMs?: number;
    staleTime?: number;
    gcTime?: number;
    preloadStaleTime?: number;
    preloadGcTime?: number;
    preSearchFilters?: SearchFilter<TFullSearchSchema>[];
    postSearchFilters?: SearchFilter<TFullSearchSchema>[];
    onError?: (err: any) => void;
    onEnter?: (match: AnyRouteMatch) => void;
    onStay?: (match: AnyRouteMatch) => void;
    onLeave?: (match: AnyRouteMatch) => void;
};
type ParseParamsOption<TPath extends string, TParams> = ParseParamsFn<TPath, TParams>;
type ParseParamsFn<TPath extends string, TParams> = (rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>) => TParams extends Record<ParsePathParams<TPath>, any> ? TParams : 'parseParams must return an object';
type ParseParamsObj<TPath extends string, TParams> = {
    parse?: ParseParamsFn<TPath, TParams>;
};
type SearchSchemaValidator<TReturn> = SearchSchemaValidatorObj<TReturn> | SearchSchemaValidatorFn<TReturn>;
type SearchSchemaValidatorObj<TReturn> = {
    parse?: SearchSchemaValidatorFn<TReturn>;
};
type SearchSchemaValidatorFn<TReturn> = (searchObj: Record<string, unknown>) => TReturn;
type DefinedPathParamWarning = 'Path params cannot be redefined by child routes!';
type ParentParams<TParentParams> = AnyPathParams extends TParentParams ? {} : {
    [Key in keyof TParentParams]?: DefinedPathParamWarning;
};
type RouteLoaderFn<TAllParams = {}, TLoaderDeps extends Record<string, any> = {}, TAllContext extends Record<string, any> = AnyContext, TRouteContext extends Record<string, any> = AnyContext, TLoaderData extends any = unknown> = (match: LoaderFnContext<TAllParams, TLoaderDeps, TAllContext, TRouteContext>) => Promise<TLoaderData> | TLoaderData;
interface LoaderFnContext<TAllParams = {}, TLoaderDeps extends Record<string, any> = {}, TAllContext extends Record<string, any> = AnyContext, TRouteContext extends Record<string, any> = AnyContext> {
    abortController: AbortController;
    preload: boolean;
    params: TAllParams;
    deps: TLoaderDeps;
    context: Expand<Assign<TAllContext, TRouteContext>>;
    location: ParsedLocation;
    navigate: (opts: NavigateOptions<AnyRoute>) => Promise<void>;
    parentMatchPromise?: Promise<void>;
    cause: 'preload' | 'enter' | 'stay';
}
type SearchFilter<T, U = T> = (prev: T) => U;
type ResolveId<TParentRoute, TCustomId extends string, TPath extends string> = TParentRoute extends {
    id: infer TParentId extends string;
} ? RoutePrefix<TParentId, string extends TCustomId ? TPath : TCustomId> : RootRouteId;
type InferFullSearchSchema<TRoute> = TRoute extends {
    types: {
        fullSearchSchema: infer TFullSearchSchema;
    };
} ? TFullSearchSchema : {};
type ResolveFullSearchSchema<TParentRoute, TSearchSchema> = Expand<Assign<InferFullSearchSchema<TParentRoute>, TSearchSchema>>;
interface AnyRoute extends Route<any, any, any, any, any, any, any, any, any, any, any, any, any, any, any, any> {
}
type MergeFromFromParent<T, U> = IsAny<T, U, T & U>;
type ResolveAllParams<TParentRoute extends AnyRoute, TParams extends AnyPathParams> = Record<never, string> extends TParentRoute['types']['allParams'] ? TParams : Expand<UnionToIntersection<TParentRoute['types']['allParams'] & TParams> & {}>;
type RouteConstraints = {
    TParentRoute: AnyRoute;
    TPath: string;
    TFullPath: string;
    TCustomId: string;
    TId: string;
    TSearchSchema: AnySearchSchema;
    TFullSearchSchema: AnySearchSchema;
    TParams: Record<string, any>;
    TAllParams: Record<string, any>;
    TParentContext: AnyContext;
    TRouteContext: RouteContext;
    TAllContext: AnyContext;
    TRouterContext: AnyContext;
    TChildren: unknown;
    TRouteTree: AnyRoute;
};
declare class RouteApi<TId extends RouteIds<RegisteredRouter['routeTree']>, TRoute extends AnyRoute = RouteById<RegisteredRouter['routeTree'], TId>, TFullSearchSchema extends Record<string, any> = TRoute['types']['fullSearchSchema'], TAllParams extends AnyPathParams = TRoute['types']['allParams'], TAllContext extends Record<string, any> = TRoute['types']['allContext'], TLoaderDeps extends Record<string, any> = TRoute['types']['loaderDeps'], TLoaderData extends any = TRoute['types']['loaderData']> {
    id: TId;
    constructor({ id }: {
        id: TId;
    });
    useMatch: <TSelected = TAllContext>(opts?: {
        select?: ((s: TAllContext) => TSelected) | undefined;
    } | undefined) => TSelected;
    useRouteContext: <TSelected = TAllContext>(opts?: {
        select?: ((s: TAllContext) => TSelected) | undefined;
    } | undefined) => TSelected;
    useSearch: <TSelected = TFullSearchSchema>(opts?: {
        select?: ((s: TFullSearchSchema) => TSelected) | undefined;
    } | undefined) => TSelected;
    useParams: <TSelected = TAllParams>(opts?: {
        select?: ((s: TAllParams) => TSelected) | undefined;
    } | undefined) => TSelected;
    useLoaderDeps: <TSelected = TLoaderDeps>(opts?: {
        select?: ((s: TLoaderDeps) => TSelected) | undefined;
    } | undefined) => TSelected;
    useLoaderData: <TSelected = TLoaderData>(opts?: {
        select?: ((s: TLoaderData) => TSelected) | undefined;
    } | undefined) => TSelected;
}
declare class Route<TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute, TPath extends RouteConstraints['TPath'] = '/', TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<TParentRoute, TPath>, TCustomId extends RouteConstraints['TCustomId'] = string, TId extends RouteConstraints['TId'] = ResolveId<TParentRoute, TCustomId, TPath>, TSearchSchema extends RouteConstraints['TSearchSchema'] = {}, TFullSearchSchema extends RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchema<TParentRoute, TSearchSchema>, TParams extends RouteConstraints['TParams'] = Expand<Record<ParsePathParams<TPath>, string>>, TAllParams extends RouteConstraints['TAllParams'] = ResolveAllParams<TParentRoute, TParams>, TRouteContext extends RouteConstraints['TRouteContext'] = RouteContext, TAllContext extends Expand<Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>> = Expand<Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>>, TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext, TLoaderDeps extends Record<string, any> = {}, TLoaderData extends any = unknown, TChildren extends RouteConstraints['TChildren'] = unknown, TRouteTree extends RouteConstraints['TRouteTree'] = AnyRoute> {
    isRoot: TParentRoute extends Route<any> ? true : false;
    options: RouteOptions<TParentRoute, TCustomId, TPath, TSearchSchema, TFullSearchSchema, TParams, TAllParams, TRouteContext, TAllContext, TLoaderDeps, TLoaderData>;
    test: Expand<Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>>;
    parentRoute: TParentRoute;
    id: TId;
    path: TPath;
    fullPath: TFullPath;
    to: TrimPathRight<TFullPath>;
    children?: TChildren;
    originalIndex?: number;
    router?: AnyRouter;
    rank: number;
    constructor(options: RouteOptions<TParentRoute, TCustomId, TPath, TSearchSchema, TFullSearchSchema, TParams, TAllParams, TRouteContext, TAllContext, TLoaderDeps, TLoaderData>);
    types: {
        parentRoute: TParentRoute;
        path: TPath;
        to: TrimPathRight<TFullPath>;
        fullPath: TFullPath;
        customId: TCustomId;
        id: TId;
        searchSchema: TSearchSchema;
        fullSearchSchema: TFullSearchSchema;
        params: TParams;
        allParams: TAllParams;
        routeContext: TRouteContext;
        allContext: TAllContext;
        children: TChildren;
        routeTree: TRouteTree;
        routerContext: TRouterContext;
        loaderData: TLoaderData;
        loaderDeps: TLoaderDeps;
    };
    init: (opts: {
        originalIndex: number;
    }) => void;
    addChildren: <TNewChildren extends AnyRoute[]>(children: TNewChildren) => Route<TParentRoute, TPath, TFullPath, TCustomId, TId, TSearchSchema, TFullSearchSchema, TParams, TAllParams, TRouteContext, TAllContext, TRouterContext, TLoaderDeps, TLoaderData, TNewChildren, TRouteTree>;
    update: (options: UpdatableRouteOptions<TFullSearchSchema>) => this;
    useMatch: <TSelected = TAllContext>(opts?: {
        select?: ((search: TAllContext) => TSelected) | undefined;
    } | undefined) => TSelected;
    useRouteContext: <TSelected = TAllContext>(opts?: {
        select?: ((search: TAllContext) => TSelected) | undefined;
    } | undefined) => TSelected;
    useSearch: <TSelected = TFullSearchSchema>(opts?: {
        select?: ((search: TFullSearchSchema) => TSelected) | undefined;
    } | undefined) => TSelected;
    useParams: <TSelected = TAllParams>(opts?: {
        select?: ((search: TAllParams) => TSelected) | undefined;
    } | undefined) => TSelected;
    useLoaderDeps: <TSelected = TLoaderDeps>(opts?: {
        select?: ((s: TLoaderDeps) => TSelected) | undefined;
    } | undefined) => TSelected;
    useLoaderData: <TSelected = TLoaderData>(opts?: {
        select?: ((search: TLoaderData) => TSelected) | undefined;
    } | undefined) => TSelected;
}
type AnyRootRoute = RootRoute<any, any, any, any>;
declare function rootRouteWithContext<TRouterContext extends {}>(): <TSearchSchema extends Record<string, any> = {}, TRouteContext extends RouteContext = RouteContext, TLoaderDeps extends Record<string, any> = {}, TLoaderData extends unknown = unknown>(options?: Omit<RouteOptions<AnyRoute, "__root__", "", TSearchSchema, TSearchSchema, {}, {}, TRouteContext, Assign<TRouterContext, TRouteContext>, TLoaderDeps, TLoaderData>, "path" | "id" | "getParentRoute" | "stringifyParams" | "parseParams" | "caseSensitive"> | undefined) => RootRoute<TSearchSchema, TRouteContext, TRouterContext, {}, unknown>;
declare class RootRoute<TSearchSchema extends Record<string, any> = {}, TRouteContext extends RouteContext = RouteContext, TRouterContext extends {} = {}, TLoaderDeps extends Record<string, any> = {}, TLoaderData extends any = unknown> extends Route<any, // TParentRoute
'/', // TPath
'/', // TFullPath
string, // TCustomId
RootRouteId, // TId
TSearchSchema, // TSearchSchema
TSearchSchema, // TFullSearchSchema
{}, // TParams
{}, // TAllParams
TRouteContext, // TRouteContext
Expand<Assign<TRouterContext, TRouteContext>>, // TAllContext
TRouterContext, // TRouterContext
TLoaderDeps, TLoaderData, any, // TChildren
any> {
    constructor(options?: Omit<RouteOptions<AnyRoute, // TParentRoute
    RootRouteId, // TCustomId
    '', // TPath
    TSearchSchema, // TSearchSchema
    TSearchSchema, // TFullSearchSchema
    {}, // TParams
    {}, // TAllParams
    TRouteContext, // TRouteContext
    Assign<TRouterContext, TRouteContext>, // TAllContext
    TLoaderDeps, TLoaderData>, 'path' | 'id' | 'getParentRoute' | 'caseSensitive' | 'parseParams' | 'stringifyParams'>);
}
type ResolveFullPath<TParentRoute extends AnyRoute, TPath extends string, TPrefixed = RoutePrefix<TParentRoute['fullPath'], TPath>> = TPrefixed extends RootRouteId ? '/' : TPrefixed;
type RoutePrefix<TPrefix extends string, TPath extends string> = string extends TPath ? RootRouteId : TPath extends string ? TPrefix extends RootRouteId ? TPath extends '/' ? '/' : `/${TrimPath<TPath>}` : `${TPrefix}/${TPath}` extends '/' ? '/' : `/${TrimPathLeft<`${TrimPathRight<TPrefix>}/${TrimPath<TPath>}`>}` : never;
type TrimPath<T extends string> = '' extends T ? '' : TrimPathRight<TrimPathLeft<T>>;
type TrimPathLeft<T extends string> = T extends `${RootRouteId}/${infer U}` ? TrimPathLeft<U> : T extends `/${infer U}` ? TrimPathLeft<U> : T;
type TrimPathRight<T extends string> = T extends '/' ? '/' : T extends `${infer U}/` ? TrimPathRight<U> : T;
type RouteMask<TRouteTree extends AnyRoute> = {
    routeTree: TRouteTree;
    from: RoutePaths<TRouteTree>;
    to?: any;
    params?: any;
    search?: any;
    hash?: any;
    state?: any;
    unmaskOnReload?: boolean;
};
declare function createRouteMask<TRouteTree extends AnyRoute, TFrom extends RoutePaths<TRouteTree>, TTo extends string>(opts: {
    routeTree: TRouteTree;
} & ToSubOptions<TRouteTree, TFrom, TTo>): RouteMask<TRouteTree>;
type ErrorRouteProps = {
    error: unknown;
    info: {
        componentStack: string;
    };
};
type ReactNode = any;
type SyncRouteComponent<TProps> = ((props: TProps) => ReactNode) | React$1.LazyExoticComponent<(props: TProps) => ReactNode>;
type AsyncRouteComponent<TProps> = SyncRouteComponent<TProps> & {
    preload?: () => Promise<void>;
};
type RouteComponent<TProps = any> = SyncRouteComponent<TProps> & AsyncRouteComponent<TProps>;
type ErrorRouteComponent = RouteComponent<ErrorRouteProps>;
declare class NotFoundRoute<TParentRoute extends AnyRootRoute, TSearchSchema extends RouteConstraints['TSearchSchema'] = {}, TFullSearchSchema extends RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchema<TParentRoute, TSearchSchema>, TRouteContext extends RouteConstraints['TRouteContext'] = RouteContext, TAllContext extends Expand<Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>> = Expand<Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>>, TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext, TLoaderDeps extends Record<string, any> = {}, TLoaderData extends any = unknown, TChildren extends RouteConstraints['TChildren'] = unknown, TRouteTree extends RouteConstraints['TRouteTree'] = AnyRoute> extends Route<TParentRoute, '/404', '/404', '404', '404', TSearchSchema, TFullSearchSchema, {}, {}, TRouteContext, TAllContext, TRouterContext, TLoaderDeps, TLoaderData, TChildren, TRouteTree> {
    constructor(options: Omit<RouteOptions<TParentRoute, string, string, TSearchSchema, TFullSearchSchema, {}, {}, TRouteContext, TAllContext, TLoaderDeps, TLoaderData>, 'caseSensitive' | 'parseParams' | 'stringifyParams' | 'path' | 'id'>);
}

declare function useNavigate<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TDefaultFrom extends RoutePaths<TRouteTree> = '/'>(defaultOpts?: {
    from?: TDefaultFrom;
}): <TFrom extends RoutePaths<TRouteTree> = TDefaultFrom, TTo extends string = "", TMaskFrom extends RoutePaths<TRouteTree> = "/", TMaskTo extends string = "">(opts?: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> | undefined) => Promise<void>;
declare function Navigate<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = '/', TMaskTo extends string = ''>(props: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>): null;
type UseLinkPropsOptions<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = '/', TMaskTo extends string = ''> = ActiveLinkOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & React$1.AnchorHTMLAttributes<HTMLAnchorElement>;
type LinkProps<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = '/', TMaskTo extends string = ''> = ActiveLinkOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & Omit<React$1.AnchorHTMLAttributes<HTMLAnchorElement>, 'children'> & {
    children?: React$1.ReactNode | ((state: {
        isActive: boolean;
    }) => React$1.ReactNode);
};
type ActiveLinkOptions<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = '/', TMaskTo extends string = ''> = LinkOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {
    activeProps?: React$1.AnchorHTMLAttributes<HTMLAnchorElement> | (() => React$1.AnchorHTMLAttributes<HTMLAnchorElement>);
    inactiveProps?: React$1.AnchorHTMLAttributes<HTMLAnchorElement> | (() => React$1.AnchorHTMLAttributes<HTMLAnchorElement>);
};

type CleanPath<T extends string> = T extends `${infer L}//${infer R}` ? CleanPath<`${CleanPath<L>}/${CleanPath<R>}`> : T extends `${infer L}//` ? `${CleanPath<L>}/` : T extends `//${infer L}` ? `/${CleanPath<L>}` : T;
type Split<S, TIncludeTrailingSlash = true> = S extends unknown ? string extends S ? string[] : S extends string ? CleanPath<S> extends '' ? [] : TIncludeTrailingSlash extends true ? CleanPath<S> extends `${infer T}/` ? [...Split<T>, '/'] : CleanPath<S> extends `/${infer U}` ? Split<U> : CleanPath<S> extends `${infer T}/${infer U}` ? [...Split<T>, ...Split<U>] : [S] : CleanPath<S> extends `${infer T}/${infer U}` ? [...Split<T>, ...Split<U>] : S extends string ? [S] : never : never : never;
type ParsePathParams<T extends string> = keyof {
    [K in Trim<Split<T>[number], '_'> as K extends `$${infer L}` ? L : never]: K;
};
type Join<T, Delimiter extends string = '/'> = T extends [] ? '' : T extends [infer L extends string] ? L : T extends [infer L extends string, ...infer Tail extends [...string[]]] ? CleanPath<`${L}${Delimiter}${Join<Tail>}`> : never;
type Last<T extends any[]> = T extends [...infer _, infer L] ? L : never;
type RelativeToPathAutoComplete<AllPaths extends string, TFrom extends string, TTo extends string, SplitPaths extends string[] = Split<AllPaths, false>> = TTo extends `..${infer _}` ? SplitPaths extends [
    ...Split<ResolveRelativePath<TFrom, TTo>, false>,
    ...infer TToRest
] ? `${CleanPath<Join<[
    ...Split<TTo, false>,
    ...(TToRest | (Split<ResolveRelativePath<TFrom, TTo>, false>['length'] extends 1 ? never : ['../']))
]>>}` : never : TTo extends `./${infer RestTTo}` ? SplitPaths extends [
    ...Split<TFrom, false>,
    ...Split<RestTTo, false>,
    ...infer RestPath
] ? `${TTo}${Join<RestPath>}` : never : (TFrom extends `/` ? never : SplitPaths extends [...Split<TFrom, false>, ...infer RestPath] ? Join<RestPath> extends {
    length: 0;
} ? never : './' : never) | (TFrom extends `/` ? never : '../') | AllPaths;
type NavigateOptions<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = TFrom, TMaskTo extends string = ''> = ToOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {
    replace?: boolean;
    resetScroll?: boolean;
    startTransition?: boolean;
};
type ToOptions<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = '/', TMaskTo extends string = ''> = ToSubOptions<TRouteTree, TFrom, TTo> & {
    mask?: ToMaskOptions<TRouteTree, TMaskFrom, TMaskTo>;
};
type ToMaskOptions<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TMaskFrom extends RoutePaths<TRouteTree> = '/', TMaskTo extends string = ''> = ToSubOptions<TRouteTree, TMaskFrom, TMaskTo> & {
    unmaskOnReload?: boolean;
};
type ToSubOptions<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>> = {
    to?: ToPathOption<TRouteTree, TFrom, TTo>;
    hash?: true | Updater<string>;
    state?: true | NonNullableUpdater<HistoryState>;
    from?: TFrom;
} & CheckPath<TRouteTree, NoInfer<TResolved>, {}> & SearchParamOptions<TRouteTree, TFrom, TTo, TResolved> & PathParamOptions<TRouteTree, TFrom, TResolved>;
type SearchParamOptions<TRouteTree extends AnyRoute, TFrom, TTo, TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>, TFromSearchEnsured = '/' extends TFrom ? FullSearchSchema<TRouteTree> : Expand<PickRequired<RouteByPath<TRouteTree, TFrom>['types']['fullSearchSchema']>>, TFromSearchOptional = Omit<FullSearchSchema<TRouteTree>, keyof TFromSearchEnsured>, TFromSearch = Expand<TFromSearchEnsured & TFromSearchOptional>, TToSearch = '' extends TTo ? FullSearchSchema<TRouteTree> : Expand<RouteByPath<TRouteTree, TResolved>['types']['fullSearchSchema']>> = keyof PickRequired<TToSearch> extends never ? {
    search?: true | SearchReducer<TFromSearch, TToSearch>;
} : {
    search: TFromSearchEnsured extends PickRequired<TToSearch> ? true | SearchReducer<TFromSearch, TToSearch> : SearchReducer<TFromSearch, TToSearch>;
};
type SearchReducer<TFrom, TTo> = TTo | ((current: TFrom) => TTo);
type PathParamOptions<TRouteTree extends AnyRoute, TFrom, TTo, TFromParamsEnsured = Expand<UnionToIntersection<PickRequired<RouteByPath<TRouteTree, TFrom>['types']['allParams']>>>, TFromParamsOptional = Omit<AllParams<TRouteTree>, keyof TFromParamsEnsured>, TFromParams = Expand<TFromParamsOptional & TFromParamsEnsured>, TToParams = Expand<RouteByPath<TRouteTree, TTo>['types']['allParams']>> = never extends TToParams ? {
    params?: true | ParamsReducer<Partial<TFromParams>, Partial<TFromParams>>;
} : keyof PickRequired<TToParams> extends never ? {
    params?: true | ParamsReducer<TFromParams, TToParams>;
} : {
    params: TFromParamsEnsured extends PickRequired<TToParams> ? true | ParamsReducer<TFromParams, TToParams> : ParamsReducer<TFromParams, TToParams>;
};
type ParamsReducer<TFrom, TTo> = TTo | ((current: TFrom) => TTo);
type ToPathOption<TRouteTree extends AnyRoute = AnyRoute, TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = ''> = TTo | RelativeToPathAutoComplete<RoutePaths<TRouteTree>, NoInfer<TFrom> extends string ? NoInfer<TFrom> : '', NoInfer<TTo> & string>;
type ToIdOption<TRouteTree extends AnyRoute = AnyRoute, TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = ''> = TTo | RelativeToPathAutoComplete<RouteIds<TRouteTree>, NoInfer<TFrom> extends string ? NoInfer<TFrom> : '', NoInfer<TTo> & string>;
interface ActiveOptions {
    exact?: boolean;
    includeHash?: boolean;
    includeSearch?: boolean;
}
type LinkOptions<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = TFrom, TMaskTo extends string = ''> = NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {
    target?: HTMLAnchorElement['target'];
    activeOptions?: ActiveOptions;
    preload?: false | 'intent';
    preloadDelay?: number;
    disabled?: boolean;
};
type CheckRelativePath<TRouteTree extends AnyRoute, TFrom, TTo> = TTo extends string ? TFrom extends string ? ResolveRelativePath<TFrom, TTo> extends RoutePaths<TRouteTree> ? {} : {
    Error: `${TFrom} + ${TTo} resolves to ${ResolveRelativePath<TFrom, TTo>}, which is not a valid route path.`;
    'Valid Route Paths': RoutePaths<TRouteTree>;
} : {} : {};
type CheckPath<TRouteTree extends AnyRoute, TPath, TPass> = Exclude<TPath, RoutePaths<TRouteTree>> extends never ? TPass : CheckPathError<TRouteTree, Exclude<TPath, RoutePaths<TRouteTree>>>;
type CheckPathError<TRouteTree extends AnyRoute, TInvalids> = {
    to: RoutePaths<TRouteTree>;
};
type CheckId<TRouteTree extends AnyRoute, TPath, TPass> = Exclude<TPath, RouteIds<TRouteTree>> extends never ? TPass : CheckIdError<TRouteTree, Exclude<TPath, RouteIds<TRouteTree>>>;
type CheckIdError<TRouteTree extends AnyRoute, TInvalids> = {
    Error: `${TInvalids extends string ? TInvalids : never} is not a valid route ID.`;
    'Valid Route IDs': RouteIds<TRouteTree>;
};
type ResolveRelativePath<TFrom, TTo = '.'> = TFrom extends string ? TTo extends string ? TTo extends '.' ? TFrom : TTo extends `./` ? Join<[TFrom, '/']> : TTo extends `./${infer TRest}` ? ResolveRelativePath<TFrom, TRest> : TTo extends `/${infer TRest}` ? TTo : Split<TTo> extends ['..', ...infer ToRest] ? Split<TFrom> extends [...infer FromRest, infer FromTail] ? ToRest extends ['/'] ? Join<[...FromRest, '/']> : ResolveRelativePath<Join<FromRest>, Join<ToRest>> : never : Split<TTo> extends ['.', ...infer ToRest] ? ToRest extends ['/'] ? Join<[TFrom, '/']> : ResolveRelativePath<TFrom, Join<ToRest>> : CleanPath<Join<['/', ...Split<TFrom>, ...Split<TTo>]>> : never : never;
declare function useLinkProps<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = '/', TMaskTo extends string = ''>(options: UseLinkPropsOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>): React$1.AnchorHTMLAttributes<HTMLAnchorElement>;
interface LinkComponent<TProps extends Record<string, any> = {}> {
    <TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = '/', TMaskTo extends string = ''>(props: LinkProps<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & TProps & React$1.RefAttributes<HTMLAnchorElement>): ReactNode;
}
declare const Link: LinkComponent;

declare const matchContext: React$1.Context<string | undefined>;
interface RouteMatch<TRouteTree extends AnyRoute = AnyRoute, TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id']> {
    id: string;
    routeId: TRouteId;
    pathname: string;
    params: RouteById<TRouteTree, TRouteId>['types']['allParams'];
    status: 'pending' | 'success' | 'error';
    isFetching: boolean;
    showPending: boolean;
    error: unknown;
    paramsError: unknown;
    searchError: unknown;
    updatedAt: number;
    loadPromise?: Promise<void>;
    loaderData?: RouteById<TRouteTree, TRouteId>['types']['loaderData'];
    routeContext: RouteById<TRouteTree, TRouteId>['types']['routeContext'];
    context: RouteById<TRouteTree, TRouteId>['types']['allContext'];
    search: FullSearchSchema<TRouteTree> & RouteById<TRouteTree, TRouteId>['types']['fullSearchSchema'];
    fetchCount: number;
    abortController: AbortController;
    cause: 'preload' | 'enter' | 'stay';
    loaderDeps: RouteById<TRouteTree, TRouteId>['types']['loaderDeps'];
    preload: boolean;
    invalid: boolean;
}
type AnyRouteMatch = RouteMatch<any, any>;
declare function Matches(): React$1.JSX.Element;
declare function Match({ matchId }: {
    matchId: string;
}): React$1.JSX.Element;
declare const Outlet: React$1.NamedExoticComponent<object>;
interface MatchRouteOptions {
    pending?: boolean;
    caseSensitive?: boolean;
    includeSearch?: boolean;
    fuzzy?: boolean;
}
type UseMatchRouteOptions<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = '/', TMaskTo extends string = ''> = ToOptions<AnyRoute, TFrom, TTo, TMaskFrom, TMaskTo> & MatchRouteOptions;
declare function useMatchRoute<TRouteTree extends AnyRoute = RegisteredRouter['routeTree']>(): <TFrom extends RoutePaths<TRouteTree> = "/", TTo extends string = "", TMaskFrom extends RoutePaths<TRouteTree> = "/", TMaskTo extends string = "", TResolved extends string = ResolveRelativePath<TFrom, NoInfer<TTo>>>(opts: UseMatchRouteOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>) => false | RouteById<TRouteTree, TResolved>["types"]["allParams"];
type MakeMatchRouteOptions<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = '/', TMaskTo extends string = ''> = ToOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & MatchRouteOptions & {
    children?: ((params?: RouteByPath<TRouteTree, ResolveRelativePath<TFrom, NoInfer<TTo>>>['types']['allParams']) => ReactNode) | React$1.ReactNode;
};
declare function MatchRoute<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = '/', TMaskTo extends string = ''>(props: MakeMatchRouteOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>): any;
declare function useMatch<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>, TStrict extends boolean = true, TRouteMatchState = RouteMatch<TRouteTree, TFrom>, TSelected = TRouteMatchState>(opts: StrictOrFrom<TFrom> & {
    select?: (match: TRouteMatchState) => TSelected;
}): TStrict extends true ? TSelected : TSelected | undefined;
declare function useMatches<T = RouteMatch[]>(opts?: {
    select?: (matches: RouteMatch[]) => T;
}): T;
declare function useParentMatches<T = RouteMatch[]>(opts?: {
    select?: (matches: RouteMatch[]) => T;
}): T;
declare function useLoaderDeps<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>, TStrict extends boolean = true, TRouteMatch extends RouteMatch<TRouteTree, TFrom> = RouteMatch<TRouteTree, TFrom>, TSelected = Required<TRouteMatch>['loaderDeps']>(opts: StrictOrFrom<TFrom> & {
    select?: (match: TRouteMatch) => TSelected;
}): TStrict extends true ? TSelected : TSelected | undefined;
declare function useLoaderData<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>, TStrict extends boolean = true, TRouteMatch extends RouteMatch<TRouteTree, TFrom> = RouteMatch<TRouteTree, TFrom>, TSelected = Required<TRouteMatch>['loaderData']>(opts: StrictOrFrom<TFrom> & {
    select?: (match: TRouteMatch) => TSelected;
}): TStrict extends true ? TSelected : TSelected | undefined;

interface FileRoutesByPath {
}
type Replace<S extends string, From extends string, To extends string> = S extends `${infer Start}${From}${infer Rest}` ? `${Start}${To}${Replace<Rest, From, To>}` : S;
type TrimLeft<T extends string, S extends string> = T extends `${S}${infer U}` ? U : T;
type TrimRight<T extends string, S extends string> = T extends `${infer U}${S}` ? U : T;
type Trim<T extends string, S extends string> = TrimLeft<TrimRight<T, S>, S>;
type RemoveUnderScores<T extends string> = Replace<Replace<TrimRight<TrimLeft<T, '/_'>, '_'>, '_/', '/'>, '/_', '/'>;
type ResolveFilePath<TParentRoute extends AnyRoute, TFilePath extends string> = TParentRoute['id'] extends RootRouteId ? TrimPathLeft<TFilePath> : Replace<TrimPathLeft<TFilePath>, TrimPathLeft<TParentRoute['types']['customId']>, ''>;
type FileRoutePath<TParentRoute extends AnyRoute, TFilePath extends string> = ResolveFilePath<TParentRoute, TFilePath> extends `_${infer _}` ? string : ResolveFilePath<TParentRoute, TFilePath>;
declare class FileRoute<TFilePath extends keyof FileRoutesByPath, TParentRoute extends AnyRoute = FileRoutesByPath[TFilePath]['parentRoute'], TId extends RouteConstraints['TId'] = TFilePath, TPath extends RouteConstraints['TPath'] = FileRoutePath<TParentRoute, TFilePath>, TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<TParentRoute, RemoveUnderScores<TPath>>> {
    path: TFilePath;
    constructor(path: TFilePath);
    createRoute: <TSearchSchema extends AnySearchSchema = {}, TFullSearchSchema extends AnySearchSchema = ResolveFullSearchSchema<TParentRoute, TSearchSchema>, TParams extends Record<string, any> = Expand<Record<ParsePathParams<TPath>, string>>, TAllParams extends Record<string, any> = MergeFromFromParent<TParentRoute["types"]["allParams"], TParams>, TRouteContext extends RouteContext = RouteContext, TContext extends Expand<Assign<IsAny<TParentRoute["types"]["allContext"], {}>, TRouteContext>> = Expand<Assign<IsAny<TParentRoute["types"]["allContext"], {}>, TRouteContext>>, TRouterContext extends AnyContext = AnyContext, TLoaderDeps extends Record<string, any> = {}, TLoaderData extends unknown = unknown, TChildren extends unknown = unknown, TRouteTree extends AnyRoute = AnyRoute>(options?: (Omit<RouteOptions<TParentRoute, string, TPath, TSearchSchema, TFullSearchSchema, TParams, TAllParams, TRouteContext, TContext, TLoaderDeps, TLoaderData>, "path" | "id" | "getParentRoute"> & {
        meta?: RouteMeta | undefined;
    } & {
        caseSensitive?: boolean | undefined;
        wrapInSuspense?: boolean | undefined;
        component?: RouteComponent<any> | undefined;
        errorComponent?: false | ErrorRouteComponent | null | undefined;
        pendingComponent?: RouteComponent<any> | undefined;
        pendingMs?: number | undefined;
        pendingMinMs?: number | undefined;
        staleTime?: number | undefined;
        gcTime?: number | undefined;
        preloadStaleTime?: number | undefined;
        preloadGcTime?: number | undefined;
        preSearchFilters?: SearchFilter<TFullSearchSchema, TFullSearchSchema>[] | undefined;
        postSearchFilters?: SearchFilter<TFullSearchSchema, TFullSearchSchema>[] | undefined;
        onError?: ((err: any) => void) | undefined;
        onEnter?: ((match: AnyRouteMatch) => void) | undefined;
        onStay?: ((match: AnyRouteMatch) => void) | undefined;
        onLeave?: ((match: AnyRouteMatch) => void) | undefined;
    }) | undefined) => Route<TParentRoute, TPath, TFullPath, TFilePath, TId, TSearchSchema, TFullSearchSchema, TParams, TAllParams, TRouteContext, TContext, TRouterContext, TLoaderDeps, TLoaderData, TChildren, TRouteTree>;
}

declare module '@tanstack/history' {
    interface HistoryState {
        __tempLocation?: HistoryLocation;
        __tempKey?: string;
    }
}

declare function lazyRouteComponent<T extends Record<string, any>, TKey extends keyof T = 'default'>(importer: () => Promise<T>, exportName?: TKey): T[TKey] extends (props: infer TProps) => any ? AsyncRouteComponent<TProps> : never;

interface Segment {
    type: 'pathname' | 'param' | 'wildcard';
    value: string;
}
declare function joinPaths(paths: (string | undefined)[]): string;
declare function cleanPath(path: string): string;
declare function trimPathLeft(path: string): string;
declare function trimPathRight(path: string): string;
declare function trimPath(path: string): string;
declare function resolvePath(basepath: string, base: string, to: string): string;
declare function parsePathname(pathname?: string): Segment[];
declare function interpolatePath(path: string | undefined, params: any, leaveWildcards?: boolean): string;
declare function matchPathname(basepath: string, currentPathname: string, matchLocation: Pick<MatchLocation, 'to' | 'fuzzy' | 'caseSensitive'>): AnyPathParams | undefined;
declare function removeBasepath(basepath: string, pathname: string): string;
declare function matchByPath(basepath: string, from: string, matchLocation: Pick<MatchLocation, 'to' | 'caseSensitive' | 'fuzzy'>): Record<string, string> | undefined;

declare function encode(obj: any, pfx?: string): string;
declare function decode(str: any): {};

type AnyRedirect = Redirect<any, any, any, any, any>;
type Redirect<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = TFrom, TMaskTo extends string = ''> = {
    code?: number;
    throw?: any;
} & NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>;
declare function redirect<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = TFrom, TMaskTo extends string = ''>(opts: Redirect<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>): Redirect<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>;
declare function isRedirect(obj: any): obj is AnyRedirect;

type ScrollRestorationOptions = {
    getKey?: (location: ParsedLocation) => string;
};
declare function useScrollRestoration(options?: ScrollRestorationOptions): void;
declare function ScrollRestoration(props: ScrollRestorationOptions): null;
declare function useElementScrollRestoration(options: ({
    id: string;
    getElement?: () => Element | undefined | null;
} | {
    id?: string;
    getElement: () => Element | undefined | null;
}) & {
    getKey?: (location: ParsedLocation) => string;
}): {
    scrollX: number;
    scrollY: number;
} | undefined;

declare function useBlocker(blockerFn: BlockerFn, condition?: boolean | any): void;
declare function Block({ blocker, condition, children }: PromptProps): any;
type PromptProps = {
    blocker: BlockerFn;
    condition?: boolean | any;
    children?: ReactNode;
};

declare function useParams<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>, TDefaultSelected = AllParams<TRouteTree> & RouteById<TRouteTree, TFrom>['types']['allParams'], TSelected = TDefaultSelected>(opts: StrictOrFrom<TFrom> & {
    select?: (search: TDefaultSelected) => TSelected;
}): TSelected;

declare function useSearch<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>, TStrict extends boolean = true, TSearch = RouteById<TRouteTree, TFrom>['types']['fullSearchSchema'], TSelected = TSearch>(opts: StrictOrFrom<TFrom> & {
    select?: (search: TSearch) => TSelected;
}): TStrict extends true ? TSelected : TSelected | undefined;

export { type ActiveLinkOptions, type ActiveOptions, type AllParams, type AnyContext, type AnyPathParams, type AnyRedirect, type AnyRootRoute, type AnyRoute, type AnyRouteMatch, type AnyRouter, type AnySearchSchema, type Assign, type AssignAll, type AsyncRouteComponent, Await, type AwaitOptions, type BaseRouteOptions, Block, type BuildLocationFn, type BuildNextOptions, CatchBoundary, CatchBoundaryImpl, type CheckId, type CheckIdError, type CheckPath, type CheckPathError, type CheckRelativePath, type CleanPath, type CommitLocationOptions, type DeepAwaited, type DeferredPromise, type DeferredPromiseState, type DefinedPathParamWarning, type DehydratedRouteMatch, type DehydratedRouter, type DehydratedRouterState, ErrorComponent, type ErrorRouteComponent, type ErrorRouteProps, type Expand, FileRoute, type FileRoutePath, type FileRoutesByPath, type FullSearchSchema, type HydrationCtx, type InferFullSearchSchema, type InjectedHtmlEntry, type IsAny, type IsAnyBoolean, type IsKnown, type Join, type Last, Link, type LinkComponent, type LinkOptions, type LinkProps, type ListenerFn, type LoaderFnContext, type MakeMatchRouteOptions, Match, type MatchLocation, MatchRoute, type MatchRouteFn, type MatchRouteOptions, Matches, type MergeFromFromParent, type MetaOptions, Navigate, type NavigateFn, type NavigateOptions, type NoInfer, type NonNullableUpdater, NotFoundRoute, Outlet, type ParamsFallback, type ParentParams, type ParseParamsFn, type ParseParamsObj, type ParseParamsOption, type ParsePathParams, type ParseRoute, type ParseRouteChildren, type ParsedLocation, PathParamError, type PathParamMask, type PathParamOptions, type PickAsPartial, type PickAsRequired, type PickExclude, type PickExtra, type PickExtract, type PickRequired, type PickUnsafe, type PreloadableObj, type PromptProps, type ReactNode, type Redirect, type Register, type RegisteredRouter, type RelativeToPathAutoComplete, type RemoveUnderScores, type ResolveAllParams, type ResolveFilePath, type ResolveFullPath, type ResolveFullSearchSchema, type ResolveId, type ResolveRelativePath, RootRoute, type RootRouteId, Route, RouteApi, type RouteById, type RouteByPath, type RouteComponent, type RouteConstraints, type RouteContext, type RouteFromIdOrRoute, type RouteIds, type RouteLoaderFn, type RouteMask, type RouteMatch, type RouteMeta, type RouteOptions, type RoutePathOptions, type RoutePathOptionsIntersection, type RoutePaths, Router, type RouterConstructorOptions, type RouterContextOptions, type RouterEvent, type RouterEvents, type RouterListener, type RouterOptions, type RouterProps, RouterProvider, type RouterState, type RoutesById, type RoutesByPath, ScrollRestoration, type ScrollRestorationOptions, type SearchFilter, SearchParamError, type SearchParamOptions, type SearchParser, type SearchSchemaValidator, type SearchSchemaValidatorFn, type SearchSchemaValidatorObj, type SearchSerializer, type Segment, type Split, type StrictOrFrom, type SyncRouteComponent, type Timeout, type ToIdOption, type ToMaskOptions, type ToOptions, type ToPathOption, type ToSubOptions, type Trim, type TrimLeft, type TrimPath, type TrimPathLeft, type TrimPathRight, type TrimRight, type UnionToIntersection, type UnionToTuple, type UpdatableRouteOptions, type Updater, type UseLinkPropsOptions, type UseMatchRouteOptions, type ValueKeys, type Values, cleanPath, componentTypes, createRouteMask, decode, deepEqual, defaultParseSearch, defaultStringifySearch, defer, encode, escapeJSON, functionalUpdate, getInitialRouterState, getRouteMatch, interpolatePath, isDehydratedDeferred, isPlainObject, isRedirect, isServer, joinPaths, last, lazyFn, lazyRouteComponent, matchByPath, matchContext, matchPathname, parsePathname, parseSearchWith, pick, redirect, removeBasepath, replaceEqualDeep, resolvePath, rootRouteId, rootRouteWithContext, routerContext, shallow, stringifySearchWith, trimPath, trimPathLeft, trimPathRight, useAwaited, useBlocker, useElementScrollRestoration, useLayoutEffect, useLinkProps, useLoaderData, useLoaderDeps, useMatch, useMatchRoute, useMatches, useNavigate, useParams, useParentMatches, useRouteContext, useRouter, useRouterState, useScrollRestoration, useSearch, useStableCallback };
