import * as React from 'react';
import { ResolveRelativePath, ToOptions } from './link';
import { AnyRoute, ReactNode } from './route';
import { FullSearchSchema, ParseRoute, RouteById, RouteByPath, RouteIds, RoutePaths } from './routeInfo';
import { RegisteredRouter } from './router';
import { NoInfer, StrictOrFrom } from './utils';
export declare const matchContext: React.Context<string | undefined>;
export interface RouteMatch<TRouteTree extends AnyRoute = AnyRoute, TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id']> {
    id: string;
    routeId: TRouteId;
    pathname: string;
    params: RouteById<TRouteTree, TRouteId>['types']['allParams'];
    status: 'pending' | 'success' | 'error';
    isFetching: boolean;
    showPending: boolean;
    error: unknown;
    paramsError: unknown;
    searchError: unknown;
    updatedAt: number;
    loadPromise?: Promise<void>;
    loaderData?: RouteById<TRouteTree, TRouteId>['types']['loaderData'];
    routeContext: RouteById<TRouteTree, TRouteId>['types']['routeContext'];
    context: RouteById<TRouteTree, TRouteId>['types']['allContext'];
    search: FullSearchSchema<TRouteTree> & RouteById<TRouteTree, TRouteId>['types']['fullSearchSchema'];
    fetchCount: number;
    abortController: AbortController;
    cause: 'preload' | 'enter' | 'stay';
    loaderDeps: RouteById<TRouteTree, TRouteId>['types']['loaderDeps'];
    preload: boolean;
    invalid: boolean;
}
export type AnyRouteMatch = RouteMatch<any, any>;
export declare function Matches(): React.JSX.Element;
export declare function Match({ matchId }: {
    matchId: string;
}): React.JSX.Element;
export declare const Outlet: React.NamedExoticComponent<object>;
export interface MatchRouteOptions {
    pending?: boolean;
    caseSensitive?: boolean;
    includeSearch?: boolean;
    fuzzy?: boolean;
}
export type UseMatchRouteOptions<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = '/', TMaskTo extends string = ''> = ToOptions<AnyRoute, TFrom, TTo, TMaskFrom, TMaskTo> & MatchRouteOptions;
export declare function useMatchRoute<TRouteTree extends AnyRoute = RegisteredRouter['routeTree']>(): <TFrom extends RoutePaths<TRouteTree> = "/", TTo extends string = "", TMaskFrom extends RoutePaths<TRouteTree> = "/", TMaskTo extends string = "", TResolved extends string = ResolveRelativePath<TFrom, NoInfer<TTo>>>(opts: UseMatchRouteOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>) => false | RouteById<TRouteTree, TResolved>["types"]["allParams"];
export type MakeMatchRouteOptions<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = '/', TMaskTo extends string = ''> = ToOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & MatchRouteOptions & {
    children?: ((params?: RouteByPath<TRouteTree, ResolveRelativePath<TFrom, NoInfer<TTo>>>['types']['allParams']) => ReactNode) | React.ReactNode;
};
export declare function MatchRoute<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = '/', TMaskTo extends string = ''>(props: MakeMatchRouteOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>): any;
export declare function useMatch<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>, TStrict extends boolean = true, TRouteMatchState = RouteMatch<TRouteTree, TFrom>, TSelected = TRouteMatchState>(opts: StrictOrFrom<TFrom> & {
    select?: (match: TRouteMatchState) => TSelected;
}): TStrict extends true ? TSelected : TSelected | undefined;
export declare function useMatches<T = RouteMatch[]>(opts?: {
    select?: (matches: RouteMatch[]) => T;
}): T;
export declare function useParentMatches<T = RouteMatch[]>(opts?: {
    select?: (matches: RouteMatch[]) => T;
}): T;
export declare function useLoaderDeps<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>, TStrict extends boolean = true, TRouteMatch extends RouteMatch<TRouteTree, TFrom> = RouteMatch<TRouteTree, TFrom>, TSelected = Required<TRouteMatch>['loaderDeps']>(opts: StrictOrFrom<TFrom> & {
    select?: (match: TRouteMatch) => TSelected;
}): TStrict extends true ? TSelected : TSelected | undefined;
export declare function useLoaderData<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>, TStrict extends boolean = true, TRouteMatch extends RouteMatch<TRouteTree, TFrom> = RouteMatch<TRouteTree, TFrom>, TSelected = Required<TRouteMatch>['loaderData']>(opts: StrictOrFrom<TFrom> & {
    select?: (match: TRouteMatch) => TSelected;
}): TStrict extends true ? TSelected : TSelected | undefined;
