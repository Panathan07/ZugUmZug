import * as React from 'react';
import { LinkOptions, ToOptions, ResolveRelativePath, NavigateOptions } from './link';
import { AnySearchSchema, AnyPathParams, AnyContext, AnyRoute } from './route';
import { RoutePaths, RouteByPath, RouteIds, ParseRoute, RoutesById, RouteById, AllParams } from './routeInfo';
import { RegisteredRouter, RouterOptions, Router, RouterState } from './router';
import { RouteMatch } from './RouteMatch';
import { NoInfer } from './utils';
import { MatchRouteOptions, RouterContext } from './RouterProvider';
export type RouteProps<TFullSearchSchema extends Record<string, any> = AnySearchSchema, TAllParams extends AnyPathParams = AnyPathParams, TAllContext extends Record<string, any> = AnyContext> = {
    useMatch: <TSelected = TAllContext>(opts?: {
        select?: (search: TAllContext) => TSelected;
    }) => TSelected;
    useRouteContext: <TSelected = TAllContext>(opts?: {
        select?: (search: TAllContext) => TSelected;
    }) => TSelected;
    useSearch: <TSelected = TFullSearchSchema>(opts?: {
        select?: (search: TFullSearchSchema) => TSelected;
    }) => TSelected;
    useParams: <TSelected = TAllParams>(opts?: {
        select?: (search: TAllParams) => TSelected;
    }) => TSelected;
};
export type ErrorRouteProps<TFullSearchSchema extends Record<string, any> = AnySearchSchema, TAllParams extends AnyPathParams = AnyPathParams, TAllContext extends Record<string, any> = AnyContext> = {
    error: unknown;
    info: {
        componentStack: string;
    };
} & RouteProps<TFullSearchSchema, TAllParams, TAllContext>;
export type PendingRouteProps<TFullSearchSchema extends Record<string, any> = AnySearchSchema, TAllParams extends AnyPathParams = AnyPathParams, TAllContext extends Record<string, any> = AnyContext> = RouteProps<TFullSearchSchema, TAllParams, TAllContext>;
type ReactNode = any;
export type SyncRouteComponent<TProps> = ((props: TProps) => ReactNode) | React.LazyExoticComponent<(props: TProps) => ReactNode>;
export type AsyncRouteComponent<TProps> = SyncRouteComponent<TProps> & {
    preload?: () => Promise<void>;
};
export type RouteComponent<TFullSearchSchema extends Record<string, any>, TAllParams extends AnyPathParams, TAllContext extends Record<string, any>> = AsyncRouteComponent<RouteProps<TFullSearchSchema, TAllParams, TAllContext>>;
export type ErrorRouteComponent<TFullSearchSchema extends Record<string, any>, TAllParams extends AnyPathParams, TAllContext extends Record<string, any>> = AsyncRouteComponent<ErrorRouteProps<TFullSearchSchema, TAllParams, TAllContext>>;
export type PendingRouteComponent<TFullSearchSchema extends Record<string, any>, TAllParams extends AnyPathParams, TAllContext extends Record<string, any>> = AsyncRouteComponent<PendingRouteProps<TFullSearchSchema, TAllParams, TAllContext>>;
export type AnyRouteComponent = RouteComponent<any, any, any>;
export declare function lazyRouteComponent<T extends Record<string, any>, TKey extends keyof T = 'default'>(importer: () => Promise<T>, exportName?: TKey): T[TKey] extends (props: infer TProps) => any ? AsyncRouteComponent<TProps> : never;
export type LinkPropsOptions<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = '/', TMaskTo extends string = ''> = LinkOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {
    activeProps?: React.AnchorHTMLAttributes<HTMLAnchorElement> | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>);
    inactiveProps?: React.AnchorHTMLAttributes<HTMLAnchorElement> | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>);
    startTransition?: boolean;
};
export type MakeUseMatchRouteOptions<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = '/', TMaskTo extends string = ''> = ToOptions<AnyRoute, TFrom, TTo, TMaskFrom, TMaskTo> & MatchRouteOptions;
export type MakeMatchRouteOptions<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = '/', TMaskTo extends string = ''> = ToOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & MatchRouteOptions & {
    children?: ((params?: RouteByPath<TRouteTree, ResolveRelativePath<TFrom, NoInfer<TTo>>>['types']['allParams']) => ReactNode) | React.ReactNode;
};
export type MakeLinkPropsOptions<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = '/', TMaskTo extends string = ''> = LinkPropsOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & React.AnchorHTMLAttributes<HTMLAnchorElement>;
export type MakeLinkOptions<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = '/', TMaskTo extends string = ''> = LinkPropsOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & Omit<React.AnchorHTMLAttributes<HTMLAnchorElement>, 'children'> & {
    children?: React.ReactNode | ((state: {
        isActive: boolean;
    }) => React.ReactNode);
};
export type PromptProps = {
    message: string;
    condition?: boolean | any;
    children?: ReactNode;
};
export declare function useLinkProps<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = '/', TMaskTo extends string = ''>(options: MakeLinkPropsOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>): React.AnchorHTMLAttributes<HTMLAnchorElement>;
export interface LinkComponent<TProps extends Record<string, any> = {}> {
    <TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = '/', TMaskTo extends string = ''>(props: MakeLinkOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & TProps & React.RefAttributes<HTMLAnchorElement>): ReactNode;
}
export declare const Link: LinkComponent;
export declare function Navigate<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = '/', TMaskTo extends string = ''>(props: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>): null;
export declare const matchesContext: React.Context<RouteMatch<AnyRoute, any>[]>;
export type RouterProps<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TDehydrated extends Record<string, any> = Record<string, any>> = Omit<RouterOptions<TRouteTree, TDehydrated>, 'context'> & {
    router: Router<TRouteTree>;
    context?: Partial<RouterOptions<TRouteTree, TDehydrated>['context']>;
};
export declare function useRouter<TRouteTree extends AnyRoute = RegisteredRouter['routeTree']>(): RouterContext<TRouteTree>;
export declare function useRouterState<TSelected = RouterState<RegisteredRouter['routeTree']>>(opts?: {
    select: (state: RouterState<RegisteredRouter['routeTree']>) => TSelected;
}): TSelected;
export declare function useMatches<T = RouteMatch[]>(opts?: {
    select?: (matches: RouteMatch[]) => T;
}): T;
type StrictOrFrom<TFrom> = {
    from: TFrom;
    strict?: true;
} | {
    from?: never;
    strict: false;
};
export declare function useMatch<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>, TStrict extends boolean = true, TRouteMatchState = RouteMatch<TRouteTree, TFrom>, TSelected = TRouteMatchState>(opts: StrictOrFrom<TFrom> & {
    select?: (match: TRouteMatchState) => TSelected;
}): TStrict extends true ? TRouteMatchState : TRouteMatchState | undefined;
export type RouteFromIdOrRoute<T, TRouteTree extends AnyRoute = RegisteredRouter['routeTree']> = T extends ParseRoute<TRouteTree> ? T : T extends RouteIds<TRouteTree> ? RoutesById<TRouteTree>[T] : T extends string ? RouteIds<TRouteTree> : never;
export declare function useRouteContext<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>, TStrict extends boolean = true, TRouteContext = RouteById<TRouteTree, TFrom>['types']['allContext'], TSelected = TRouteContext>(opts: StrictOrFrom<TFrom> & {
    select?: (search: TRouteContext) => TSelected;
}): TStrict extends true ? TSelected : TSelected | undefined;
export declare function useSearch<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>, TStrict extends boolean = true, TSearch = RouteById<TRouteTree, TFrom>['types']['fullSearchSchema'], TSelected = TSearch>(opts: StrictOrFrom<TFrom> & {
    select?: (search: TSearch) => TSelected;
}): TStrict extends true ? TSelected : TSelected | undefined;
export declare function useParams<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>, TDefaultSelected = AllParams<TRouteTree> & RouteById<TRouteTree, TFrom>['types']['allParams'], TSelected = TDefaultSelected>(opts: StrictOrFrom<TFrom> & {
    select?: (search: TDefaultSelected) => TSelected;
}): TSelected;
export declare function useNavigate<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TDefaultFrom extends RoutePaths<TRouteTree> = '/'>(defaultOpts?: {
    from?: TDefaultFrom;
}): <TFrom extends RoutePaths<TRouteTree> = TDefaultFrom, TTo extends string = "", TMaskFrom extends RoutePaths<TRouteTree> = "/", TMaskTo extends string = "">(opts?: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> | undefined) => Promise<void>;
export declare function typedNavigate<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TDefaultFrom extends RoutePaths<TRouteTree> = '/'>(navigate: (opts: NavigateOptions<any>) => Promise<void>): <TFrom extends RoutePaths<TRouteTree> = TDefaultFrom, TTo extends string = "", TMaskFrom extends RoutePaths<TRouteTree> = "/", TMaskTo extends string = "">(opts?: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> | undefined) => Promise<void>;
export declare function useMatchRoute<TRouteTree extends AnyRoute = RegisteredRouter['routeTree']>(): <TFrom extends RoutePaths<TRouteTree> = "/", TTo extends string = "", TMaskFrom extends RoutePaths<TRouteTree> = "/", TMaskTo extends string = "", TResolved extends string = ResolveRelativePath<TFrom, NoInfer<TTo>>>(opts: MakeUseMatchRouteOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>) => false | RouteById<TRouteTree, TResolved>["types"]["allParams"];
export declare function Matches(): JSX.Element;
export declare function MatchRoute<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = '/', TMaskTo extends string = ''>(props: MakeMatchRouteOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>): any;
export declare function Outlet(): JSX.Element | null;
export declare function CatchBoundary(props: {
    resetKey: string;
    children: any;
    errorComponent?: any;
    onCatch: (error: any) => void;
}): JSX.Element;
export declare class CatchBoundaryImpl extends React.Component<{
    resetKey: string;
    children: (props: {
        error: any;
        reset: () => void;
    }) => any;
    onCatch?: (error: any) => void;
}> {
    state: any;
    static getDerivedStateFromError(error: any): {
        error: any;
    };
    componentDidUpdate(prevProps: Readonly<{
        resetKey: string;
        children: (props: {
            error: any;
            reset: () => void;
        }) => any;
        onCatch?: ((error: any, info: any) => void) | undefined;
    }>, prevState: any): void;
    componentDidCatch(error: any): void;
    render(): any;
}
export declare function ErrorComponent({ error }: {
    error: any;
}): JSX.Element;
export declare function useBlocker(message: string, condition?: boolean | any): void;
export declare function Block({ message, condition, children }: PromptProps): any;
export declare function shallow<T>(objA: T, objB: T): boolean;
export {};
