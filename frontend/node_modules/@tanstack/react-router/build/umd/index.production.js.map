{"version":3,"file":"index.production.js","sources":["../../../history/build/esm/index.js","../../../../node_modules/.pnpm/tiny-invariant@1.3.1/node_modules/tiny-invariant/dist/esm/tiny-invariant.js","../../../../node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/shim/with-selector.js","../../../../node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.min.js","../../../../node_modules/.pnpm/@tanstack+store@0.1.3/node_modules/@tanstack/store/build/modern/index.js","../../../../node_modules/.pnpm/@tanstack+react-store@0.2.1_react-dom@18.2.0_react@18.2.0/node_modules/@tanstack/react-store/build/modern/index.js","../../src/CatchBoundary.tsx","../../src/utils.ts","../../src/Matches.tsx","../../src/RouterProvider.tsx","../../src/defer.ts","../../src/awaited.tsx","../../src/path.ts","../../src/useParams.tsx","../../src/useSearch.tsx","../../src/route.ts","../../src/link.tsx","../../src/qss.ts","../../src/redirects.ts","../../src/searchParams.ts","../../src/router.ts","../../src/scroll-restoration.tsx","../../src/useBlocker.tsx","../../src/fileRoute.ts","../../src/useNavigate.tsx","../../src/lazyRouteComponent.tsx","../../../../node_modules/.pnpm/tiny-warning@1.0.3/node_modules/tiny-warning/dist/tiny-warning.esm.js"],"sourcesContent":["/**\n * @tanstack/history/src/index.ts\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n// While the public API was clearly inspired by the \"history\" npm package,\n// This implementation attempts to be more lightweight by\n// making assumptions about the way TanStack Router works\n\nconst pushStateEvent = 'pushstate';\nconst popStateEvent = 'popstate';\nconst beforeUnloadEvent = 'beforeunload';\nconst beforeUnloadListener = event => {\n  event.preventDefault();\n  // @ts-ignore\n  return event.returnValue = '';\n};\nconst stopBlocking = () => {\n  removeEventListener(beforeUnloadEvent, beforeUnloadListener, {\n    capture: true\n  });\n};\nfunction createHistory(opts) {\n  let location = opts.getLocation();\n  let subscribers = new Set();\n  let blockers = [];\n  const onUpdate = () => {\n    location = opts.getLocation();\n    subscribers.forEach(subscriber => subscriber());\n  };\n  const tryNavigation = async task => {\n    if (typeof document !== 'undefined' && blockers.length) {\n      for (let blocker of blockers) {\n        const allowed = await blocker();\n        if (!allowed) {\n          opts.onBlocked?.(onUpdate);\n          return;\n        }\n      }\n    }\n    task();\n  };\n  return {\n    get location() {\n      return location;\n    },\n    subscribe: cb => {\n      subscribers.add(cb);\n      return () => {\n        subscribers.delete(cb);\n      };\n    },\n    push: (path, state) => {\n      state = assignKey(state);\n      tryNavigation(() => {\n        opts.pushState(path, state, onUpdate);\n      });\n    },\n    replace: (path, state) => {\n      state = assignKey(state);\n      tryNavigation(() => {\n        opts.replaceState(path, state, onUpdate);\n      });\n    },\n    go: index => {\n      tryNavigation(() => {\n        opts.go(index);\n      });\n    },\n    back: () => {\n      tryNavigation(() => {\n        opts.back();\n      });\n    },\n    forward: () => {\n      tryNavigation(() => {\n        opts.forward();\n      });\n    },\n    createHref: str => opts.createHref(str),\n    block: blocker => {\n      blockers.push(blocker);\n      if (blockers.length === 1) {\n        addEventListener(beforeUnloadEvent, beforeUnloadListener, {\n          capture: true\n        });\n      }\n      return () => {\n        blockers = blockers.filter(b => b !== blocker);\n        if (!blockers.length) {\n          stopBlocking();\n        }\n      };\n    },\n    flush: () => opts.flush?.(),\n    destroy: () => opts.destroy?.(),\n    notify: onUpdate\n  };\n}\nfunction assignKey(state) {\n  if (!state) {\n    state = {};\n  }\n  return {\n    ...state,\n    key: createRandomKey()\n  };\n}\n\n/**\n * Creates a history object that can be used to interact with the browser's\n * navigation. This is a lightweight API wrapping the browser's native methods.\n * It is designed to work with TanStack Router, but could be used as a standalone API as well.\n * IMPORTANT: This API implements history throttling via a microtask to prevent\n * excessive calls to the history API. In some browsers, calling history.pushState or\n * history.replaceState in quick succession can cause the browser to ignore subsequent\n * calls. This API smooths out those differences and ensures that your application\n * state will *eventually* match the browser state. In most cases, this is not a problem,\n * but if you need to ensure that the browser state is up to date, you can use the\n * `history.flush` method to immediately flush all pending state changes to the browser URL.\n * @param opts\n * @param opts.getHref A function that returns the current href (path + search + hash)\n * @param opts.createHref A function that takes a path and returns a href (path + search + hash)\n * @returns A history instance\n */\nfunction createBrowserHistory(opts) {\n  const win = opts?.window ?? (typeof document !== 'undefined' ? window : undefined);\n  const createHref = opts?.createHref ?? (path => path);\n  const parseLocation = opts?.parseLocation ?? (() => parseHref(`${win.location.pathname}${win.location.search}${win.location.hash}`, win.history.state));\n  let currentLocation = parseLocation();\n  let rollbackLocation;\n  const getLocation = () => currentLocation;\n  let next;\n\n  // Because we are proactively updating the location\n  // in memory before actually updating the browser history,\n  // we need to track when we are doing this so we don't\n  // notify subscribers twice on the last update.\n  let tracking = true;\n\n  // We need to track the current scheduled update to prevent\n  // multiple updates from being scheduled at the same time.\n  let scheduled;\n\n  // This function is a wrapper to prevent any of the callback's\n  // side effects from causing a subscriber notification\n  const untrack = fn => {\n    tracking = false;\n    fn();\n    tracking = true;\n  };\n\n  // This function flushes the next update to the browser history\n  const flush = () => {\n    // Do not notify subscribers about this push/replace call\n    untrack(() => {\n      if (!next) return;\n      win.history[next.isPush ? 'pushState' : 'replaceState'](next.state, '', next.href);\n      // Reset the nextIsPush flag and clear the scheduled update\n      next = undefined;\n      scheduled = undefined;\n      rollbackLocation = undefined;\n    });\n  };\n\n  // This function queues up a call to update the browser history\n  const queueHistoryAction = (type, destHref, state, onUpdate) => {\n    const href = createHref(destHref);\n    if (!scheduled) {\n      rollbackLocation = currentLocation;\n    }\n\n    // Update the location in memory\n    currentLocation = parseHref(destHref, state);\n\n    // Keep track of the next location we need to flush to the URL\n    next = {\n      href,\n      state,\n      isPush: next?.isPush || type === 'push'\n    };\n\n    // Notify subscribers\n    onUpdate();\n    if (!scheduled) {\n      // Schedule an update to the browser history\n      scheduled = Promise.resolve().then(() => flush());\n    }\n  };\n  const onPushPop = () => {\n    currentLocation = parseLocation();\n    history.notify();\n  };\n  var originalPushState = win.history.pushState;\n  var originalReplaceState = win.history.replaceState;\n  const history = createHistory({\n    getLocation,\n    pushState: (href, state, onUpdate) => queueHistoryAction('push', href, state, onUpdate),\n    replaceState: (href, state, onUpdate) => queueHistoryAction('replace', href, state, onUpdate),\n    back: () => win.history.back(),\n    forward: () => win.history.forward(),\n    go: n => win.history.go(n),\n    createHref: href => createHref(href),\n    flush,\n    destroy: () => {\n      win.history.pushState = originalPushState;\n      win.history.replaceState = originalReplaceState;\n      win.removeEventListener(pushStateEvent, onPushPop);\n      win.removeEventListener(popStateEvent, onPushPop);\n    },\n    onBlocked: onUpdate => {\n      // If a navigation is blocked, we need to rollback the location\n      // that we optimistically updated in memory.\n      if (rollbackLocation && currentLocation !== rollbackLocation) {\n        currentLocation = rollbackLocation;\n        // Notify subscribers\n        onUpdate();\n      }\n    }\n  });\n  win.addEventListener(pushStateEvent, onPushPop);\n  win.addEventListener(popStateEvent, onPushPop);\n  win.history.pushState = function () {\n    let res = originalPushState.apply(win.history, arguments);\n    if (tracking) history.notify();\n    return res;\n  };\n  win.history.replaceState = function () {\n    let res = originalReplaceState.apply(win.history, arguments);\n    if (tracking) history.notify();\n    return res;\n  };\n  return history;\n}\nfunction createHashHistory(opts) {\n  const win = opts?.window ?? (typeof document !== 'undefined' ? window : undefined);\n  return createBrowserHistory({\n    window: win,\n    parseLocation: () => {\n      const hashHref = win.location.hash.split('#').slice(1).join('#') ?? '/';\n      return parseHref(hashHref, win.history.state);\n    },\n    createHref: href => `${win.location.pathname}${win.location.search}#${href}`\n  });\n}\nfunction createMemoryHistory(opts = {\n  initialEntries: ['/']\n}) {\n  const entries = opts.initialEntries;\n  let index = opts.initialIndex ?? entries.length - 1;\n  let currentState = {\n    key: createRandomKey()\n  };\n  const getLocation = () => parseHref(entries[index], currentState);\n  return createHistory({\n    getLocation,\n    pushState: (path, state) => {\n      currentState = state;\n      entries.push(path);\n      index++;\n    },\n    replaceState: (path, state) => {\n      currentState = state;\n      entries[index] = path;\n    },\n    back: () => {\n      index--;\n    },\n    forward: () => {\n      index = Math.min(index + 1, entries.length - 1);\n    },\n    go: n => {\n      index = Math.min(Math.max(index + n, 0), entries.length - 1);\n    },\n    createHref: path => path\n  });\n}\nfunction parseHref(href, state) {\n  let hashIndex = href.indexOf('#');\n  let searchIndex = href.indexOf('?');\n  return {\n    href,\n    pathname: href.substring(0, hashIndex > 0 ? searchIndex > 0 ? Math.min(hashIndex, searchIndex) : hashIndex : searchIndex > 0 ? searchIndex : href.length),\n    hash: hashIndex > -1 ? href.substring(hashIndex) : '',\n    search: searchIndex > -1 ? href.slice(searchIndex, hashIndex === -1 ? undefined : hashIndex) : '',\n    state: state || {}\n  };\n}\n\n// Thanks co-pilot!\nfunction createRandomKey() {\n  return (Math.random() + 1).toString(36).substring(7);\n}\n\nexport { createBrowserHistory, createHashHistory, createHistory, createMemoryHistory };\n//# sourceMappingURL=index.js.map\n","var isProduction = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new Error(prefix);\n    }\n    var provided = typeof message === 'function' ? message() : message;\n    var value = provided ? \"\".concat(prefix, \": \").concat(provided) : prefix;\n    throw new Error(value);\n}\n\nexport { invariant as default };\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.production.min.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.development.js');\n}\n","/**\n * @license React\n * use-sync-external-store-shim/with-selector.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var h=require(\"react\"),n=require(\"use-sync-external-store/shim\");function p(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var q=\"function\"===typeof Object.is?Object.is:p,r=n.useSyncExternalStore,t=h.useRef,u=h.useEffect,v=h.useMemo,w=h.useDebugValue;\nexports.useSyncExternalStoreWithSelector=function(a,b,e,l,g){var c=t(null);if(null===c.current){var f={hasValue:!1,value:null};c.current=f}else f=c.current;c=v(function(){function a(a){if(!c){c=!0;d=a;a=l(a);if(void 0!==g&&f.hasValue){var b=f.value;if(g(b,a))return k=b}return k=a}b=k;if(q(d,a))return b;var e=l(a);if(void 0!==g&&g(b,e))return b;d=a;return k=e}var c=!1,d,k,m=void 0===e?null:e;return[function(){return a(b())},null===m?void 0:function(){return a(m())}]},[b,e,l,g]);var d=r(a,c[0],c[1]);\nu(function(){f.hasValue=!0;f.value=d},[d]);w(d);return d};\n","// src/index.ts\nvar Store = class {\n  constructor(initialState, options) {\n    this.listeners = /* @__PURE__ */ new Set();\n    this._batching = false;\n    this._flushing = 0;\n    this._nextPriority = null;\n    this.subscribe = (listener) => {\n      this.listeners.add(listener);\n      const unsub = this.options?.onSubscribe?.(listener, this);\n      return () => {\n        this.listeners.delete(listener);\n        unsub?.();\n      };\n    };\n    this.setState = (updater, opts) => {\n      const previous = this.state;\n      this.state = this.options?.updateFn ? this.options.updateFn(previous)(updater) : updater(previous);\n      const priority = opts?.priority ?? this.options?.defaultPriority ?? \"high\";\n      if (this._nextPriority === null) {\n        this._nextPriority = priority;\n      } else if (this._nextPriority === \"high\") {\n        this._nextPriority = priority;\n      } else {\n        this._nextPriority = this.options?.defaultPriority ?? \"high\";\n      }\n      this.options?.onUpdate?.({\n        priority: this._nextPriority\n      });\n      this._flush();\n    };\n    this._flush = () => {\n      if (this._batching)\n        return;\n      const flushId = ++this._flushing;\n      this.listeners.forEach((listener) => {\n        if (this._flushing !== flushId)\n          return;\n        listener({\n          priority: this._nextPriority ?? \"high\"\n        });\n      });\n    };\n    this.batch = (cb) => {\n      if (this._batching)\n        return cb();\n      this._batching = true;\n      cb();\n      this._batching = false;\n      this._flush();\n    };\n    this.state = initialState;\n    this.options = options;\n  }\n};\nexport {\n  Store\n};\n//# sourceMappingURL=index.js.map","// src/index.ts\nimport { useSyncExternalStoreWithSelector } from \"use-sync-external-store/shim/with-selector.js\";\nexport * from \"@tanstack/store\";\nfunction useStore(store, selector = (d) => d) {\n  const slice = useSyncExternalStoreWithSelector(\n    store.subscribe,\n    () => store.state,\n    () => store.state,\n    selector,\n    shallow\n  );\n  return slice;\n}\nfunction shallow(objA, objB) {\n  if (Object.is(objA, objB)) {\n    return true;\n  }\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n    return false;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  for (let i = 0; i < keysA.length; i++) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n  return true;\n}\nexport {\n  shallow,\n  useStore\n};\n//# sourceMappingURL=index.js.map","import * as React from 'react'\n\nexport function CatchBoundary(props: {\n  getResetKey: () => string\n  children: any\n  errorComponent?: any\n  onCatch: (error: any) => void\n}) {\n  const errorComponent = props.errorComponent ?? ErrorComponent\n\n  return (\n    <CatchBoundaryImpl\n      getResetKey={props.getResetKey}\n      onCatch={props.onCatch}\n      children={({ error }) => {\n        if (error) {\n          return React.createElement(errorComponent, {\n            error,\n          })\n        }\n\n        return props.children\n      }}\n    />\n  )\n}\n\nexport class CatchBoundaryImpl extends React.Component<{\n  getResetKey: () => string\n  children: (props: { error: any; reset: () => void }) => any\n  onCatch?: (error: any) => void\n}> {\n  state = { error: null } as any\n  static getDerivedStateFromProps(props: any) {\n    return { resetKey: props.getResetKey() }\n  }\n  static getDerivedStateFromError(error: any) {\n    return { error }\n  }\n  componentDidUpdate(\n    prevProps: Readonly<{\n      getResetKey: () => string\n      children: (props: { error: any; reset: () => void }) => any\n      onCatch?: ((error: any, info: any) => void) | undefined\n    }>,\n    prevState: any,\n  ): void {\n    if (prevState.error && prevState.resetKey !== this.state.resetKey) {\n      this.setState({ error: null })\n    }\n  }\n  componentDidCatch(error: any) {\n    console.error(error)\n    this.props.onCatch?.(error)\n  }\n  render() {\n    return this.props.children(this.state)\n  }\n}\n\nexport function ErrorComponent({ error }: { error: any }) {\n  const [show, setShow] = React.useState(process.env.NODE_ENV !== 'production')\n\n  return (\n    <div style={{ padding: '.5rem', maxWidth: '100%' }}>\n      <div style={{ display: 'flex', alignItems: 'center', gap: '.5rem' }}>\n        <strong style={{ fontSize: '1rem' }}>Something went wrong!</strong>\n        <button\n          style={{\n            appearance: 'none',\n            fontSize: '.6em',\n            border: '1px solid currentColor',\n            padding: '.1rem .2rem',\n            fontWeight: 'bold',\n            borderRadius: '.25rem',\n          }}\n          onClick={() => setShow((d) => !d)}\n        >\n          {show ? 'Hide Error' : 'Show Error'}\n        </button>\n      </div>\n      <div style={{ height: '.25rem' }} />\n      {show ? (\n        <div>\n          <pre\n            style={{\n              fontSize: '.7em',\n              border: '1px solid red',\n              borderRadius: '.25rem',\n              padding: '.3rem',\n              color: 'red',\n              overflow: 'auto',\n            }}\n          >\n            {error.message ? <code>{error.message}</code> : null}\n          </pre>\n        </div>\n      ) : null}\n    </div>\n  )\n}\n","import * as React from 'react'\nimport { useMatch } from './Matches'\nimport { RouteMatch } from './Matches'\nimport { AnyRoute } from './route'\nimport { ParseRoute, RouteIds, RoutesById, RouteById } from './routeInfo'\nimport { RegisteredRouter } from './router'\n\nexport type NoInfer<T> = [T][T extends any ? 0 : never]\nexport type IsAny<T, Y, N = T> = 1 extends 0 & T ? Y : N\nexport type IsAnyBoolean<T> = 1 extends 0 & T ? true : false\nexport type IsKnown<T, Y, N> = unknown extends T ? N : Y\nexport type PickAsRequired<T, K extends keyof T> = Omit<T, K> &\n  Required<Pick<T, K>>\nexport type PickAsPartial<T, K extends keyof T> = Omit<T, K> &\n  Partial<Pick<T, K>>\nexport type PickUnsafe<T, K> = K extends keyof T ? Pick<T, K> : never\nexport type PickExtra<T, K> = {\n  [TKey in keyof K as string extends TKey\n    ? never\n    : TKey extends keyof T\n    ? never\n    : TKey]: K[TKey]\n}\n\nexport type PickRequired<T> = {\n  [K in keyof T as undefined extends T[K] ? never : K]: T[K]\n}\n\n// export type Expand<T> = T\nexport type Expand<T> = T extends object\n  ? T extends infer O\n    ? { [K in keyof O]: O[K] }\n    : never\n  : T\n\nexport type UnionToIntersection<U> = (\n  U extends any ? (k: U) => void : never\n) extends (k: infer I) => any\n  ? I\n  : never\n\n// type Compute<T> = { [K in keyof T]: T[K] } | never\n\n// type AllKeys<T> = T extends any ? keyof T : never\n\n// export type MergeUnion<T, Keys extends keyof T = keyof T> = Compute<\n//   {\n//     [K in Keys]: T[Keys]\n//   } & {\n//     [K in AllKeys<T>]?: T extends any\n//       ? K extends keyof T\n//         ? T[K]\n//         : never\n//       : never\n//   }\n// >\n\nexport type Assign<Left, Right> = Omit<Left, keyof Right> & Right\n\nexport type AssignAll<T extends any[]> = T extends [infer Left, ...infer Right]\n  ? Right extends any[]\n    ? Assign<Left, AssignAll<Right>>\n    : Left\n  : {}\n\n// // Sample types to merge\n// type TypeA = {\n//   shared: string\n//   onlyInA: string\n//   nested: {\n//     shared: string\n//     aProp: string\n//   }\n//   array: string[]\n// }\n\n// type TypeB = {\n//   shared: number\n//   onlyInB: number\n//   nested: {\n//     shared: number\n//     bProp: number\n//   }\n//   array: number[]\n// }\n\n// type TypeC = {\n//   shared: boolean\n//   onlyInC: boolean\n//   nested: {\n//     shared: boolean\n//     cProp: boolean\n//   }\n//   array: boolean[]\n// }\n\n// type Test = Expand<Assign<TypeA, TypeB>>\n\n// // Using DeepMerge to merge TypeA and TypeB\n// type MergedType = Expand<AssignAll<[TypeA, TypeB, TypeC]>>\n\nexport type Values<O> = O[ValueKeys<O>]\nexport type ValueKeys<O> = Extract<keyof O, PropertyKey>\n\nexport type DeepAwaited<T> = T extends Promise<infer A>\n  ? DeepAwaited<A>\n  : T extends Record<infer A, Promise<infer B>>\n  ? { [K in A]: DeepAwaited<B> }\n  : T\n\nexport type PathParamMask<TRoutePath extends string> =\n  TRoutePath extends `${infer L}/$${infer C}/${infer R}`\n    ? PathParamMask<`${L}/${string}/${R}`>\n    : TRoutePath extends `${infer L}/$${infer C}`\n    ? PathParamMask<`${L}/${string}`>\n    : TRoutePath\n\nexport type Timeout = ReturnType<typeof setTimeout>\n\nexport type Updater<TPrevious, TResult = TPrevious> =\n  | TResult\n  | ((prev?: TPrevious) => TResult)\n\nexport type NonNullableUpdater<TPrevious, TResult = TPrevious> =\n  | TResult\n  | ((prev: TPrevious) => TResult)\n\nexport type PickExtract<T, U> = {\n  [K in keyof T as T[K] extends U ? K : never]: T[K]\n}\n\nexport type PickExclude<T, U> = {\n  [K in keyof T as T[K] extends U ? never : K]: T[K]\n}\n\n// from https://github.com/type-challenges/type-challenges/issues/737\ntype LastInUnion<U> = UnionToIntersection<\n  U extends unknown ? (x: U) => 0 : never\n> extends (x: infer L) => 0\n  ? L\n  : never\nexport type UnionToTuple<U, Last = LastInUnion<U>> = [U] extends [never]\n  ? []\n  : [...UnionToTuple<Exclude<U, Last>>, Last]\n\n//\n\nexport const isServer = typeof document === 'undefined'\n\nexport function last<T>(arr: T[]) {\n  return arr[arr.length - 1]\n}\n\nfunction isFunction(d: any): d is Function {\n  return typeof d === 'function'\n}\n\nexport function functionalUpdate<TResult>(\n  updater: Updater<TResult> | NonNullableUpdater<TResult>,\n  previous: TResult,\n): TResult {\n  if (isFunction(updater)) {\n    return updater(previous as TResult)\n  }\n\n  return updater\n}\n\nexport function pick<T, K extends keyof T>(parent: T, keys: K[]): Pick<T, K> {\n  return keys.reduce((obj: any, key: K) => {\n    obj[key] = parent[key]\n    return obj\n  }, {} as any)\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between immutable JSON values for example.\n * Do not use this with signals\n */\nexport function replaceEqualDeep<T>(prev: any, _next: T): T {\n  if (prev === _next) {\n    return prev\n  }\n\n  const next = _next as any\n\n  const array = Array.isArray(prev) && Array.isArray(next)\n\n  if (array || (isPlainObject(prev) && isPlainObject(next))) {\n    const prevSize = array ? prev.length : Object.keys(prev).length\n    const nextItems = array ? next : Object.keys(next)\n    const nextSize = nextItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < nextSize; i++) {\n      const key = array ? i : nextItems[i]\n      copy[key] = replaceEqualDeep(prev[key], next[key])\n      if (copy[key] === prev[key]) {\n        equalItems++\n      }\n    }\n\n    return prevSize === nextSize && equalItems === prevSize ? prev : copy\n  }\n\n  return next\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any) {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any) {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function deepEqual(a: any, b: any, partial: boolean = false): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (isPlainObject(a) && isPlainObject(b)) {\n    const aKeys = Object.keys(a)\n    const bKeys = Object.keys(b)\n\n    if (!partial && aKeys.length !== bKeys.length) {\n      return false\n    }\n\n    return !bKeys.some(\n      (key) => !(key in a) || !deepEqual(a[key], b[key], partial),\n    )\n  }\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return !a.some((item, index) => !deepEqual(item, b[index], partial))\n  }\n\n  return false\n}\n\nexport function useStableCallback<T extends (...args: any[]) => any>(fn: T): T {\n  const fnRef = React.useRef(fn)\n  fnRef.current = fn\n\n  const ref = React.useRef((...args: any[]) => fnRef.current(...args))\n  return ref.current as T\n}\n\nexport function shallow<T>(objA: T, objB: T) {\n  if (Object.is(objA, objB)) {\n    return true\n  }\n\n  if (\n    typeof objA !== 'object' ||\n    objA === null ||\n    typeof objB !== 'object' ||\n    objB === null\n  ) {\n    return false\n  }\n\n  const keysA = Object.keys(objA)\n  if (keysA.length !== Object.keys(objB).length) {\n    return false\n  }\n\n  for (let i = 0; i < keysA.length; i++) {\n    if (\n      !Object.prototype.hasOwnProperty.call(objB, keysA[i] as string) ||\n      !Object.is(objA[keysA[i] as keyof T], objB[keysA[i] as keyof T])\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\nexport type StrictOrFrom<TFrom> =\n  | {\n      from: TFrom\n      strict?: true\n    }\n  | {\n      from?: never\n      strict: false\n    }\n\nexport type RouteFromIdOrRoute<\n  T,\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n> = T extends ParseRoute<TRouteTree>\n  ? T\n  : T extends RouteIds<TRouteTree>\n  ? RoutesById<TRouteTree>[T]\n  : T extends string\n  ? RouteIds<TRouteTree>\n  : never\n\nexport function useRouteContext<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TStrict extends boolean = true,\n  TRouteContext = RouteById<TRouteTree, TFrom>['types']['allContext'],\n  TSelected = TRouteContext,\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (search: TRouteContext) => TSelected\n  },\n): TStrict extends true ? TSelected : TSelected | undefined {\n  return useMatch({\n    ...(opts as any),\n    select: (match: RouteMatch) =>\n      opts?.select\n        ? opts.select(match.context as TRouteContext)\n        : match.context,\n  })\n}\n\nexport const useLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\nexport function escapeJSON(jsonString: string) {\n  return jsonString\n    .replace(/\\\\/g, '\\\\\\\\') // Escape backslashes\n    .replace(/'/g, \"\\\\'\") // Escape single quotes\n    .replace(/\"/g, '\\\\\"') // Escape double quotes\n}\n","import * as React from 'react'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { CatchBoundary, ErrorComponent } from './CatchBoundary'\nimport { useRouter, useRouterState } from './RouterProvider'\nimport { ResolveRelativePath, ToOptions } from './link'\nimport { AnyRoute, ReactNode, rootRouteId } from './route'\nimport {\n  FullSearchSchema,\n  ParseRoute,\n  RouteById,\n  RouteByPath,\n  RouteIds,\n  RoutePaths,\n} from './routeInfo'\nimport { RegisteredRouter, RouterState } from './router'\nimport { NoInfer, StrictOrFrom, pick } from './utils'\n\nexport const matchContext = React.createContext<string | undefined>(undefined)\n\nexport interface RouteMatch<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id'],\n> {\n  id: string\n  routeId: TRouteId\n  pathname: string\n  params: RouteById<TRouteTree, TRouteId>['types']['allParams']\n  status: 'pending' | 'success' | 'error'\n  isFetching: boolean\n  showPending: boolean\n  error: unknown\n  paramsError: unknown\n  searchError: unknown\n  updatedAt: number\n  loadPromise?: Promise<void>\n  loaderData?: RouteById<TRouteTree, TRouteId>['types']['loaderData']\n  routeContext: RouteById<TRouteTree, TRouteId>['types']['routeContext']\n  context: RouteById<TRouteTree, TRouteId>['types']['allContext']\n  search: FullSearchSchema<TRouteTree> &\n    RouteById<TRouteTree, TRouteId>['types']['fullSearchSchema']\n  fetchCount: number\n  abortController: AbortController\n  cause: 'preload' | 'enter' | 'stay'\n  loaderDeps: RouteById<TRouteTree, TRouteId>['types']['loaderDeps']\n  preload: boolean\n  invalid: boolean\n}\n\nexport type AnyRouteMatch = RouteMatch<any, any>\n\nexport function Matches() {\n  const router = useRouter()\n  const matchId = useRouterState({\n    select: (s) => {\n      return getRenderedMatches(s)[0]?.id\n    },\n  })\n\n  return (\n    <matchContext.Provider value={matchId}>\n      <CatchBoundary\n        getResetKey={() => router.state.resolvedLocation.state?.key}\n        errorComponent={ErrorComponent}\n        onCatch={() => {\n          warning(\n            false,\n            `Error in router! Consider setting an 'errorComponent' in your RootRoute! ðŸ‘`,\n          )\n        }}\n      >\n        {matchId ? <Match matchId={matchId} /> : null}\n      </CatchBoundary>\n    </matchContext.Provider>\n  )\n}\n\nfunction SafeFragment(props: any) {\n  return <>{props.children}</>\n}\n\nexport function Match({ matchId }: { matchId: string }) {\n  const router = useRouter()\n  const routeId = useRouterState({\n    select: (s) =>\n      getRenderedMatches(s).find((d) => d.id === matchId)?.routeId as string,\n  })\n\n  invariant(\n    routeId,\n    `Could not find routeId for matchId \"${matchId}\". Please file an issue!`,\n  )\n\n  const route = router.routesById[routeId]!\n\n  const PendingComponent = (route.options.pendingComponent ??\n    router.options.defaultPendingComponent) as any\n\n  const pendingElement = PendingComponent ? <PendingComponent /> : null\n\n  const routeErrorComponent =\n    route.options.errorComponent ??\n    router.options.defaultErrorComponent ??\n    ErrorComponent\n\n  const ResolvedSuspenseBoundary =\n    route.options.wrapInSuspense ??\n    PendingComponent ??\n    route.options.component?.preload ??\n    route.options.pendingComponent?.preload ??\n    (route.options.errorComponent as any)?.preload\n      ? React.Suspense\n      : SafeFragment\n\n  const ResolvedCatchBoundary = routeErrorComponent\n    ? CatchBoundary\n    : SafeFragment\n\n  return (\n    <matchContext.Provider value={matchId}>\n      <ResolvedSuspenseBoundary fallback={pendingElement}>\n        <ResolvedCatchBoundary\n          getResetKey={() => router.state.resolvedLocation.state?.key}\n          errorComponent={routeErrorComponent}\n          onCatch={() => {\n            warning(false, `Error in route match: ${matchId}`)\n          }}\n        >\n          <MatchInner matchId={matchId!} pendingElement={pendingElement} />\n        </ResolvedCatchBoundary>\n      </ResolvedSuspenseBoundary>\n    </matchContext.Provider>\n  )\n}\n\nfunction MatchInner({\n  matchId,\n  pendingElement,\n}: {\n  matchId: string\n  pendingElement: any\n}): any {\n  const router = useRouter()\n  const routeId = useRouterState({\n    select: (s) =>\n      getRenderedMatches(s).find((d) => d.id === matchId)?.routeId as string,\n  })\n\n  const route = router.routesById[routeId]!\n\n  const match = useRouterState({\n    select: (s) =>\n      pick(getRenderedMatches(s).find((d) => d.id === matchId)!, [\n        'status',\n        'error',\n        'showPending',\n        'loadPromise',\n      ]),\n  })\n\n  if (match.status === 'error') {\n    throw match.error\n  }\n\n  if (match.status === 'pending') {\n    if (match.showPending) {\n      return pendingElement\n    }\n    throw match.loadPromise\n  }\n\n  if (match.status === 'success') {\n    let Comp = route.options.component ?? router.options.defaultComponent\n\n    if (Comp) {\n      return <Comp />\n    }\n\n    return <Outlet />\n  }\n\n  invariant(\n    false,\n    'Idle routeMatch status encountered during rendering! You should never see this. File an issue!',\n  )\n}\n\nexport const Outlet = React.memo(function Outlet() {\n  const matchId = React.useContext(matchContext)\n\n  const childMatchId = useRouterState({\n    select: (s) => {\n      const matches = getRenderedMatches(s)\n      const index = matches.findIndex((d) => d.id === matchId)\n      return matches[index + 1]?.id\n    },\n  })\n\n  if (!childMatchId) {\n    return null\n  }\n\n  return <Match matchId={childMatchId} />\n})\n\nexport interface MatchRouteOptions {\n  pending?: boolean\n  caseSensitive?: boolean\n  includeSearch?: boolean\n  fuzzy?: boolean\n}\n\nexport type UseMatchRouteOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ToOptions<AnyRoute, TFrom, TTo, TMaskFrom, TMaskTo> & MatchRouteOptions\n\nexport function useMatchRoute<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n>() {\n  useRouterState({ select: (s) => [s.location, s.resolvedLocation] })\n  const { matchRoute } = useRouter()\n\n  return React.useCallback(\n    <\n      TFrom extends RoutePaths<TRouteTree> = '/',\n      TTo extends string = '',\n      TMaskFrom extends RoutePaths<TRouteTree> = '/',\n      TMaskTo extends string = '',\n      TResolved extends string = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n    >(\n      opts: UseMatchRouteOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n    ): false | RouteById<TRouteTree, TResolved>['types']['allParams'] => {\n      const { pending, caseSensitive, ...rest } = opts\n\n      return matchRoute(rest as any, {\n        pending,\n        caseSensitive,\n      })\n    },\n    [],\n  )\n}\n\nexport type MakeMatchRouteOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ToOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> &\n  MatchRouteOptions & {\n    // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n    children?:\n      | ((\n          params?: RouteByPath<\n            TRouteTree,\n            ResolveRelativePath<TFrom, NoInfer<TTo>>\n          >['types']['allParams'],\n        ) => ReactNode)\n      | React.ReactNode\n  }\n\nexport function MatchRoute<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n>(\n  props: MakeMatchRouteOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n): any {\n  const matchRoute = useMatchRoute()\n  const params = matchRoute(props as any)\n\n  if (typeof props.children === 'function') {\n    return (props.children as any)(params)\n  }\n\n  return !!params ? props.children : null\n}\n\nfunction getRenderedMatches(state: RouterState) {\n  return state.pendingMatches?.some((d) => d.showPending)\n    ? state.pendingMatches\n    : state.matches\n}\n\nexport function useMatch<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TStrict extends boolean = true,\n  TRouteMatchState = RouteMatch<TRouteTree, TFrom>,\n  TSelected = TRouteMatchState,\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (match: TRouteMatchState) => TSelected\n  },\n): TStrict extends true ? TSelected : TSelected | undefined {\n  const router = useRouter()\n  const nearestMatchId = React.useContext(matchContext)\n\n  const nearestMatchRouteId = getRenderedMatches(router.state).find(\n    (d) => d.id === nearestMatchId,\n  )?.routeId\n\n  const matchRouteId = (() => {\n    const matches = getRenderedMatches(router.state)\n    const match = opts?.from\n      ? matches.find((d) => d.routeId === opts?.from)\n      : matches.find((d) => d.id === nearestMatchId)\n    return match!.routeId\n  })()\n\n  if (opts?.strict ?? true) {\n    invariant(\n      nearestMatchRouteId == matchRouteId,\n      `useMatch(\"${\n        matchRouteId as string\n      }\") is being called in a component that is meant to render the '${nearestMatchRouteId}' route. Did you mean to 'useMatch(\"${\n        matchRouteId as string\n      }\", { strict: false })' or 'useRoute(\"${\n        matchRouteId as string\n      }\")' instead?`,\n    )\n  }\n\n  const matchSelection = useRouterState({\n    select: (state) => {\n      const match = getRenderedMatches(state).find(\n        (d) => d.id === nearestMatchId,\n      )\n\n      invariant(\n        match,\n        `Could not find ${\n          opts?.from\n            ? `an active match from \"${opts.from}\"`\n            : 'a nearest match!'\n        }`,\n      )\n\n      return opts?.select ? opts.select(match as any) : match\n    },\n  })\n\n  return matchSelection as any\n}\n\nexport function useMatches<T = RouteMatch[]>(opts?: {\n  select?: (matches: RouteMatch[]) => T\n}): T {\n  return useRouterState({\n    select: (state) => {\n      let matches = getRenderedMatches(state)\n      return opts?.select ? opts.select(matches) : (matches as T)\n    },\n  })\n}\n\nexport function useParentMatches<T = RouteMatch[]>(opts?: {\n  select?: (matches: RouteMatch[]) => T\n}): T {\n  const contextMatchId = React.useContext(matchContext)\n\n  return useMatches({\n    select: (matches) => {\n      matches = matches.slice(matches.findIndex((d) => d.id === contextMatchId))\n      return opts?.select ? opts.select(matches) : (matches as T)\n    },\n  })\n}\n\nexport function useLoaderDeps<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TStrict extends boolean = true,\n  TRouteMatch extends RouteMatch<TRouteTree, TFrom> = RouteMatch<\n    TRouteTree,\n    TFrom\n  >,\n  TSelected = Required<TRouteMatch>['loaderDeps'],\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (match: TRouteMatch) => TSelected\n  },\n): TStrict extends true ? TSelected : TSelected | undefined {\n  return useMatch({\n    ...opts,\n    select: (s) => {\n      return typeof opts.select === 'function'\n        ? opts.select(s?.loaderDeps)\n        : s?.loaderDeps\n    },\n  })!\n}\n\nexport function useLoaderData<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TStrict extends boolean = true,\n  TRouteMatch extends RouteMatch<TRouteTree, TFrom> = RouteMatch<\n    TRouteTree,\n    TFrom\n  >,\n  TSelected = Required<TRouteMatch>['loaderData'],\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (match: TRouteMatch) => TSelected\n  },\n): TStrict extends true ? TSelected : TSelected | undefined {\n  return useMatch({\n    ...opts,\n    select: (s) => {\n      return typeof opts.select === 'function'\n        ? opts.select(s?.loaderData)\n        : s?.loaderData\n    },\n  })!\n}\n","import * as React from 'react'\nimport warning from 'tiny-warning'\nimport { useStore } from '@tanstack/react-store'\nimport { Matches } from './Matches'\nimport { NavigateOptions, ResolveRelativePath, ToOptions } from './link'\nimport { ParsedLocation } from './location'\nimport { AnyRoute } from './route'\nimport { RouteById, RoutePaths } from './routeInfo'\nimport {\n  BuildNextOptions,\n  RegisteredRouter,\n  Router,\n  RouterOptions,\n  RouterState,\n} from './router'\nimport { NoInfer, pick, useLayoutEffect } from './utils'\nimport { MatchRouteOptions } from './Matches'\nimport { RouteMatch } from './Matches'\n\nexport interface CommitLocationOptions {\n  replace?: boolean\n  resetScroll?: boolean\n  startTransition?: boolean\n}\n\nexport interface MatchLocation {\n  to?: string | number | null\n  fuzzy?: boolean\n  caseSensitive?: boolean\n  from?: string\n}\n\nexport type NavigateFn<TRouteTree extends AnyRoute> = <\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n>(\n  opts: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n) => Promise<void>\n\nexport type MatchRouteFn<TRouteTree extends AnyRoute> = <\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n>(\n  location: ToOptions<TRouteTree, TFrom, TTo>,\n  opts?: MatchRouteOptions,\n) => false | RouteById<TRouteTree, TResolved>['types']['allParams']\n\nexport type BuildLocationFn<TRouteTree extends AnyRoute> = (\n  opts: ToOptions<TRouteTree>,\n) => ParsedLocation\n\nexport type InjectedHtmlEntry = string | (() => Promise<string> | string)\n\nexport let routerContext = React.createContext<Router<any>>(null!)\n\nif (typeof document !== 'undefined') {\n  if (window.__TSR_ROUTER_CONTEXT__) {\n    routerContext = window.__TSR_ROUTER_CONTEXT__\n  } else {\n    window.__TSR_ROUTER_CONTEXT__ = routerContext as any\n  }\n}\n\nexport function RouterProvider<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TDehydrated extends Record<string, any> = Record<string, any>,\n>({ router, ...rest }: RouterProps<TRouteTree, TDehydrated>) {\n  // Allow the router to update options on the router instance\n  router.update({\n    ...router.options,\n    ...rest,\n    context: {\n      ...router.options.context,\n      ...rest?.context,\n    },\n  } as any)\n\n  const matches = router.options.InnerWrap ? (\n    <router.options.InnerWrap>\n      <Matches />\n    </router.options.InnerWrap>\n  ) : (\n    <Matches />\n  )\n\n  const provider = (\n    <routerContext.Provider value={router}>\n      {matches}\n      <Transitioner />\n    </routerContext.Provider>\n  )\n\n  if (router.options.Wrap) {\n    return <router.options.Wrap>{provider}</router.options.Wrap>\n  }\n\n  return provider\n}\n\nfunction Transitioner() {\n  const router = useRouter()\n  const routerState = useRouterState({\n    select: (s) =>\n      pick(s, ['isLoading', 'location', 'resolvedLocation', 'isTransitioning']),\n  })\n\n  const [isTransitioning, startReactTransition] = React.useTransition()\n\n  router.startReactTransition = startReactTransition\n\n  React.useEffect(() => {\n    if (isTransitioning) {\n      router.__store.setState((s) => ({\n        ...s,\n        isTransitioning,\n      }))\n    }\n  }, [isTransitioning])\n\n  const tryLoad = () => {\n    const apply = (cb: () => void) => {\n      if (!routerState.isTransitioning) {\n        startReactTransition(() => cb())\n      } else {\n        cb()\n      }\n    }\n\n    apply(() => {\n      try {\n        router.load()\n      } catch (err) {\n        console.error(err)\n      }\n    })\n  }\n\n  useLayoutEffect(() => {\n    const unsub = router.history.subscribe(() => {\n      router.latestLocation = router.parseLocation(router.latestLocation)\n      if (routerState.location !== router.latestLocation) {\n        tryLoad()\n      }\n    })\n\n    const nextLocation = router.buildLocation({\n      search: true,\n      params: true,\n      hash: true,\n      state: true,\n    })\n\n    if (routerState.location.href !== nextLocation.href) {\n      router.commitLocation({ ...nextLocation, replace: true })\n    }\n\n    return () => {\n      unsub()\n    }\n  }, [router.history])\n\n  useLayoutEffect(() => {\n    if (\n      routerState.isTransitioning &&\n      !isTransitioning &&\n      !routerState.isLoading &&\n      routerState.resolvedLocation !== routerState.location\n    ) {\n      router.emit({\n        type: 'onResolved',\n        fromLocation: routerState.resolvedLocation,\n        toLocation: routerState.location,\n        pathChanged:\n          routerState.location!.href !== routerState.resolvedLocation?.href,\n      })\n\n      if ((document as any).querySelector) {\n        if (routerState.location.hash !== '') {\n          const el = document.getElementById(\n            routerState.location.hash,\n          ) as HTMLElement | null\n          if (el) {\n            el.scrollIntoView()\n          }\n        }\n      }\n\n      router.__store.setState((s) => ({\n        ...s,\n        isTransitioning: false,\n        resolvedLocation: s.location,\n      }))\n    }\n  }, [\n    routerState.isTransitioning,\n    isTransitioning,\n    routerState.isLoading,\n    routerState.resolvedLocation,\n    routerState.location,\n  ])\n\n  useLayoutEffect(() => {\n    if (!window.__TSR_DEHYDRATED__) {\n      tryLoad()\n    }\n  }, [])\n\n  return null\n}\n\nexport function getRouteMatch<TRouteTree extends AnyRoute>(\n  state: RouterState<TRouteTree>,\n  id: string,\n): undefined | RouteMatch<TRouteTree> {\n  return [\n    ...state.cachedMatches,\n    ...(state.pendingMatches ?? []),\n    ...state.matches,\n  ].find((d) => d.id === id)\n}\n\nexport function useRouterState<\n  TSelected = RouterState<RegisteredRouter['routeTree']>,\n>(opts?: {\n  select: (state: RouterState<RegisteredRouter['routeTree']>) => TSelected\n}): TSelected {\n  const router = useRouter()\n  return useStore(router.__store, opts?.select as any)\n}\n\nexport type RouterProps<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> = Omit<RouterOptions<TRouteTree, TDehydrated>, 'context'> & {\n  router: Router<TRouteTree>\n  context?: Partial<RouterOptions<TRouteTree, TDehydrated>['context']>\n}\n\nexport function useRouter<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n>(): Router<TRouteTree> {\n  const resolvedContext =\n    typeof document !== 'undefined'\n      ? window.__TSR_ROUTER_CONTEXT__ || routerContext\n      : routerContext\n  const value = React.useContext(resolvedContext)\n  warning(value, 'useRouter must be used inside a <RouterProvider> component!')\n  return value as any\n}\n","export type DeferredPromiseState<T> = { uid: string } & (\n  | {\n      status: 'pending'\n      data?: T\n      error?: unknown\n    }\n  | {\n      status: 'success'\n      data: T\n    }\n  | {\n      status: 'error'\n      data?: T\n      error: unknown\n    }\n)\n\nexport type DeferredPromise<T> = Promise<T> & {\n  __deferredState: DeferredPromiseState<T>\n}\n\nexport function defer<T>(_promise: Promise<T>) {\n  const promise = _promise as DeferredPromise<T>\n\n  if (!promise.__deferredState) {\n    promise.__deferredState = {\n      uid: Math.random().toString(36).slice(2),\n      status: 'pending',\n    }\n\n    const state = promise.__deferredState\n\n    promise\n      .then((data) => {\n        state.status = 'success' as any\n        state.data = data\n      })\n      .catch((error) => {\n        state.status = 'error' as any\n        state.error = error\n      })\n  }\n\n  return promise\n}\n\nexport function isDehydratedDeferred(obj: any): boolean {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    !(obj instanceof Promise) &&\n    !obj.then &&\n    '__deferredState' in obj\n  )\n}\n","import { useRouter } from './RouterProvider'\nimport { DeferredPromise, isDehydratedDeferred } from './defer'\n\nexport type AwaitOptions<T> = {\n  promise: DeferredPromise<T>\n}\n\nexport function useAwaited<T>({ promise }: AwaitOptions<T>): [T] {\n  const router = useRouter()\n\n  let state = promise.__deferredState\n  const key = `__TSR__DEFERRED__${state.uid}`\n\n  if (isDehydratedDeferred(promise)) {\n    state = router.hydrateData(key)!\n    promise = Promise.resolve(state.data) as DeferredPromise<any>\n    promise.__deferredState = state\n  }\n\n  if (state.status === 'pending') {\n    throw new Promise((r) => setTimeout(r, 1)).then(() => promise)\n  }\n\n  if (state.status === 'error') {\n    throw state.error\n  }\n\n  router.dehydrateData(key, state)\n\n  return [state.data]\n}\n\nexport function Await<T>(\n  props: AwaitOptions<T> & {\n    children: (result: T) => JSX.Element\n  },\n) {\n  const awaited = useAwaited(props)\n  return props.children(...awaited)\n}\n","import { MatchLocation } from './RouterProvider'\nimport { AnyPathParams } from './route'\nimport { last } from './utils'\n\nexport interface Segment {\n  type: 'pathname' | 'param' | 'wildcard'\n  value: string\n}\n\nexport function joinPaths(paths: (string | undefined)[]) {\n  return cleanPath(paths.filter(Boolean).join('/'))\n}\n\nexport function cleanPath(path: string) {\n  // remove double slashes\n  return path.replace(/\\/{2,}/g, '/')\n}\n\nexport function trimPathLeft(path: string) {\n  return path === '/' ? path : path.replace(/^\\/{1,}/, '')\n}\n\nexport function trimPathRight(path: string) {\n  return path === '/' ? path : path.replace(/\\/{1,}$/, '')\n}\n\nexport function trimPath(path: string) {\n  return trimPathRight(trimPathLeft(path))\n}\n\nexport function resolvePath(basepath: string, base: string, to: string) {\n  base = base.replace(new RegExp(`^${basepath}`), '/')\n  to = to.replace(new RegExp(`^${basepath}`), '/')\n\n  let baseSegments = parsePathname(base)\n  const toSegments = parsePathname(to)\n\n  toSegments.forEach((toSegment, index) => {\n    if (toSegment.value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment]\n      } else if (index === toSegments.length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment)\n      } else {\n        // ignore inter-slashes\n      }\n    } else if (toSegment.value === '..') {\n      // Extra trailing slash? pop it off\n      if (baseSegments.length > 1 && last(baseSegments)?.value === '/') {\n        baseSegments.pop()\n      }\n      baseSegments.pop()\n    } else if (toSegment.value === '.') {\n      return\n    } else {\n      baseSegments.push(toSegment)\n    }\n  })\n\n  const joined = joinPaths([basepath, ...baseSegments.map((d) => d.value)])\n\n  return cleanPath(joined)\n}\n\nexport function parsePathname(pathname?: string): Segment[] {\n  if (!pathname) {\n    return []\n  }\n\n  pathname = cleanPath(pathname)\n\n  const segments: Segment[] = []\n\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!pathname) {\n    return segments\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean)\n\n  segments.push(\n    ...split.map((part): Segment => {\n      if (part === '$' || part === '*') {\n        return {\n          type: 'wildcard',\n          value: part,\n        }\n      }\n\n      if (part.charAt(0) === '$') {\n        return {\n          type: 'param',\n          value: part,\n        }\n      }\n\n      return {\n        type: 'pathname',\n        value: part,\n      }\n    }),\n  )\n\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  return segments\n}\n\nexport function interpolatePath(\n  path: string | undefined,\n  params: any,\n  leaveWildcards: boolean = false,\n) {\n  const interpolatedPathSegments = parsePathname(path)\n\n  return joinPaths(\n    interpolatedPathSegments.map((segment) => {\n      if (segment.type === 'wildcard') {\n        const value = params[segment.value]\n        if (leaveWildcards) return `${segment.value}${value ?? ''}`\n        return value\n      }\n\n      if (segment.type === 'param') {\n        return params![segment.value.substring(1)] ?? 'undefined'\n      }\n\n      return segment.value\n    }),\n  )\n}\n\nexport function matchPathname(\n  basepath: string,\n  currentPathname: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'fuzzy' | 'caseSensitive'>,\n): AnyPathParams | undefined {\n  const pathParams = matchByPath(basepath, currentPathname, matchLocation)\n  // const searchMatched = matchBySearch(location.search, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return\n  }\n\n  return pathParams ?? {}\n}\n\nexport function removeBasepath(basepath: string, pathname: string) {\n  return basepath != '/' ? pathname.substring(basepath.length) : pathname\n}\n\nexport function matchByPath(\n  basepath: string,\n  from: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'caseSensitive' | 'fuzzy'>,\n): Record<string, string> | undefined {\n  // Remove the base path from the pathname\n  from = removeBasepath(basepath, from)\n  // Default to to $ (wildcard)\n  const to = `${matchLocation.to ?? '$'}`\n  // Parse the from and to\n  const baseSegments = parsePathname(from)\n  const routeSegments = parsePathname(to)\n\n  if (!from.startsWith('/')) {\n    baseSegments.unshift({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!to.startsWith('/')) {\n    routeSegments.unshift({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  const params: Record<string, string> = {}\n\n  let isMatch = (() => {\n    for (\n      let i = 0;\n      i < Math.max(baseSegments.length, routeSegments.length);\n      i++\n    ) {\n      const baseSegment = baseSegments[i]\n      const routeSegment = routeSegments[i]\n\n      const isLastBaseSegment = i >= baseSegments.length - 1\n      const isLastRouteSegment = i >= routeSegments.length - 1\n\n      if (routeSegment) {\n        if (routeSegment.type === 'wildcard') {\n          if (baseSegment?.value) {\n            params['*'] = joinPaths(baseSegments.slice(i).map((d) => d.value))\n            return true\n          }\n          return false\n        }\n\n        if (routeSegment.type === 'pathname') {\n          if (routeSegment.value === '/' && !baseSegment?.value) {\n            return true\n          }\n\n          if (baseSegment) {\n            if (matchLocation.caseSensitive) {\n              if (routeSegment.value !== baseSegment.value) {\n                return false\n              }\n            } else if (\n              routeSegment.value.toLowerCase() !==\n              baseSegment.value.toLowerCase()\n            ) {\n              return false\n            }\n          }\n        }\n\n        if (!baseSegment) {\n          return false\n        }\n\n        if (routeSegment.type === 'param') {\n          if (baseSegment?.value === '/') {\n            return false\n          }\n          if (baseSegment.value.charAt(0) !== '$') {\n            params[routeSegment.value.substring(1)] = baseSegment.value\n          }\n        }\n      }\n\n      if (!isLastBaseSegment && isLastRouteSegment) {\n        params['**'] = joinPaths(baseSegments.slice(i + 1).map((d) => d.value))\n        return !!matchLocation.fuzzy && routeSegment?.value !== '/'\n      }\n    }\n\n    return true\n  })()\n\n  return isMatch ? (params as Record<string, string>) : undefined\n}\n","import { AnyRoute } from './route'\nimport { RouteIds, RouteById, AllParams } from './routeInfo'\nimport { RegisteredRouter } from './router'\nimport { last } from './utils'\nimport { useRouterState } from './RouterProvider'\nimport { StrictOrFrom } from './utils'\n\nexport function useParams<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TDefaultSelected = AllParams<TRouteTree> &\n    RouteById<TRouteTree, TFrom>['types']['allParams'],\n  TSelected = TDefaultSelected,\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (search: TDefaultSelected) => TSelected\n  },\n): TSelected {\n  return useRouterState({\n    select: (state: any) => {\n      const params = (last(state.matches) as any)?.params\n      return opts?.select ? opts.select(params) : params\n    },\n  })\n}\n","import { AnyRoute } from './route'\nimport { RouteIds, RouteById } from './routeInfo'\nimport { RegisteredRouter } from './router'\nimport { RouteMatch } from './Matches'\nimport { useMatch } from './Matches'\nimport { StrictOrFrom } from './utils'\n\nexport function useSearch<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TStrict extends boolean = true,\n  TSearch = RouteById<TRouteTree, TFrom>['types']['fullSearchSchema'],\n  TSelected = TSearch,\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (search: TSearch) => TSelected\n  },\n): TStrict extends true ? TSelected : TSelected | undefined {\n  return useMatch({\n    ...(opts as any),\n    select: (match: RouteMatch) => {\n      return opts?.select ? opts.select(match.search as TSearch) : match.search\n    },\n  })\n}\n","import * as React from 'react'\nimport invariant from 'tiny-invariant'\nimport { useLoaderData, useLoaderDeps, useMatch } from './Matches'\nimport { AnyRouteMatch } from './Matches'\nimport { NavigateOptions, ParsePathParams, ToSubOptions } from './link'\nimport { ParsedLocation } from './location'\nimport { joinPaths, trimPath } from './path'\nimport { RouteById, RouteIds, RoutePaths } from './routeInfo'\nimport { AnyRouter, RegisteredRouter } from './router'\nimport { useParams } from './useParams'\nimport { useSearch } from './useSearch'\nimport {\n  Assign,\n  Expand,\n  IsAny,\n  NoInfer,\n  PickRequired,\n  UnionToIntersection,\n} from './utils'\nimport { BuildLocationFn, NavigateFn } from './RouterProvider'\n\nexport const rootRouteId = '__root__' as const\nexport type RootRouteId = typeof rootRouteId\nexport type AnyPathParams = {}\n\nexport type AnySearchSchema = {}\n\nexport type AnyContext = {}\n\nexport interface RouteContext {}\n\nexport interface RouteMeta {}\n\nexport type PreloadableObj = { preload?: () => Promise<void> }\n\nexport type RoutePathOptions<TCustomId, TPath> =\n  | {\n      path: TPath\n    }\n  | {\n      id: TCustomId\n    }\n\nexport type RoutePathOptionsIntersection<TCustomId, TPath> =\n  UnionToIntersection<RoutePathOptions<TCustomId, TPath>>\n\nexport type MetaOptions = keyof PickRequired<RouteMeta> extends never\n  ? {\n      meta?: RouteMeta\n    }\n  : {\n      meta: RouteMeta\n    }\n\nexport type RouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TCustomId extends string = string,\n  TPath extends string = string,\n  TSearchSchema extends Record<string, any> = {},\n  TFullSearchSchema extends Record<string, any> = TSearchSchema,\n  TParams extends AnyPathParams = AnyPathParams,\n  TAllParams extends AnyPathParams = TParams,\n  TRouteContext extends RouteContext = RouteContext,\n  TAllContext extends Record<string, any> = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderData extends any = unknown,\n> = BaseRouteOptions<\n  TParentRoute,\n  TCustomId,\n  TPath,\n  TSearchSchema,\n  TFullSearchSchema,\n  TParams,\n  TAllParams,\n  TRouteContext,\n  TAllContext,\n  TLoaderDeps,\n  TLoaderData\n> &\n  UpdatableRouteOptions<NoInfer<TFullSearchSchema>>\n\nexport type ParamsFallback<\n  TPath extends string,\n  TParams,\n> = unknown extends TParams ? Record<ParsePathParams<TPath>, string> : TParams\n\nexport type BaseRouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TCustomId extends string = string,\n  TPath extends string = string,\n  TSearchSchema extends Record<string, any> = {},\n  TFullSearchSchema extends Record<string, any> = TSearchSchema,\n  TParams extends AnyPathParams = {},\n  TAllParams = ParamsFallback<TPath, TParams>,\n  TRouteContext extends RouteContext = RouteContext,\n  TAllContext extends Record<string, any> = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderData extends any = unknown,\n> = RoutePathOptions<TCustomId, TPath> & {\n  getParentRoute: () => TParentRoute\n  validateSearch?: SearchSchemaValidator<TSearchSchema>\n  shouldReload?:\n    | boolean\n    | ((\n        match: LoaderFnContext<\n          TAllParams,\n          TFullSearchSchema,\n          TAllContext,\n          TRouteContext\n        >,\n      ) => any)\n} & (keyof PickRequired<RouteContext> extends never\n    ? // This async function is called before a route is loaded.\n      // If an error is thrown here, the route's loader will not be called.\n      // If thrown during a navigation, the navigation will be cancelled and the error will be passed to the `onError` function.\n      // If thrown during a preload event, the error will be logged to the console.\n      {\n        beforeLoad?: BeforeLoadFn<\n          TFullSearchSchema,\n          TParentRoute,\n          TAllParams,\n          TRouteContext\n        >\n      }\n    : {\n        beforeLoad: BeforeLoadFn<\n          TFullSearchSchema,\n          TParentRoute,\n          TAllParams,\n          TRouteContext\n        >\n      }) & {\n    loaderDeps?: (opts: { search: TFullSearchSchema }) => TLoaderDeps\n    loader?: RouteLoaderFn<\n      TAllParams,\n      NoInfer<TLoaderDeps>,\n      NoInfer<TAllContext>,\n      NoInfer<TRouteContext>,\n      TLoaderData\n    >\n  } & (\n    | {\n        // Both or none\n        parseParams?: (\n          rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>,\n        ) => TParams extends Record<ParsePathParams<TPath>, any>\n          ? TParams\n          : 'parseParams must return an object'\n        stringifyParams?: (\n          params: NoInfer<ParamsFallback<TPath, TParams>>,\n        ) => Record<ParsePathParams<TPath>, string>\n      }\n    | {\n        stringifyParams?: never\n        parseParams?: never\n      }\n  )\n\ntype BeforeLoadFn<\n  TFullSearchSchema extends Record<string, any>,\n  TParentRoute extends AnyRoute,\n  TAllParams,\n  TRouteContext,\n> = (opts: {\n  search: TFullSearchSchema\n  abortController: AbortController\n  preload: boolean\n  params: TAllParams\n  context: TParentRoute['types']['allContext']\n  location: ParsedLocation\n  navigate: NavigateFn<AnyRoute>\n  buildLocation: BuildLocationFn<TParentRoute>\n  cause: 'preload' | 'enter' | 'stay'\n}) => Promise<TRouteContext> | TRouteContext | void\n\nexport type UpdatableRouteOptions<\n  TFullSearchSchema extends Record<string, any>,\n> = MetaOptions & {\n  // test?: (args: TAllContext) => void\n  // If true, this route will be matched as case-sensitive\n  caseSensitive?: boolean\n  // If true, this route will be forcefully wrapped in a suspense boundary\n  wrapInSuspense?: boolean\n  // The content to be rendered when the route is matched. If no component is provided, defaults to `<Outlet />`\n  component?: RouteComponent\n  errorComponent?: false | null | ErrorRouteComponent\n  pendingComponent?: RouteComponent\n  pendingMs?: number\n  pendingMinMs?: number\n  staleTime?: number\n  gcTime?: number\n  preloadStaleTime?: number\n  preloadGcTime?: number\n  // Filter functions that can manipulate search params *before* they are passed to links and navigate\n  // calls that match this route.\n  preSearchFilters?: SearchFilter<TFullSearchSchema>[]\n  // Filter functions that can manipulate search params *after* they are passed to links and navigate\n  // calls that match this route.\n  postSearchFilters?: SearchFilter<TFullSearchSchema>[]\n  onError?: (err: any) => void\n  // These functions are called as route matches are loaded, stick around and leave the active\n  // matches\n  onEnter?: (match: AnyRouteMatch) => void\n  onStay?: (match: AnyRouteMatch) => void\n  onLeave?: (match: AnyRouteMatch) => void\n}\n\nexport type ParseParamsOption<TPath extends string, TParams> = ParseParamsFn<\n  TPath,\n  TParams\n>\n\nexport type ParseParamsFn<TPath extends string, TParams> = (\n  rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>,\n) => TParams extends Record<ParsePathParams<TPath>, any>\n  ? TParams\n  : 'parseParams must return an object'\n\nexport type ParseParamsObj<TPath extends string, TParams> = {\n  parse?: ParseParamsFn<TPath, TParams>\n}\n\n// The parse type here allows a zod schema to be passed directly to the validator\nexport type SearchSchemaValidator<TReturn> =\n  | SearchSchemaValidatorObj<TReturn>\n  | SearchSchemaValidatorFn<TReturn>\n\nexport type SearchSchemaValidatorObj<TReturn> = {\n  parse?: SearchSchemaValidatorFn<TReturn>\n}\n\nexport type SearchSchemaValidatorFn<TReturn> = (\n  searchObj: Record<string, unknown>,\n) => TReturn\n\nexport type DefinedPathParamWarning =\n  'Path params cannot be redefined by child routes!'\n\nexport type ParentParams<TParentParams> = AnyPathParams extends TParentParams\n  ? {}\n  : {\n      [Key in keyof TParentParams]?: DefinedPathParamWarning\n    }\n\nexport type RouteLoaderFn<\n  TAllParams = {},\n  TLoaderDeps extends Record<string, any> = {},\n  TAllContext extends Record<string, any> = AnyContext,\n  TRouteContext extends Record<string, any> = AnyContext,\n  TLoaderData extends any = unknown,\n> = (\n  match: LoaderFnContext<TAllParams, TLoaderDeps, TAllContext, TRouteContext>,\n) => Promise<TLoaderData> | TLoaderData\n\nexport interface LoaderFnContext<\n  TAllParams = {},\n  TLoaderDeps extends Record<string, any> = {},\n  TAllContext extends Record<string, any> = AnyContext,\n  TRouteContext extends Record<string, any> = AnyContext,\n> {\n  abortController: AbortController\n  preload: boolean\n  params: TAllParams\n  deps: TLoaderDeps\n  context: Expand<Assign<TAllContext, TRouteContext>>\n  location: ParsedLocation // Do not supply search schema here so as to demotivate people from trying to shortcut loaderDeps\n  navigate: (opts: NavigateOptions<AnyRoute>) => Promise<void>\n  parentMatchPromise?: Promise<void>\n  cause: 'preload' | 'enter' | 'stay'\n}\n\nexport type SearchFilter<T, U = T> = (prev: T) => U\n\nexport type ResolveId<\n  TParentRoute,\n  TCustomId extends string,\n  TPath extends string,\n> = TParentRoute extends { id: infer TParentId extends string }\n  ? RoutePrefix<TParentId, string extends TCustomId ? TPath : TCustomId>\n  : RootRouteId\n\nexport type InferFullSearchSchema<TRoute> = TRoute extends {\n  types: {\n    fullSearchSchema: infer TFullSearchSchema\n  }\n}\n  ? TFullSearchSchema\n  : {}\n\nexport type ResolveFullSearchSchema<TParentRoute, TSearchSchema> = Expand<\n  Assign<InferFullSearchSchema<TParentRoute>, TSearchSchema>\n>\n\nexport interface AnyRoute\n  extends Route<\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  > {}\n\nexport type MergeFromFromParent<T, U> = IsAny<T, U, T & U>\n\nexport type ResolveAllParams<\n  TParentRoute extends AnyRoute,\n  TParams extends AnyPathParams,\n> = Record<never, string> extends TParentRoute['types']['allParams']\n  ? TParams\n  : Expand<\n      UnionToIntersection<TParentRoute['types']['allParams'] & TParams> & {}\n    >\n\nexport type RouteConstraints = {\n  TParentRoute: AnyRoute\n  TPath: string\n  TFullPath: string\n  TCustomId: string\n  TId: string\n  TSearchSchema: AnySearchSchema\n  TFullSearchSchema: AnySearchSchema\n  TParams: Record<string, any>\n  TAllParams: Record<string, any>\n  TParentContext: AnyContext\n  TRouteContext: RouteContext\n  TAllContext: AnyContext\n  TRouterContext: AnyContext\n  TChildren: unknown\n  TRouteTree: AnyRoute\n}\n\nexport class RouteApi<\n  TId extends RouteIds<RegisteredRouter['routeTree']>,\n  TRoute extends AnyRoute = RouteById<RegisteredRouter['routeTree'], TId>,\n  TFullSearchSchema extends Record<\n    string,\n    any\n  > = TRoute['types']['fullSearchSchema'],\n  TAllParams extends AnyPathParams = TRoute['types']['allParams'],\n  TAllContext extends Record<string, any> = TRoute['types']['allContext'],\n  TLoaderDeps extends Record<string, any> = TRoute['types']['loaderDeps'],\n  TLoaderData extends any = TRoute['types']['loaderData'],\n> {\n  id: TId\n\n  constructor({ id }: { id: TId }) {\n    this.id = id as any\n  }\n\n  useMatch = <TSelected = TAllContext>(opts?: {\n    select?: (s: TAllContext) => TSelected\n  }): TSelected => {\n    return useMatch({ ...opts, from: this.id }) as any\n  }\n\n  useRouteContext = <TSelected = TAllContext>(opts?: {\n    select?: (s: TAllContext) => TSelected\n  }): TSelected => {\n    return useMatch({\n      ...opts,\n      from: this.id,\n      select: (d: any) => (opts?.select ? opts.select(d.context) : d.context),\n    } as any)\n  }\n\n  useSearch = <TSelected = TFullSearchSchema>(opts?: {\n    select?: (s: TFullSearchSchema) => TSelected\n  }): TSelected => {\n    return useSearch({ ...opts, from: this.id } as any)\n  }\n\n  useParams = <TSelected = TAllParams>(opts?: {\n    select?: (s: TAllParams) => TSelected\n  }): TSelected => {\n    return useParams({ ...opts, from: this.id } as any)\n  }\n\n  useLoaderDeps = <TSelected = TLoaderDeps>(opts?: {\n    select?: (s: TLoaderDeps) => TSelected\n  }): TSelected => {\n    return useLoaderDeps({ ...opts, from: this.id } as any) as any\n  }\n\n  useLoaderData = <TSelected = TLoaderData>(opts?: {\n    select?: (s: TLoaderData) => TSelected\n  }): TSelected => {\n    return useLoaderData({ ...opts, from: this.id } as any) as any\n  }\n}\n\nexport class Route<\n  TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute,\n  TPath extends RouteConstraints['TPath'] = '/',\n  TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\n    TParentRoute,\n    TPath\n  >,\n  TCustomId extends RouteConstraints['TCustomId'] = string,\n  TId extends RouteConstraints['TId'] = ResolveId<\n    TParentRoute,\n    TCustomId,\n    TPath\n  >,\n  TSearchSchema extends RouteConstraints['TSearchSchema'] = {},\n  TFullSearchSchema extends\n    RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchema<\n    TParentRoute,\n    TSearchSchema\n  >,\n  TParams extends RouteConstraints['TParams'] = Expand<\n    Record<ParsePathParams<TPath>, string>\n  >,\n  TAllParams extends RouteConstraints['TAllParams'] = ResolveAllParams<\n    TParentRoute,\n    TParams\n  >,\n  TRouteContext extends RouteConstraints['TRouteContext'] = RouteContext,\n  TAllContext extends Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  > = Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  >,\n  TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderData extends any = unknown,\n  TChildren extends RouteConstraints['TChildren'] = unknown,\n  TRouteTree extends RouteConstraints['TRouteTree'] = AnyRoute,\n> {\n  isRoot: TParentRoute extends Route<any> ? true : false\n  options: RouteOptions<\n    TParentRoute,\n    TCustomId,\n    TPath,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContext,\n    TAllContext,\n    TLoaderDeps,\n    TLoaderData\n  >\n\n  test!: Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  >\n\n  // Set up in this.init()\n  parentRoute!: TParentRoute\n  id!: TId\n  // customId!: TCustomId\n  path!: TPath\n  fullPath!: TFullPath\n  to!: TrimPathRight<TFullPath>\n\n  // Optional\n  children?: TChildren\n  originalIndex?: number\n  router?: AnyRouter\n  rank!: number\n\n  constructor(\n    options: RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParams,\n      TAllParams,\n      TRouteContext,\n      TAllContext,\n      TLoaderDeps,\n      TLoaderData\n    >,\n  ) {\n    this.options = (options as any) || {}\n    this.isRoot = !options?.getParentRoute as any\n    invariant(\n      !((options as any)?.id && (options as any)?.path),\n      `Route cannot have both an 'id' and a 'path' option.`,\n    )\n    ;(this as any).$$typeof = Symbol.for('react.memo')\n  }\n\n  types!: {\n    parentRoute: TParentRoute\n    path: TPath\n    to: TrimPathRight<TFullPath>\n    fullPath: TFullPath\n    customId: TCustomId\n    id: TId\n    searchSchema: TSearchSchema\n    fullSearchSchema: TFullSearchSchema\n    params: TParams\n    allParams: TAllParams\n    routeContext: TRouteContext\n    allContext: TAllContext\n    children: TChildren\n    routeTree: TRouteTree\n    routerContext: TRouterContext\n    loaderData: TLoaderData\n    loaderDeps: TLoaderDeps\n  }\n\n  init = (opts: { originalIndex: number }) => {\n    this.originalIndex = opts.originalIndex\n\n    const options = this.options as RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParams,\n      TAllParams,\n      TRouteContext,\n      TAllContext,\n      TLoaderDeps,\n      TLoaderData\n    > &\n      RoutePathOptionsIntersection<TCustomId, TPath>\n\n    const isRoot = !options?.path && !options?.id\n\n    this.parentRoute = this.options?.getParentRoute?.()\n\n    if (isRoot) {\n      this.path = rootRouteId as TPath\n    } else {\n      invariant(\n        this.parentRoute,\n        `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`,\n      )\n    }\n\n    let path: undefined | string = isRoot ? rootRouteId : options.path\n\n    // If the path is anything other than an index path, trim it up\n    if (path && path !== '/') {\n      path = trimPath(path)\n    }\n\n    const customId = options?.id || path\n\n    // Strip the parentId prefix from the first level of children\n    let id = isRoot\n      ? rootRouteId\n      : joinPaths([\n          (this.parentRoute.id as any) === rootRouteId\n            ? ''\n            : this.parentRoute.id,\n          customId,\n        ])\n\n    if (path === rootRouteId) {\n      path = '/'\n    }\n\n    if (id !== rootRouteId) {\n      id = joinPaths(['/', id])\n    }\n\n    const fullPath =\n      id === rootRouteId ? '/' : joinPaths([this.parentRoute.fullPath, path])\n\n    this.path = path as TPath\n    this.id = id as TId\n    // this.customId = customId as TCustomId\n    this.fullPath = fullPath as TFullPath\n    this.to = fullPath as TrimPathRight<TFullPath>\n  }\n\n  addChildren = <TNewChildren extends AnyRoute[]>(\n    children: TNewChildren,\n  ): Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContext,\n    TAllContext,\n    TRouterContext,\n    TLoaderDeps,\n    TLoaderData,\n    TNewChildren,\n    TRouteTree\n  > => {\n    this.children = children as any\n    return this as any\n  }\n\n  update = (options: UpdatableRouteOptions<TFullSearchSchema>) => {\n    Object.assign(this.options, options)\n    return this\n  }\n\n  useMatch = <TSelected = TAllContext>(opts?: {\n    select?: (search: TAllContext) => TSelected\n  }): TSelected => {\n    return useMatch({ ...opts, from: this.id }) as any\n  }\n\n  useRouteContext = <TSelected = TAllContext>(opts?: {\n    select?: (search: TAllContext) => TSelected\n  }): TSelected => {\n    return useMatch({\n      ...opts,\n      from: this.id,\n      select: (d: any) => (opts?.select ? opts.select(d.context) : d.context),\n    } as any)\n  }\n\n  useSearch = <TSelected = TFullSearchSchema>(opts?: {\n    select?: (search: TFullSearchSchema) => TSelected\n  }): TSelected => {\n    return useSearch({ ...opts, from: this.id } as any)\n  }\n\n  useParams = <TSelected = TAllParams>(opts?: {\n    select?: (search: TAllParams) => TSelected\n  }): TSelected => {\n    return useParams({ ...opts, from: this.id } as any)\n  }\n\n  useLoaderDeps = <TSelected = TLoaderDeps>(opts?: {\n    select?: (s: TLoaderDeps) => TSelected\n  }): TSelected => {\n    return useLoaderDeps({ ...opts, from: this.id } as any) as any\n  }\n\n  useLoaderData = <TSelected = TLoaderData>(opts?: {\n    select?: (search: TLoaderData) => TSelected\n  }): TSelected => {\n    return useLoaderData({ ...opts, from: this.id } as any) as any\n  }\n}\n\nexport type AnyRootRoute = RootRoute<any, any, any, any>\n\nexport function rootRouteWithContext<TRouterContext extends {}>() {\n  return <\n    TSearchSchema extends Record<string, any> = {},\n    TRouteContext extends RouteContext = RouteContext,\n    TLoaderDeps extends Record<string, any> = {},\n    TLoaderData extends any = unknown,\n  >(\n    options?: Omit<\n      RouteOptions<\n        AnyRoute, // TParentRoute\n        RootRouteId, // TCustomId\n        '', // TPath\n        TSearchSchema, // TSearchSchema\n        TSearchSchema, // TFullSearchSchema\n        {}, // TParams\n        {}, // TAllParams\n        TRouteContext, // TRouteContext\n        Assign<TRouterContext, TRouteContext>, // TAllContext\n        TLoaderDeps,\n        TLoaderData // TLoaderData,\n      >,\n      | 'path'\n      | 'id'\n      | 'getParentRoute'\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n    >,\n  ): RootRoute<TSearchSchema, TRouteContext, TRouterContext> => {\n    return new RootRoute(options) as any\n  }\n}\n\nexport class RootRoute<\n  TSearchSchema extends Record<string, any> = {},\n  TRouteContext extends RouteContext = RouteContext,\n  TRouterContext extends {} = {},\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderData extends any = unknown,\n> extends Route<\n  any, // TParentRoute\n  '/', // TPath\n  '/', // TFullPath\n  string, // TCustomId\n  RootRouteId, // TId\n  TSearchSchema, // TSearchSchema\n  TSearchSchema, // TFullSearchSchema\n  {}, // TParams\n  {}, // TAllParams\n  TRouteContext, // TRouteContext\n  Expand<Assign<TRouterContext, TRouteContext>>, // TAllContext\n  TRouterContext, // TRouterContext\n  TLoaderDeps,\n  TLoaderData,\n  any, // TChildren\n  any // TRouteTree\n> {\n  constructor(\n    options?: Omit<\n      RouteOptions<\n        AnyRoute, // TParentRoute\n        RootRouteId, // TCustomId\n        '', // TPath\n        TSearchSchema, // TSearchSchema\n        TSearchSchema, // TFullSearchSchema\n        {}, // TParams\n        {}, // TAllParams\n        TRouteContext, // TRouteContext\n        Assign<TRouterContext, TRouteContext>, // TAllContext\n        TLoaderDeps,\n        TLoaderData\n      >,\n      | 'path'\n      | 'id'\n      | 'getParentRoute'\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n    >,\n  ) {\n    super(options as any)\n  }\n}\n\nexport type ResolveFullPath<\n  TParentRoute extends AnyRoute,\n  TPath extends string,\n  TPrefixed = RoutePrefix<TParentRoute['fullPath'], TPath>,\n> = TPrefixed extends RootRouteId ? '/' : TPrefixed\n\ntype RoutePrefix<\n  TPrefix extends string,\n  TPath extends string,\n> = string extends TPath\n  ? RootRouteId\n  : TPath extends string\n    ? TPrefix extends RootRouteId\n      ? TPath extends '/'\n        ? '/'\n        : `/${TrimPath<TPath>}`\n      : `${TPrefix}/${TPath}` extends '/'\n        ? '/'\n        : `/${TrimPathLeft<`${TrimPathRight<TPrefix>}/${TrimPath<TPath>}`>}`\n    : never\n\nexport type TrimPath<T extends string> = '' extends T\n  ? ''\n  : TrimPathRight<TrimPathLeft<T>>\n\nexport type TrimPathLeft<T extends string> =\n  T extends `${RootRouteId}/${infer U}`\n    ? TrimPathLeft<U>\n    : T extends `/${infer U}`\n      ? TrimPathLeft<U>\n      : T\nexport type TrimPathRight<T extends string> = T extends '/'\n  ? '/'\n  : T extends `${infer U}/`\n    ? TrimPathRight<U>\n    : T\n\nexport type RouteMask<TRouteTree extends AnyRoute> = {\n  routeTree: TRouteTree\n  from: RoutePaths<TRouteTree>\n  to?: any\n  params?: any\n  search?: any\n  hash?: any\n  state?: any\n  unmaskOnReload?: boolean\n}\n\nexport function createRouteMask<\n  TRouteTree extends AnyRoute,\n  TFrom extends RoutePaths<TRouteTree>,\n  TTo extends string,\n>(\n  opts: {\n    routeTree: TRouteTree\n  } & ToSubOptions<TRouteTree, TFrom, TTo>,\n): RouteMask<TRouteTree> {\n  return opts as any\n}\n\nexport type ErrorRouteProps = {\n  error: unknown\n  info: { componentStack: string }\n}\n//\n\nexport type ReactNode = any\n\nexport type SyncRouteComponent<TProps> =\n  | ((props: TProps) => ReactNode)\n  | React.LazyExoticComponent<(props: TProps) => ReactNode>\n\nexport type AsyncRouteComponent<TProps> = SyncRouteComponent<TProps> & {\n  preload?: () => Promise<void>\n}\n\nexport type RouteComponent<TProps = any> = SyncRouteComponent<TProps> &\n  AsyncRouteComponent<TProps>\n\nexport type ErrorRouteComponent = RouteComponent<ErrorRouteProps>\n\nexport class NotFoundRoute<\n  TParentRoute extends AnyRootRoute,\n  TSearchSchema extends RouteConstraints['TSearchSchema'] = {},\n  TFullSearchSchema extends\n    RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchema<\n    TParentRoute,\n    TSearchSchema\n  >,\n  TRouteContext extends RouteConstraints['TRouteContext'] = RouteContext,\n  TAllContext extends Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  > = Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  >,\n  TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderData extends any = unknown,\n  TChildren extends RouteConstraints['TChildren'] = unknown,\n  TRouteTree extends RouteConstraints['TRouteTree'] = AnyRoute,\n> extends Route<\n  TParentRoute,\n  '/404',\n  '/404',\n  '404',\n  '404',\n  TSearchSchema,\n  TFullSearchSchema,\n  {},\n  {},\n  TRouteContext,\n  TAllContext,\n  TRouterContext,\n  TLoaderDeps,\n  TLoaderData,\n  TChildren,\n  TRouteTree\n> {\n  constructor(\n    options: Omit<\n      RouteOptions<\n        TParentRoute,\n        string,\n        string,\n        TSearchSchema,\n        TFullSearchSchema,\n        {},\n        {},\n        TRouteContext,\n        TAllContext,\n        TLoaderDeps,\n        TLoaderData\n      >,\n      'caseSensitive' | 'parseParams' | 'stringifyParams' | 'path' | 'id'\n    >,\n  ) {\n    super({\n      ...(options as any),\n      id: '404',\n    })\n  }\n}\n","import * as React from 'react'\nimport { useMatch } from './Matches'\nimport { useRouter, useRouterState } from './RouterProvider'\nimport { Trim } from './fileRoute'\nimport { AnyRoute, ReactNode } from './route'\nimport {\n  AllParams,\n  FullSearchSchema,\n  RouteByPath,\n  RouteIds,\n  RoutePaths,\n} from './routeInfo'\nimport { RegisteredRouter } from './router'\nimport { LinkProps, UseLinkPropsOptions } from './useNavigate'\nimport {\n  Expand,\n  NoInfer,\n  NonNullableUpdater,\n  PickRequired,\n  UnionToIntersection,\n  Updater,\n  deepEqual,\n  functionalUpdate,\n} from './utils'\nimport { HistoryState } from '@tanstack/history'\n\nexport type CleanPath<T extends string> = T extends `${infer L}//${infer R}`\n  ? CleanPath<`${CleanPath<L>}/${CleanPath<R>}`>\n  : T extends `${infer L}//`\n    ? `${CleanPath<L>}/`\n    : T extends `//${infer L}`\n      ? `/${CleanPath<L>}`\n      : T\n\nexport type Split<S, TIncludeTrailingSlash = true> = S extends unknown\n  ? string extends S\n    ? string[]\n    : S extends string\n      ? CleanPath<S> extends ''\n        ? []\n        : TIncludeTrailingSlash extends true\n          ? CleanPath<S> extends `${infer T}/`\n            ? [...Split<T>, '/']\n            : CleanPath<S> extends `/${infer U}`\n              ? Split<U>\n              : CleanPath<S> extends `${infer T}/${infer U}`\n                ? [...Split<T>, ...Split<U>]\n                : [S]\n          : CleanPath<S> extends `${infer T}/${infer U}`\n            ? [...Split<T>, ...Split<U>]\n            : S extends string\n              ? [S]\n              : never\n      : never\n  : never\n\nexport type ParsePathParams<T extends string> = keyof {\n  [K in Trim<Split<T>[number], '_'> as K extends `$${infer L}` ? L : never]: K\n}\n\nexport type Join<T, Delimiter extends string = '/'> = T extends []\n  ? ''\n  : T extends [infer L extends string]\n    ? L\n    : T extends [infer L extends string, ...infer Tail extends [...string[]]]\n      ? CleanPath<`${L}${Delimiter}${Join<Tail>}`>\n      : never\n\nexport type Last<T extends any[]> = T extends [...infer _, infer L] ? L : never\n\nexport type RelativeToPathAutoComplete<\n  AllPaths extends string,\n  TFrom extends string,\n  TTo extends string,\n  SplitPaths extends string[] = Split<AllPaths, false>,\n> = TTo extends `..${infer _}`\n  ? SplitPaths extends [\n      ...Split<ResolveRelativePath<TFrom, TTo>, false>,\n      ...infer TToRest,\n    ]\n    ? `${CleanPath<\n        Join<\n          [\n            ...Split<TTo, false>,\n            ...(\n              | TToRest\n              | (Split<\n                  ResolveRelativePath<TFrom, TTo>,\n                  false\n                >['length'] extends 1\n                  ? never\n                  : ['../'])\n            ),\n          ]\n        >\n      >}`\n    : never\n  : TTo extends `./${infer RestTTo}`\n    ? SplitPaths extends [\n        ...Split<TFrom, false>,\n        ...Split<RestTTo, false>,\n        ...infer RestPath,\n      ]\n      ? `${TTo}${Join<RestPath>}`\n      : never\n    :\n        | (TFrom extends `/`\n            ? never\n            : SplitPaths extends [...Split<TFrom, false>, ...infer RestPath]\n              ? Join<RestPath> extends { length: 0 }\n                ? never\n                : './'\n              : never)\n        | (TFrom extends `/` ? never : '../')\n        | AllPaths\n\nexport type NavigateOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n> = ToOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // `replace` is a boolean that determines whether the navigation should replace the current history entry or push a new one.\n  replace?: boolean\n  resetScroll?: boolean\n  // If set to `true`, the link's underlying navigate() call will be wrapped in a `React.startTransition` call. Defaults to `true`.\n  startTransition?: boolean\n}\n\nexport type ToOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ToSubOptions<TRouteTree, TFrom, TTo> & {\n  mask?: ToMaskOptions<TRouteTree, TMaskFrom, TMaskTo>\n}\n\nexport type ToMaskOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ToSubOptions<TRouteTree, TMaskFrom, TMaskTo> & {\n  unmaskOnReload?: boolean\n}\n\nexport type ToSubOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n> = {\n  to?: ToPathOption<TRouteTree, TFrom, TTo>\n  // The new has string or a function to update it\n  hash?: true | Updater<string>\n  // State to pass to the history stack\n  state?: true | NonNullableUpdater<HistoryState>\n  // The source route path. This is automatically set when using route-level APIs, but for type-safe relative routing on the router itself, this is required\n  from?: TFrom\n  // // When using relative route paths, this option forces resolution from the current path, instead of the route API's path or `from` path\n} & CheckPath<TRouteTree, NoInfer<TResolved>, {}> &\n  SearchParamOptions<TRouteTree, TFrom, TTo, TResolved> &\n  PathParamOptions<TRouteTree, TFrom, TResolved>\n\nexport type SearchParamOptions<\n  TRouteTree extends AnyRoute,\n  TFrom,\n  TTo,\n  TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n  TFromSearchEnsured = '/' extends TFrom\n    ? FullSearchSchema<TRouteTree>\n    : Expand<\n          PickRequired<\n            RouteByPath<TRouteTree, TFrom>['types']['fullSearchSchema']\n          >\n      >,\n  TFromSearchOptional = Omit<\n    FullSearchSchema<TRouteTree>,\n    keyof TFromSearchEnsured\n  >,\n  TFromSearch = Expand<TFromSearchEnsured & TFromSearchOptional>,\n  TToSearch = '' extends TTo\n    ? FullSearchSchema<TRouteTree>\n    : Expand<RouteByPath<TRouteTree, TResolved>['types']['fullSearchSchema']>,\n> = keyof PickRequired<TToSearch> extends never\n  ? {\n      search?: true | SearchReducer<TFromSearch, TToSearch>\n    }\n  : {\n      search: TFromSearchEnsured extends PickRequired<TToSearch>\n        ? true | SearchReducer<TFromSearch, TToSearch>\n        : SearchReducer<TFromSearch, TToSearch>\n    }\n\ntype SearchReducer<TFrom, TTo> = TTo | ((current: TFrom) => TTo)\n\nexport type PathParamOptions<\n  TRouteTree extends AnyRoute,\n  TFrom,\n  TTo,\n  TFromParamsEnsured = Expand<\n    UnionToIntersection<\n      PickRequired<RouteByPath<TRouteTree, TFrom>['types']['allParams']>\n    >\n  >,\n  TFromParamsOptional = Omit<AllParams<TRouteTree>, keyof TFromParamsEnsured>,\n  TFromParams = Expand<TFromParamsOptional & TFromParamsEnsured>,\n  TToParams = Expand<RouteByPath<TRouteTree, TTo>['types']['allParams']>,\n> = never extends TToParams\n  ? {\n      params?: true | ParamsReducer<Partial<TFromParams>, Partial<TFromParams>>\n    }\n  : keyof PickRequired<TToParams> extends never\n    ? {\n        params?: true | ParamsReducer<TFromParams, TToParams>\n      }\n    : {\n        params: TFromParamsEnsured extends PickRequired<TToParams>\n          ? true | ParamsReducer<TFromParams, TToParams>\n          : ParamsReducer<TFromParams, TToParams>\n      }\n\ntype ParamsReducer<TFrom, TTo> = TTo | ((current: TFrom) => TTo)\n\nexport type ToPathOption<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n> =\n  | TTo\n  | RelativeToPathAutoComplete<\n      RoutePaths<TRouteTree>,\n      NoInfer<TFrom> extends string ? NoInfer<TFrom> : '',\n      NoInfer<TTo> & string\n    >\n\nexport type ToIdOption<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n> =\n  | TTo\n  | RelativeToPathAutoComplete<\n      RouteIds<TRouteTree>,\n      NoInfer<TFrom> extends string ? NoInfer<TFrom> : '',\n      NoInfer<TTo> & string\n    >\n\nexport interface ActiveOptions {\n  exact?: boolean\n  includeHash?: boolean\n  includeSearch?: boolean\n}\n\nexport type LinkOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n> = NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // The standard anchor tag target attribute\n  target?: HTMLAnchorElement['target']\n  // Defaults to `{ exact: false, includeHash: false }`\n  activeOptions?: ActiveOptions\n  // If set, will preload the linked route on hover and cache it for this many milliseconds in hopes that the user will eventually navigate there.\n  preload?: false | 'intent'\n  // Delay intent preloading by this many milliseconds. If the intent exits before this delay, the preload will be cancelled.\n  preloadDelay?: number\n  // If true, will render the link without the href attribute\n  disabled?: boolean\n}\n\nexport type CheckRelativePath<\n  TRouteTree extends AnyRoute,\n  TFrom,\n  TTo,\n> = TTo extends string\n  ? TFrom extends string\n    ? ResolveRelativePath<TFrom, TTo> extends RoutePaths<TRouteTree>\n      ? {}\n      : {\n          Error: `${TFrom} + ${TTo} resolves to ${ResolveRelativePath<\n            TFrom,\n            TTo\n          >}, which is not a valid route path.`\n          'Valid Route Paths': RoutePaths<TRouteTree>\n        }\n    : {}\n  : {}\n\nexport type CheckPath<TRouteTree extends AnyRoute, TPath, TPass> = Exclude<\n  TPath,\n  RoutePaths<TRouteTree>\n> extends never\n  ? TPass\n  : CheckPathError<TRouteTree, Exclude<TPath, RoutePaths<TRouteTree>>>\n\nexport type CheckPathError<TRouteTree extends AnyRoute, TInvalids> = {\n  to: RoutePaths<TRouteTree>\n}\n\nexport type CheckId<TRouteTree extends AnyRoute, TPath, TPass> = Exclude<\n  TPath,\n  RouteIds<TRouteTree>\n> extends never\n  ? TPass\n  : CheckIdError<TRouteTree, Exclude<TPath, RouteIds<TRouteTree>>>\n\nexport type CheckIdError<TRouteTree extends AnyRoute, TInvalids> = {\n  Error: `${TInvalids extends string\n    ? TInvalids\n    : never} is not a valid route ID.`\n  'Valid Route IDs': RouteIds<TRouteTree>\n}\n\nexport type ResolveRelativePath<TFrom, TTo = '.'> = TFrom extends string\n  ? TTo extends string\n    ? TTo extends '.'\n      ? TFrom\n      : TTo extends `./`\n        ? Join<[TFrom, '/']>\n        : TTo extends `./${infer TRest}`\n          ? ResolveRelativePath<TFrom, TRest>\n          : TTo extends `/${infer TRest}`\n            ? TTo\n            : Split<TTo> extends ['..', ...infer ToRest]\n              ? Split<TFrom> extends [...infer FromRest, infer FromTail]\n                ? ToRest extends ['/']\n                  ? Join<[...FromRest, '/']>\n                  : ResolveRelativePath<Join<FromRest>, Join<ToRest>>\n                : never\n              : Split<TTo> extends ['.', ...infer ToRest]\n                ? ToRest extends ['/']\n                  ? Join<[TFrom, '/']>\n                  : ResolveRelativePath<TFrom, Join<ToRest>>\n                : CleanPath<Join<['/', ...Split<TFrom>, ...Split<TTo>]>>\n    : never\n  : never\n\ntype LinkCurrentTargetElement = {\n  preloadTimeout?: null | ReturnType<typeof setTimeout>\n}\n\nconst preloadWarning = 'Error preloading route! â˜ï¸'\n\nexport function useLinkProps<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n>(\n  options: UseLinkPropsOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n): React.AnchorHTMLAttributes<HTMLAnchorElement> {\n  const router = useRouter()\n  const matchPathname = useMatch({\n    strict: false,\n    select: (s) => s.pathname,\n  })\n\n  const {\n    // custom props\n    children,\n    target,\n    activeProps = () => ({ className: 'active' }),\n    inactiveProps = () => ({}),\n    activeOptions,\n    disabled,\n    hash,\n    search,\n    params,\n    to,\n    state,\n    mask,\n    preload: userPreload,\n    preloadDelay: userPreloadDelay,\n    replace,\n    startTransition,\n    resetScroll,\n    // element props\n    style,\n    className,\n    onClick,\n    onFocus,\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart,\n    ...rest\n  } = options\n\n  // If this link simply reloads the current route,\n  // make sure it has a new key so it will trigger a data refresh\n\n  // If this `to` is a valid external URL, return\n  // null for LinkUtils\n\n  const dest = {\n    from: options.to ? matchPathname : undefined,\n    ...options,\n  }\n\n  let type: 'internal' | 'external' = 'internal'\n\n  try {\n    new URL(`${to}`)\n    type = 'external'\n  } catch {}\n\n  if (type === 'external') {\n    return {\n      href: to,\n    }\n  }\n\n  const next = router.buildLocation(dest as any)\n\n  const preload = userPreload ?? router.options.defaultPreload\n  const preloadDelay =\n    userPreloadDelay ?? router.options.defaultPreloadDelay ?? 0\n\n  const isActive = useRouterState({\n    select: (s) => {\n      // Compare path/hash for matches\n      const currentPathSplit = s.location.pathname.split('/')\n      const nextPathSplit = next.pathname.split('/')\n      const pathIsFuzzyEqual = nextPathSplit.every(\n        (d, i) => d === currentPathSplit[i],\n      )\n      // Combine the matches based on user router.options\n      const pathTest = activeOptions?.exact\n        ? s.location.pathname === next.pathname\n        : pathIsFuzzyEqual\n      const hashTest = activeOptions?.includeHash\n        ? s.location.hash === next.hash\n        : true\n      const searchTest =\n        activeOptions?.includeSearch ?? true\n          ? deepEqual(s.location.search, next.search, !activeOptions?.exact)\n          : true\n\n      // The final \"active\" test\n      return pathTest && hashTest && searchTest\n    },\n  })\n\n  // The click handler\n  const handleClick = (e: MouseEvent) => {\n    if (\n      !disabled &&\n      !isCtrlEvent(e) &&\n      !e.defaultPrevented &&\n      (!target || target === '_self') &&\n      e.button === 0\n    ) {\n      e.preventDefault()\n\n      // All is well? Navigate!\n      router.commitLocation({ ...next, replace, resetScroll, startTransition })\n    }\n  }\n\n  // The click handler\n  const handleFocus = (e: MouseEvent) => {\n    if (preload) {\n      router.preloadRoute(dest as any).catch((err) => {\n        console.warn(err)\n        console.warn(preloadWarning)\n      })\n    }\n  }\n\n  const handleTouchStart = (e: TouchEvent) => {\n    if (preload) {\n      router.preloadRoute(dest as any).catch((err) => {\n        console.warn(err)\n        console.warn(preloadWarning)\n      })\n    }\n  }\n\n  const handleEnter = (e: MouseEvent) => {\n    const target = (e.target || {}) as LinkCurrentTargetElement\n\n    if (preload) {\n      if (target.preloadTimeout) {\n        return\n      }\n\n      target.preloadTimeout = setTimeout(() => {\n        target.preloadTimeout = null\n        router.preloadRoute(dest as any).catch((err) => {\n          console.warn(err)\n          console.warn(preloadWarning)\n        })\n      }, preloadDelay)\n    }\n  }\n\n  const handleLeave = (e: MouseEvent) => {\n    const target = (e.target || {}) as LinkCurrentTargetElement\n\n    if (target.preloadTimeout) {\n      clearTimeout(target.preloadTimeout)\n      target.preloadTimeout = null\n    }\n  }\n\n  const composeHandlers =\n    (handlers: (undefined | ((e: any) => void))[]) =>\n    (e: React.SyntheticEvent) => {\n      if (e.persist) e.persist()\n      handlers.filter(Boolean).forEach((handler) => {\n        if (e.defaultPrevented) return\n        handler!(e)\n      })\n    }\n\n  // Get the active props\n  const resolvedActiveProps: React.HTMLAttributes<HTMLAnchorElement> = isActive\n    ? functionalUpdate(activeProps as any, {}) ?? {}\n    : {}\n\n  // Get the inactive props\n  const resolvedInactiveProps: React.HTMLAttributes<HTMLAnchorElement> =\n    isActive ? {} : functionalUpdate(inactiveProps, {}) ?? {}\n\n  return {\n    ...resolvedActiveProps,\n    ...resolvedInactiveProps,\n    ...rest,\n    href: disabled\n      ? undefined\n      : next.maskedLocation\n        ? next.maskedLocation.href\n        : next.href,\n    onClick: composeHandlers([onClick, handleClick]),\n    onFocus: composeHandlers([onFocus, handleFocus]),\n    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),\n    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),\n    onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),\n    target,\n    style: {\n      ...style,\n      ...resolvedActiveProps.style,\n      ...resolvedInactiveProps.style,\n    },\n    className:\n      [\n        className,\n        resolvedActiveProps.className,\n        resolvedInactiveProps.className,\n      ]\n        .filter(Boolean)\n        .join(' ') || undefined,\n    ...(disabled\n      ? {\n          role: 'link',\n          'aria-disabled': true,\n        }\n      : undefined),\n    ['data-status']: isActive ? 'active' : undefined,\n  }\n}\n\nexport interface LinkComponent<TProps extends Record<string, any> = {}> {\n  <\n    TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n    TFrom extends RoutePaths<TRouteTree> = '/',\n    TTo extends string = '',\n    TMaskFrom extends RoutePaths<TRouteTree> = '/',\n    TMaskTo extends string = '',\n  >(\n    props: LinkProps<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> &\n      TProps &\n      React.RefAttributes<HTMLAnchorElement>,\n  ): ReactNode\n}\n\nexport const Link: LinkComponent = React.forwardRef((props: any, ref) => {\n  const linkProps = useLinkProps(props)\n\n  return (\n    <a\n      {...{\n        ref: ref as any,\n        ...linkProps,\n        children:\n          typeof props.children === 'function'\n            ? props.children({\n                isActive: (linkProps as any)['data-status'] === 'active',\n              })\n            : props.children,\n      }}\n    />\n  )\n}) as any\n\nfunction isCtrlEvent(e: MouseEvent) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n}\n","// @ts-nocheck\n\n// qss has been slightly modified and inlined here for our use cases (and compression's sake). We've included it as a hard dependency for MIT license attribution.\n\nexport function encode(obj, pfx?: string) {\n  var k,\n    i,\n    tmp,\n    str = ''\n\n  for (k in obj) {\n    if ((tmp = obj[k]) !== void 0) {\n      if (Array.isArray(tmp)) {\n        for (i = 0; i < tmp.length; i++) {\n          str && (str += '&')\n          str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp[i])\n        }\n      } else {\n        str && (str += '&')\n        str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp)\n      }\n    }\n  }\n\n  return (pfx || '') + str\n}\n\nfunction toValue(mix) {\n  if (!mix) return ''\n  var str = decodeURIComponent(mix)\n  if (str === 'false') return false\n  if (str === 'true') return true\n  return +str * 0 === 0 && +str + '' === str ? +str : str\n}\n\nexport function decode(str) {\n  var tmp,\n    k,\n    out = {},\n    arr = str.split('&')\n\n  while ((tmp = arr.shift())) {\n    tmp = tmp.split('=')\n    k = tmp.shift()\n    if (out[k] !== void 0) {\n      out[k] = [].concat(out[k], toValue(tmp.shift()))\n    } else {\n      out[k] = toValue(tmp.shift())\n    }\n  }\n\n  return out\n}\n","import { NavigateOptions } from './link'\nimport { AnyRoute } from './route'\nimport { RoutePaths } from './routeInfo'\nimport { RegisteredRouter } from './router'\n\n// Detect if we're in the DOM\n\nexport type AnyRedirect = Redirect<any, any, any, any, any>\n\nexport type Redirect<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n> = {\n  code?: number\n  throw?: any\n} & NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>\n\nexport function redirect<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n>(\n  opts: Redirect<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n): Redirect<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> {\n  ;(opts as any).isRedirect = true\n  if (opts.throw) {\n    throw opts\n  }\n  return opts\n}\n\nexport function isRedirect(obj: any): obj is AnyRedirect {\n  return !!obj?.isRedirect\n}\n","import { decode, encode } from './qss'\nimport { AnySearchSchema } from './route'\n\nexport const defaultParseSearch = parseSearchWith(JSON.parse)\nexport const defaultStringifySearch = stringifySearchWith(\n  JSON.stringify,\n  JSON.parse,\n)\n\nexport function parseSearchWith(parser: (str: string) => any) {\n  return (searchStr: string): AnySearchSchema => {\n    if (searchStr.substring(0, 1) === '?') {\n      searchStr = searchStr.substring(1)\n    }\n\n    let query: Record<string, unknown> = decode(searchStr)\n\n    // Try to parse any query params that might be json\n    for (let key in query) {\n      const value = query[key]\n      if (typeof value === 'string') {\n        try {\n          query[key] = parser(value)\n        } catch (err) {\n          //\n        }\n      }\n    }\n\n    return query\n  }\n}\n\nexport function stringifySearchWith(\n  stringify: (search: any) => string,\n  parser?: (str: string) => any,\n) {\n  function stringifyValue(val: any) {\n    if (typeof val === 'object' && val !== null) {\n      try {\n        return stringify(val)\n      } catch (err) {\n        // silent\n      }\n    } else if (typeof val === 'string' && typeof parser === 'function') {\n      try {\n        // Check if it's a valid parseable string.\n        // If it is, then stringify it again.\n        parser(val)\n        return stringify(val)\n      } catch (err) {\n        // silent\n      }\n    }\n    return val\n  }\n\n  return (search: Record<string, any>) => {\n    search = { ...search }\n\n    if (search) {\n      Object.keys(search).forEach((key) => {\n        const val = search[key]\n        if (typeof val === 'undefined' || val === undefined) {\n          delete search[key]\n        } else {\n          search[key] = stringifyValue(val)\n        }\n      })\n    }\n\n    const searchStr = encode(search as Record<string, string>).toString()\n\n    return searchStr ? `?${searchStr}` : ''\n  }\n}\n\nexport type SearchSerializer = (searchObj: Record<string, any>) => string\nexport type SearchParser = (searchStr: string) => Record<string, any>\n","import {\n  HistoryLocation,\n  HistoryState,\n  RouterHistory,\n  createBrowserHistory,\n  createMemoryHistory,\n} from '@tanstack/history'\nimport { Store } from '@tanstack/store'\n\n//\n\nimport {\n  AnySearchSchema,\n  AnyRoute,\n  AnyContext,\n  AnyPathParams,\n  RouteMask,\n  Route,\n  LoaderFnContext,\n} from './route'\nimport { FullSearchSchema, RoutesById, RoutesByPath } from './routeInfo'\nimport { defaultParseSearch, defaultStringifySearch } from './searchParams'\nimport {\n  PickAsRequired,\n  Updater,\n  NonNullableUpdater,\n  replaceEqualDeep,\n  deepEqual,\n  escapeJSON,\n  functionalUpdate,\n  last,\n  pick,\n  Timeout,\n} from './utils'\nimport { RouteComponent } from './route'\nimport { AnyRouteMatch, RouteMatch } from './Matches'\nimport { ParsedLocation } from './location'\nimport { SearchSerializer, SearchParser } from './searchParams'\nimport {\n  BuildLocationFn,\n  CommitLocationOptions,\n  InjectedHtmlEntry,\n  MatchRouteFn,\n  NavigateFn,\n  getRouteMatch,\n} from './RouterProvider'\n\nimport {\n  cleanPath,\n  interpolatePath,\n  joinPaths,\n  matchPathname,\n  parsePathname,\n  removeBasepath,\n  resolvePath,\n  trimPath,\n  trimPathLeft,\n  trimPathRight,\n} from './path'\nimport invariant from 'tiny-invariant'\nimport { isRedirect } from './redirects'\nimport { ToOptions } from './link'\n// import warning from 'tiny-warning'\n\n//\n\ndeclare global {\n  interface Window {\n    __TSR_DEHYDRATED__?: HydrationCtx\n    __TSR_ROUTER_CONTEXT__?: React.Context<Router<any>>\n  }\n}\n\nexport interface Register {\n  // router: Router\n}\n\nexport type AnyRouter = Router<AnyRoute, any>\n\nexport type RegisteredRouter = Register extends {\n  router: infer TRouter extends AnyRouter\n}\n  ? TRouter\n  : AnyRouter\n\nexport type HydrationCtx = {\n  router: DehydratedRouter\n  payload: Record<string, any>\n}\n\nexport type RouterContextOptions<TRouteTree extends AnyRoute> =\n  AnyContext extends TRouteTree['types']['routerContext']\n    ? {\n        context?: TRouteTree['types']['routerContext']\n      }\n    : {\n        context: TRouteTree['types']['routerContext']\n      }\n\nexport interface RouterOptions<\n  TRouteTree extends AnyRoute,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> {\n  history?: RouterHistory\n  stringifySearch?: SearchSerializer\n  parseSearch?: SearchParser\n  defaultPreload?: false | 'intent'\n  defaultPreloadDelay?: number\n  defaultComponent?: RouteComponent\n  defaultErrorComponent?: RouteComponent\n  defaultPendingComponent?: RouteComponent\n  defaultPendingMs?: number\n  defaultPendingMinMs?: number\n  defaultStaleTime?: number\n  defaultPreloadStaleTime?: number\n  defaultPreloadGcTime?: number\n  defaultGcTime?: number\n  caseSensitive?: boolean\n  routeTree?: TRouteTree\n  basepath?: string\n  context?: TRouteTree['types']['routerContext']\n  dehydrate?: () => TDehydrated\n  hydrate?: (dehydrated: TDehydrated) => void\n  routeMasks?: RouteMask<TRouteTree>[]\n  unmaskOnReload?: boolean\n  Wrap?: (props: { children: any }) => JSX.Element\n  InnerWrap?: (props: { children: any }) => JSX.Element\n  notFoundRoute?: AnyRoute\n}\n\nexport interface RouterState<TRouteTree extends AnyRoute = AnyRoute> {\n  status: 'pending' | 'idle'\n  isLoading: boolean\n  isTransitioning: boolean\n  matches: RouteMatch<TRouteTree>[]\n  pendingMatches?: RouteMatch<TRouteTree>[]\n  cachedMatches: RouteMatch<TRouteTree>[]\n  location: ParsedLocation<FullSearchSchema<TRouteTree>>\n  resolvedLocation: ParsedLocation<FullSearchSchema<TRouteTree>>\n  lastUpdated: number\n}\n\nexport type ListenerFn<TEvent extends RouterEvent> = (event: TEvent) => void\n\nexport interface BuildNextOptions {\n  to?: string | number | null\n  params?: true | Updater<unknown>\n  search?: true | Updater<unknown>\n  hash?: true | Updater<string>\n  state?: true | NonNullableUpdater<HistoryState>\n  mask?: {\n    to?: string | number | null\n    params?: true | Updater<unknown>\n    search?: true | Updater<unknown>\n    hash?: true | Updater<string>\n    state?: true | NonNullableUpdater<HistoryState>\n    unmaskOnReload?: boolean\n  }\n  from?: string\n}\n\nexport interface DehydratedRouterState {\n  dehydratedMatches: DehydratedRouteMatch[]\n}\n\nexport type DehydratedRouteMatch = Pick<\n  RouteMatch,\n  'id' | 'status' | 'updatedAt'\n>\n\nexport interface DehydratedRouter {\n  state: DehydratedRouterState\n}\n\nexport type RouterConstructorOptions<\n  TRouteTree extends AnyRoute,\n  TDehydrated extends Record<string, any>,\n> = Omit<RouterOptions<TRouteTree, TDehydrated>, 'context'> &\n  RouterContextOptions<TRouteTree>\n\nexport const componentTypes = [\n  'component',\n  'errorComponent',\n  'pendingComponent',\n] as const\n\nexport type RouterEvents = {\n  onBeforeLoad: {\n    type: 'onBeforeLoad'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n  onLoad: {\n    type: 'onLoad'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n  onResolved: {\n    type: 'onResolved'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n}\n\nexport type RouterEvent = RouterEvents[keyof RouterEvents]\n\nexport type RouterListener<TRouterEvent extends RouterEvent> = {\n  eventType: TRouterEvent['type']\n  fn: ListenerFn<TRouterEvent>\n}\n\nexport class Router<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> {\n  // Option-independent properties\n  tempLocationKey: string | undefined = `${Math.round(\n    Math.random() * 10000000,\n  )}`\n  resetNextScroll: boolean = true\n  navigateTimeout: Timeout | null = null\n  latestLoadPromise: Promise<void> = Promise.resolve()\n  subscribers = new Set<RouterListener<RouterEvent>>()\n  injectedHtml: InjectedHtmlEntry[] = []\n  dehydratedData?: TDehydrated\n\n  // Must build in constructor\n  __store!: Store<RouterState<TRouteTree>>\n  options!: PickAsRequired<\n    RouterOptions<TRouteTree, TDehydrated>,\n    'stringifySearch' | 'parseSearch' | 'context'\n  >\n  history!: RouterHistory\n  latestLocation!: ParsedLocation\n  basepath!: string\n  routeTree!: TRouteTree\n  routesById!: RoutesById<TRouteTree>\n  routesByPath!: RoutesByPath<TRouteTree>\n  flatRoutes!: AnyRoute[]\n\n  constructor(options: RouterConstructorOptions<TRouteTree, TDehydrated>) {\n    this.update({\n      defaultPreloadDelay: 50,\n      defaultPendingMs: 1000,\n      defaultPendingMinMs: 500,\n      context: undefined!,\n      ...options,\n      stringifySearch: options?.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options?.parseSearch ?? defaultParseSearch,\n    })\n  }\n\n  // These are default implementations that can optionally be overridden\n  // by the router provider once rendered. We provide these so that the\n  // router can be used in a non-react environment if necessary\n  startReactTransition: (fn: () => void) => void = (fn) => fn()\n\n  update = (newOptions: RouterConstructorOptions<TRouteTree, TDehydrated>) => {\n    this.options = {\n      ...this.options,\n      ...newOptions,\n    }\n\n    this.basepath = `/${trimPath(newOptions.basepath ?? '') ?? ''}`\n\n    if (\n      !this.history ||\n      (this.options.history && this.options.history !== this.history)\n    ) {\n      this.history =\n        this.options.history ??\n        (typeof document !== 'undefined'\n          ? createBrowserHistory()\n          : createMemoryHistory())\n      this.latestLocation = this.parseLocation()\n    }\n\n    if (this.options.routeTree !== this.routeTree) {\n      this.routeTree = this.options.routeTree as TRouteTree\n      this.buildRouteTree()\n    }\n\n    if (!this.__store) {\n      this.__store = new Store(getInitialRouterState(this.latestLocation), {\n        onUpdate: () => {\n          this.__store.state = {\n            ...this.state,\n            status:\n              this.state.isTransitioning || this.state.isLoading\n                ? 'pending'\n                : 'idle',\n          }\n        },\n      })\n    }\n  }\n\n  get state() {\n    return this.__store.state\n  }\n\n  buildRouteTree = () => {\n    this.routesById = {} as RoutesById<TRouteTree>\n    this.routesByPath = {} as RoutesByPath<TRouteTree>\n\n    const notFoundRoute = this.options.notFoundRoute\n    if (notFoundRoute) {\n      notFoundRoute.init({ originalIndex: 99999999999 })\n      ;(this.routesById as any)[notFoundRoute.id] = notFoundRoute\n    }\n\n    const recurseRoutes = (childRoutes: AnyRoute[]) => {\n      childRoutes.forEach((childRoute, i) => {\n        childRoute.init({ originalIndex: i })\n\n        const existingRoute = (this.routesById as any)[childRoute.id]\n\n        invariant(\n          !existingRoute,\n          `Duplicate routes found with id: ${String(childRoute.id)}`,\n        )\n        ;(this.routesById as any)[childRoute.id] = childRoute\n\n        if (!childRoute.isRoot && childRoute.path) {\n          const trimmedFullPath = trimPathRight(childRoute.fullPath)\n          if (\n            !(this.routesByPath as any)[trimmedFullPath] ||\n            childRoute.fullPath.endsWith('/')\n          ) {\n            ;(this.routesByPath as any)[trimmedFullPath] = childRoute\n          }\n        }\n\n        const children = childRoute.children as Route[]\n\n        if (children?.length) {\n          recurseRoutes(children)\n        }\n      })\n    }\n\n    recurseRoutes([this.routeTree])\n\n    const scoredRoutes: {\n      child: AnyRoute\n      trimmed: string\n      parsed: ReturnType<typeof parsePathname>\n      index: number\n      scores: number[]\n    }[] = []\n\n    ;(Object.values(this.routesById) as AnyRoute[]).forEach((d, i) => {\n      if (d.isRoot || !d.path) {\n        return\n      }\n\n      const trimmed = trimPathLeft(d.fullPath)\n      const parsed = parsePathname(trimmed)\n\n      while (parsed.length > 1 && parsed[0]?.value === '/') {\n        parsed.shift()\n      }\n\n      const scores = parsed.map((d) => {\n        if (d.value === '/') {\n          return 0.75\n        }\n\n        if (d.type === 'param') {\n          return 0.5\n        }\n\n        if (d.type === 'wildcard') {\n          return 0.25\n        }\n\n        return 1\n      })\n\n      scoredRoutes.push({ child: d, trimmed, parsed, index: i, scores })\n    })\n\n    this.flatRoutes = scoredRoutes\n      .sort((a, b) => {\n        const minLength = Math.min(a.scores.length, b.scores.length)\n\n        // Sort by min available score\n        for (let i = 0; i < minLength; i++) {\n          if (a.scores[i] !== b.scores[i]) {\n            return b.scores[i]! - a.scores[i]!\n          }\n        }\n\n        // Sort by length of score\n        if (a.scores.length !== b.scores.length) {\n          return b.scores.length - a.scores.length\n        }\n\n        // Sort by min available parsed value\n        for (let i = 0; i < minLength; i++) {\n          if (a.parsed[i]!.value !== b.parsed[i]!.value) {\n            return a.parsed[i]!.value! > b.parsed[i]!.value! ? 1 : -1\n          }\n        }\n\n        // Sort by original index\n        return a.index - b.index\n      })\n      .map((d, i) => {\n        d.child.rank = i\n        return d.child\n      })\n  }\n\n  subscribe = <TType extends keyof RouterEvents>(\n    eventType: TType,\n    fn: ListenerFn<RouterEvents[TType]>,\n  ) => {\n    const listener: RouterListener<any> = {\n      eventType,\n      fn,\n    }\n\n    this.subscribers.add(listener)\n\n    return () => {\n      this.subscribers.delete(listener)\n    }\n  }\n\n  emit = (routerEvent: RouterEvent) => {\n    this.subscribers.forEach((listener) => {\n      if (listener.eventType === routerEvent.type) {\n        listener.fn(routerEvent)\n      }\n    })\n  }\n\n  checkLatest = (promise: Promise<void>): undefined | Promise<void> => {\n    return this.latestLoadPromise !== promise\n      ? this.latestLoadPromise\n      : undefined\n  }\n\n  parseLocation = (\n    previousLocation?: ParsedLocation,\n  ): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n    const parse = ({\n      pathname,\n      search,\n      hash,\n      state,\n    }: HistoryLocation): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n      const parsedSearch = this.options.parseSearch(search)\n\n      return {\n        pathname: pathname,\n        searchStr: search,\n        search: replaceEqualDeep(previousLocation?.search, parsedSearch) as any,\n        hash: hash.split('#').reverse()[0] ?? '',\n        href: `${pathname}${search}${hash}`,\n        state: replaceEqualDeep(previousLocation?.state, state) as HistoryState,\n      }\n    }\n\n    const location = parse(this.history.location)\n\n    let { __tempLocation, __tempKey } = location.state\n\n    if (__tempLocation && (!__tempKey || __tempKey === this.tempLocationKey)) {\n      // Sync up the location keys\n      const parsedTempLocation = parse(__tempLocation) as any\n      parsedTempLocation.state.key = location.state.key\n\n      delete parsedTempLocation.state.__tempLocation\n\n      return {\n        ...parsedTempLocation,\n        maskedLocation: location,\n      }\n    }\n\n    return location\n  }\n\n  resolvePathWithBase = (from: string, path: string) => {\n    return resolvePath(this.basepath!, from, cleanPath(path))\n  }\n\n  get looseRoutesById() {\n    return this.routesById as Record<string, AnyRoute>\n  }\n\n  matchRoutes = <TRouteTree extends AnyRoute>(\n    pathname: string,\n    locationSearch: AnySearchSchema,\n    opts?: { throwOnError?: boolean; debug?: boolean },\n  ): RouteMatch<TRouteTree>[] => {\n    let routeParams: Record<string, string> = {}\n\n    let foundRoute = this.flatRoutes.find((route) => {\n      const matchedParams = matchPathname(\n        this.basepath,\n        trimPathRight(pathname),\n        {\n          to: route.fullPath,\n          caseSensitive:\n            route.options.caseSensitive ?? this.options.caseSensitive,\n          fuzzy: true,\n        },\n      )\n\n      if (matchedParams) {\n        routeParams = matchedParams\n        return true\n      }\n\n      return false\n    })\n\n    let routeCursor: AnyRoute =\n      foundRoute || (this.routesById as any)['__root__']\n\n    let matchedRoutes: AnyRoute[] = [routeCursor]\n\n    // Check to see if the route needs a 404 entry\n    if (\n      // If we found a route, and it's not an index route and we have left over path\n      (foundRoute\n        ? foundRoute.path !== '/' && routeParams['**']\n        : // Or if we didn't find a route and we have left over path\n          trimPathRight(pathname)) &&\n      // And we have a 404 route configured\n      this.options.notFoundRoute\n    ) {\n      matchedRoutes.push(this.options.notFoundRoute)\n    }\n\n    while (routeCursor?.parentRoute) {\n      routeCursor = routeCursor.parentRoute\n      if (routeCursor) matchedRoutes.unshift(routeCursor)\n    }\n\n    // Existing matches are matches that are already loaded along with\n    // pending matches that are still loading\n\n    const parseErrors = matchedRoutes.map((route) => {\n      let parsedParamsError\n\n      if (route.options.parseParams) {\n        try {\n          const parsedParams = route.options.parseParams(routeParams)\n          // Add the parsed params to the accumulated params bag\n          Object.assign(routeParams, parsedParams)\n        } catch (err: any) {\n          parsedParamsError = new PathParamError(err.message, {\n            cause: err,\n          })\n\n          if (opts?.throwOnError) {\n            throw parsedParamsError\n          }\n\n          return parsedParamsError\n        }\n      }\n\n      return\n    })\n\n    const matches: AnyRouteMatch[] = []\n\n    matchedRoutes.forEach((route, index) => {\n      // Take each matched route and resolve + validate its search params\n      // This has to happen serially because each route's search params\n      // can depend on the parent route's search params\n      // It must also happen before we create the match so that we can\n      // pass the search params to the route's potential key function\n      // which is used to uniquely identify the route match in state\n\n      const parentMatch = matches[index - 1]\n\n      const [preMatchSearch, searchError]: [Record<string, any>, any] = (() => {\n        // Validate the search params and stabilize them\n        const parentSearch = parentMatch?.search ?? locationSearch\n\n        try {\n          const validator =\n            typeof route.options.validateSearch === 'object'\n              ? route.options.validateSearch.parse\n              : route.options.validateSearch\n\n          let search = validator?.(parentSearch) ?? {}\n\n          return [\n            {\n              ...parentSearch,\n              ...search,\n            },\n            undefined,\n          ]\n        } catch (err: any) {\n          const searchError = new SearchParamError(err.message, {\n            cause: err,\n          })\n\n          if (opts?.throwOnError) {\n            throw searchError\n          }\n\n          return [parentSearch, searchError]\n        }\n      })()\n\n      // This is where we need to call route.options.loaderDeps() to get any additional\n      // deps that the route's loader function might need to run. We need to do this\n      // before we create the match so that we can pass the deps to the route's\n      // potential key function which is used to uniquely identify the route match in state\n\n      const loaderDeps =\n        route.options.loaderDeps?.({\n          search: preMatchSearch,\n        }) ?? ''\n\n      const loaderDepsHash = loaderDeps ? JSON.stringify(loaderDeps) : ''\n\n      const interpolatedPath = interpolatePath(route.fullPath, routeParams)\n      const matchId =\n        interpolatePath(route.id, routeParams, true) + loaderDepsHash\n\n      // Waste not, want not. If we already have a match for this route,\n      // reuse it. This is important for layout routes, which might stick\n      // around between navigation actions that only change leaf routes.\n      const existingMatch = getRouteMatch(this.state, matchId)\n\n      const cause = this.state.matches.find((d) => d.id === matchId)\n        ? 'stay'\n        : 'enter'\n\n      // Create a fresh route match\n      const hasLoaders = !!(\n        route.options.loader ||\n        componentTypes.some((d) => (route.options[d] as any)?.preload)\n      )\n\n      const match: AnyRouteMatch = existingMatch\n        ? { ...existingMatch, cause }\n        : {\n            id: matchId,\n            routeId: route.id,\n            params: routeParams,\n            pathname: joinPaths([this.basepath, interpolatedPath]),\n            updatedAt: Date.now(),\n            search: {} as any,\n            searchError: undefined,\n            status: hasLoaders ? 'pending' : 'success',\n            showPending: false,\n            isFetching: false,\n            error: undefined,\n            paramsError: parseErrors[index],\n            loadPromise: Promise.resolve(),\n            routeContext: undefined!,\n            context: undefined!,\n            abortController: new AbortController(),\n            fetchCount: 0,\n            cause,\n            loaderDeps,\n            invalid: false,\n            preload: false,\n          }\n\n      // Regardless of whether we're reusing an existing match or creating\n      // a new one, we need to update the match's search params\n      match.search = replaceEqualDeep(match.search, preMatchSearch)\n      // And also update the searchError if there is one\n      match.searchError = searchError\n\n      matches.push(match)\n    })\n\n    return matches as any\n  }\n\n  cancelMatch = (id: string) => {\n    getRouteMatch(this.state, id)?.abortController?.abort()\n  }\n\n  cancelMatches = () => {\n    this.state.pendingMatches?.forEach((match) => {\n      this.cancelMatch(match.id)\n    })\n  }\n\n  buildLocation: BuildLocationFn<TRouteTree> = (opts) => {\n    const build = (\n      dest: BuildNextOptions & {\n        unmaskOnReload?: boolean\n      } = {},\n      matches?: AnyRouteMatch[],\n    ): ParsedLocation => {\n      const from = this.latestLocation\n      const fromSearch =\n        (this.state.pendingMatches || this.state.matches).at(-1)?.search ||\n        from.search\n      const fromPathname = dest.from ?? from.pathname\n\n      let pathname = this.resolvePathWithBase(fromPathname, `${dest.to ?? ''}`)\n\n      const fromMatches = this.matchRoutes(fromPathname, fromSearch)\n      const stayingMatches = matches?.filter(\n        (d) => fromMatches?.find((e) => e.routeId === d.routeId),\n      )\n\n      const prevParams = { ...last(fromMatches)?.params }\n\n      let nextParams =\n        (dest.params ?? true) === true\n          ? prevParams\n          : functionalUpdate(dest.params!, prevParams)\n\n      if (nextParams) {\n        matches\n          ?.map((d) => this.looseRoutesById[d.routeId]!.options.stringifyParams)\n          .filter(Boolean)\n          .forEach((fn) => {\n            nextParams = { ...nextParams!, ...fn!(nextParams!) }\n          })\n      }\n\n      pathname = interpolatePath(pathname, nextParams ?? {})\n\n      const preSearchFilters =\n        stayingMatches\n          ?.map(\n            (match) =>\n              this.looseRoutesById[match.routeId]!.options.preSearchFilters ??\n              [],\n          )\n          .flat()\n          .filter(Boolean) ?? []\n\n      const postSearchFilters =\n        stayingMatches\n          ?.map(\n            (match) =>\n              this.looseRoutesById[match.routeId]!.options.postSearchFilters ??\n              [],\n          )\n          .flat()\n          .filter(Boolean) ?? []\n\n      // Pre filters first\n      const preFilteredSearch = preSearchFilters?.length\n        ? preSearchFilters?.reduce(\n            (prev, next) => next(prev) as any,\n            fromSearch,\n          )\n        : fromSearch\n\n      // Then the link/navigate function\n      const destSearch =\n        dest.search === true\n          ? preFilteredSearch // Preserve resolvedFrom true\n          : dest.search\n            ? functionalUpdate(dest.search, preFilteredSearch) ?? {} // Updater\n            : preSearchFilters?.length\n              ? preFilteredSearch // Preserve resolvedFrom filters\n              : {}\n\n      // Then post filters\n      const postFilteredSearch = postSearchFilters?.length\n        ? postSearchFilters.reduce((prev, next) => next(prev), destSearch)\n        : destSearch\n\n      const search = replaceEqualDeep(fromSearch, postFilteredSearch)\n\n      const searchStr = this.options.stringifySearch(search)\n\n      const hash =\n        dest.hash === true\n          ? from.hash\n          : dest.hash\n            ? functionalUpdate(dest.hash!, from.hash)\n            : from.hash\n\n      const hashStr = hash ? `#${hash}` : ''\n\n      let nextState =\n        dest.state === true\n          ? from.state\n          : dest.state\n            ? functionalUpdate(dest.state, from.state)\n            : from.state\n\n      nextState = replaceEqualDeep(from.state, nextState)\n\n      return {\n        pathname,\n        search,\n        searchStr,\n        state: nextState as any,\n        hash,\n        href: `${pathname}${searchStr}${hashStr}`,\n        unmaskOnReload: dest.unmaskOnReload,\n      }\n    }\n\n    const buildWithMatches = (\n      dest: BuildNextOptions = {},\n      maskedDest?: BuildNextOptions,\n    ) => {\n      let next = build(dest)\n      let maskedNext = maskedDest ? build(maskedDest) : undefined\n\n      if (!maskedNext) {\n        let params = {}\n\n        let foundMask = this.options.routeMasks?.find((d) => {\n          const match = matchPathname(this.basepath, next.pathname, {\n            to: d.from,\n            caseSensitive: false,\n            fuzzy: false,\n          })\n\n          if (match) {\n            params = match\n            return true\n          }\n\n          return false\n        })\n\n        if (foundMask) {\n          foundMask = {\n            ...foundMask,\n            from: interpolatePath(foundMask.from, params) as any,\n          }\n          maskedDest = foundMask\n          maskedNext = build(maskedDest)\n        }\n      }\n\n      const nextMatches = this.matchRoutes(next.pathname, next.search)\n      const maskedMatches = maskedNext\n        ? this.matchRoutes(maskedNext.pathname, maskedNext.search)\n        : undefined\n      const maskedFinal = maskedNext\n        ? build(maskedDest, maskedMatches)\n        : undefined\n\n      const final = build(dest, nextMatches)\n\n      if (maskedFinal) {\n        final.maskedLocation = maskedFinal\n      }\n\n      return final\n    }\n\n    if (opts.mask) {\n      return buildWithMatches(opts, {\n        ...pick(opts, ['from']),\n        ...opts.mask,\n      })\n    }\n\n    return buildWithMatches(opts)\n  }\n\n  commitLocation = async ({\n    startTransition,\n    ...next\n  }: ParsedLocation & CommitLocationOptions) => {\n    if (this.navigateTimeout) clearTimeout(this.navigateTimeout)\n\n    const isSameUrl = this.latestLocation.href === next.href\n\n    // If the next urls are the same and we're not replacing,\n    // do nothing\n    if (!isSameUrl || !next.replace) {\n      let { maskedLocation, ...nextHistory } = next\n\n      if (maskedLocation) {\n        nextHistory = {\n          ...maskedLocation,\n          state: {\n            ...maskedLocation.state,\n            __tempKey: undefined,\n            __tempLocation: {\n              ...nextHistory,\n              search: nextHistory.searchStr,\n              state: {\n                ...nextHistory.state,\n                __tempKey: undefined!,\n                __tempLocation: undefined!,\n                key: undefined!,\n              },\n            },\n          },\n        }\n\n        if (\n          nextHistory.unmaskOnReload ??\n          this.options.unmaskOnReload ??\n          false\n        ) {\n          nextHistory.state.__tempKey = this.tempLocationKey\n        }\n      }\n\n      const apply = () => {\n        this.history[next.replace ? 'replace' : 'push'](\n          nextHistory.href,\n          nextHistory.state,\n        )\n      }\n\n      if (startTransition ?? true) {\n        this.startReactTransition(apply)\n      } else {\n        apply()\n      }\n    }\n\n    this.resetNextScroll = next.resetScroll ?? true\n\n    return this.latestLoadPromise\n  }\n\n  buildAndCommitLocation = ({\n    replace,\n    resetScroll,\n    startTransition,\n    ...rest\n  }: BuildNextOptions & CommitLocationOptions = {}) => {\n    const location = this.buildLocation(rest as any)\n    return this.commitLocation({\n      ...location,\n      startTransition,\n      replace,\n      resetScroll,\n    })\n  }\n\n  navigate: NavigateFn<TRouteTree> = ({ from, to = '', ...rest }) => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n    const toString = String(to)\n    const fromString = typeof from === 'undefined' ? from : String(from)\n    let isExternal\n\n    try {\n      new URL(`${toString}`)\n      isExternal = true\n    } catch (e) {}\n\n    invariant(\n      !isExternal,\n      'Attempting to navigate to external url with this.navigate!',\n    )\n\n    return this.buildAndCommitLocation({\n      ...rest,\n      from: fromString,\n      to: toString,\n    })\n  }\n\n  loadMatches = async ({\n    checkLatest,\n    matches,\n    preload,\n  }: {\n    checkLatest: () => Promise<void> | undefined\n    matches: AnyRouteMatch[]\n    preload?: boolean\n  }): Promise<RouteMatch[]> => {\n    let latestPromise\n    let firstBadMatchIndex: number | undefined\n\n    const updateMatch = (match: AnyRouteMatch) => {\n      // const isPreload = this.state.cachedMatches.find((d) => d.id === match.id)\n      const isPending = this.state.pendingMatches?.find(\n        (d) => d.id === match.id,\n      )\n\n      const isMatched = this.state.matches.find((d) => d.id === match.id)\n\n      const matchesKey = isPending\n        ? 'pendingMatches'\n        : isMatched\n          ? 'matches'\n          : 'cachedMatches'\n\n      this.__store.setState((s) => ({\n        ...s,\n        [matchesKey]: s[matchesKey]?.map((d) =>\n          d.id === match.id ? match : d,\n        ),\n      }))\n    }\n\n    // Check each match middleware to see if the route can be accessed\n    try {\n      for (let [index, match] of matches.entries()) {\n        const parentMatch = matches[index - 1]\n        const route = this.looseRoutesById[match.routeId]!\n        const abortController = new AbortController()\n\n        const handleErrorAndRedirect = (err: any, code: string) => {\n          err.routerCode = code\n          firstBadMatchIndex = firstBadMatchIndex ?? index\n\n          if (isRedirect(err)) {\n            throw err\n          }\n\n          try {\n            route.options.onError?.(err)\n          } catch (errorHandlerErr) {\n            err = errorHandlerErr\n\n            if (isRedirect(errorHandlerErr)) {\n              throw errorHandlerErr\n            }\n          }\n\n          matches[index] = match = {\n            ...match,\n            error: err,\n            status: 'error',\n            updatedAt: Date.now(),\n            abortController: new AbortController(),\n          }\n        }\n\n        try {\n          if (match.paramsError) {\n            handleErrorAndRedirect(match.paramsError, 'PARSE_PARAMS')\n          }\n\n          if (match.searchError) {\n            handleErrorAndRedirect(match.searchError, 'VALIDATE_SEARCH')\n          }\n\n          const parentContext =\n            parentMatch?.context ?? this.options.context ?? {}\n\n          const beforeLoadContext =\n            (await route.options.beforeLoad?.({\n              search: match.search,\n              abortController,\n              params: match.params,\n              preload: !!preload,\n              context: parentContext,\n              location: this.state.location,\n              // TOOD: just expose state and router, etc\n              navigate: (opts) =>\n                this.navigate({ ...opts, from: match.pathname } as any),\n              buildLocation: this.buildLocation,\n              cause: preload ? 'preload' : match.cause,\n            })) ?? ({} as any)\n\n          if (isRedirect(beforeLoadContext)) {\n            throw beforeLoadContext\n          }\n\n          const context = {\n            ...parentContext,\n            ...beforeLoadContext,\n          }\n\n          matches[index] = match = {\n            ...match,\n            routeContext: replaceEqualDeep(\n              match.routeContext,\n              beforeLoadContext,\n            ),\n            context: replaceEqualDeep(match.context, context),\n            abortController,\n          }\n        } catch (err) {\n          handleErrorAndRedirect(err, 'BEFORE_LOAD')\n          break\n        }\n      }\n    } catch (err) {\n      if (isRedirect(err)) {\n        if (!preload) this.navigate(err as any)\n        return matches\n      }\n\n      throw err\n    }\n\n    const validResolvedMatches = matches.slice(0, firstBadMatchIndex)\n    const matchPromises: Promise<any>[] = []\n\n    validResolvedMatches.forEach((match, index) => {\n      matchPromises.push(\n        new Promise<void>(async (resolve) => {\n          const parentMatchPromise = matchPromises[index - 1]\n          const route = this.looseRoutesById[match.routeId]!\n\n          const handleErrorAndRedirect = (err: any) => {\n            if (isRedirect(err)) {\n              if (!preload) {\n                this.navigate(err as any)\n              }\n              return true\n            }\n            return false\n          }\n\n          let loadPromise: Promise<void> | undefined\n\n          matches[index] = match = {\n            ...match,\n            showPending: false,\n          }\n\n          let didShowPending = false\n          const pendingMs =\n            route.options.pendingMs ?? this.options.defaultPendingMs\n          const pendingMinMs =\n            route.options.pendingMinMs ?? this.options.defaultPendingMinMs\n          const shouldPending =\n            !preload &&\n            pendingMs &&\n            (route.options.pendingComponent ??\n              this.options.defaultPendingComponent)\n\n          const loaderContext: LoaderFnContext = {\n            params: match.params,\n            deps: match.loaderDeps,\n            preload: !!preload,\n            parentMatchPromise,\n            abortController: match.abortController,\n            context: match.context,\n            location: this.state.location,\n            navigate: (opts) =>\n              this.navigate({ ...opts, from: match.pathname } as any),\n            cause: preload ? 'preload' : match.cause,\n          }\n\n          const fetch = async () => {\n            if (match.isFetching) {\n              loadPromise = getRouteMatch(this.state, match.id)?.loadPromise\n            } else {\n              // If the user doesn't want the route to reload, just\n              // resolve with the existing loader data\n\n              if (match.fetchCount && match.status === 'success') {\n                resolve()\n              }\n\n              // Otherwise, load the route\n              matches[index] = match = {\n                ...match,\n                isFetching: true,\n                fetchCount: match.fetchCount + 1,\n              }\n\n              const componentsPromise = Promise.all(\n                componentTypes.map(async (type) => {\n                  const component = route.options[type]\n\n                  if ((component as any)?.preload) {\n                    await (component as any).preload()\n                  }\n                }),\n              )\n\n              const loaderPromise = route.options.loader?.(loaderContext)\n\n              loadPromise = Promise.all([\n                componentsPromise,\n                loaderPromise,\n              ]).then((d) => d[1])\n            }\n\n            matches[index] = match = {\n              ...match,\n              loadPromise,\n            }\n\n            updateMatch(match)\n\n            try {\n              const loaderData = await loadPromise\n              if ((latestPromise = checkLatest())) return await latestPromise\n\n              if (isRedirect(loaderData)) {\n                if (handleErrorAndRedirect(loaderData)) return\n              }\n\n              if (didShowPending && pendingMinMs) {\n                await new Promise((r) => setTimeout(r, pendingMinMs))\n              }\n\n              if ((latestPromise = checkLatest())) return await latestPromise\n\n              matches[index] = match = {\n                ...match,\n                error: undefined,\n                status: 'success',\n                isFetching: false,\n                updatedAt: Date.now(),\n                loaderData,\n                loadPromise: undefined,\n              }\n            } catch (error) {\n              if ((latestPromise = checkLatest())) return await latestPromise\n              if (handleErrorAndRedirect(error)) return\n\n              try {\n                route.options.onError?.(error)\n              } catch (onErrorError) {\n                error = onErrorError\n                if (handleErrorAndRedirect(onErrorError)) return\n              }\n\n              matches[index] = match = {\n                ...match,\n                error,\n                status: 'error',\n                isFetching: false,\n              }\n            }\n\n            updateMatch(match)\n          }\n\n          // This is where all of the stale-while-revalidate magic happens\n          const age = Date.now() - match.updatedAt\n\n          let staleAge = preload\n            ? route.options.preloadStaleTime ??\n              this.options.defaultPreloadStaleTime ??\n              30_000 // 30 seconds for preloads by default\n            : route.options.staleTime ?? this.options.defaultStaleTime ?? 0\n\n          // Default to reloading the route all the time\n          let shouldReload\n\n          const shouldReloadOption = route.options.shouldReload\n\n          // Allow shouldReload to get the last say,\n          // if provided.\n          shouldReload =\n            typeof shouldReloadOption === 'function'\n              ? shouldReloadOption(loaderContext)\n              : shouldReloadOption\n\n          matches[index] = match = {\n            ...match,\n            preload:\n              !!preload && !this.state.matches.find((d) => d.id === match.id),\n          }\n\n          if (match.status !== 'success') {\n            // If we need to potentially show the pending component,\n            // start a timer to show it after the pendingMs\n            if (shouldPending) {\n              new Promise((r) => setTimeout(r, pendingMs)).then(async () => {\n                if ((latestPromise = checkLatest())) return latestPromise\n\n                didShowPending = true\n                matches[index] = match = {\n                  ...match,\n                  showPending: true,\n                }\n\n                updateMatch(match)\n                resolve()\n              })\n            }\n\n            // Critical Fetching, we need to await\n            await fetch()\n          } else if (match.invalid || (shouldReload ?? age > staleAge)) {\n            // Background Fetching, no need to wait\n            fetch()\n          }\n\n          resolve()\n        }),\n      )\n    })\n\n    await Promise.all(matchPromises)\n    return matches\n  }\n\n  invalidate = () => {\n    const invalidate = (d: any) => ({\n      ...d,\n      invalid: true,\n    })\n\n    this.__store.setState((s) => ({\n      ...s,\n      matches: s.matches.map(invalidate),\n      cachedMatches: s.cachedMatches.map(invalidate),\n      pendingMatches: s.pendingMatches?.map(invalidate),\n    }))\n\n    this.load()\n  }\n\n  load = async (): Promise<void> => {\n    const promise = new Promise<void>(async (resolve, reject) => {\n      const next = this.latestLocation\n      const prevLocation = this.state.resolvedLocation\n      const pathDidChange = prevLocation!.href !== next.href\n      let latestPromise: Promise<void> | undefined | null\n\n      // Cancel any pending matches\n      this.cancelMatches()\n\n      this.emit({\n        type: 'onBeforeLoad',\n        fromLocation: prevLocation,\n        toLocation: next,\n        pathChanged: pathDidChange,\n      })\n\n      let pendingMatches!: RouteMatch<any, any>[]\n      const previousMatches = this.state.matches\n\n      this.__store.batch(() => {\n        this.cleanCache()\n\n        // Match the routes\n        pendingMatches = this.matchRoutes(next.pathname, next.search, {\n          debug: true,\n        })\n\n        // Ingest the new matches\n        // If a cached moved to pendingMatches, remove it from cachedMatches\n        this.__store.setState((s) => ({\n          ...s,\n          isLoading: true,\n          location: next,\n          pendingMatches,\n          cachedMatches: s.cachedMatches.filter((d) => {\n            return !pendingMatches.find((e) => e.id === d.id)\n          }),\n        }))\n      })\n\n      try {\n        try {\n          // Load the matches\n          await this.loadMatches({\n            matches: pendingMatches,\n            checkLatest: () => this.checkLatest(promise),\n          })\n        } catch (err) {\n          // swallow this error, since we'll display the\n          // errors on the route components\n        }\n\n        // Only apply the latest transition\n        if ((latestPromise = this.checkLatest(promise))) {\n          return latestPromise\n        }\n\n        const exitingMatches = previousMatches.filter(\n          (match) => !pendingMatches.find((d) => d.id === match.id),\n        )\n        const enteringMatches = pendingMatches.filter(\n          (match) => !previousMatches.find((d) => d.id === match.id),\n        )\n        const stayingMatches = previousMatches.filter((match) =>\n          pendingMatches.find((d) => d.id === match.id),\n        )\n\n        // Commit the pending matches. If a previous match was\n        // removed, place it in the cachedMatches\n        this.__store.batch(() => {\n          this.__store.setState((s) => ({\n            ...s,\n            isLoading: false,\n            matches: s.pendingMatches!,\n            pendingMatches: undefined,\n            cachedMatches: [\n              ...s.cachedMatches,\n              ...exitingMatches.filter((d) => d.status !== 'error'),\n            ],\n          }))\n          this.cleanCache()\n        })\n\n        //\n        ;(\n          [\n            [exitingMatches, 'onLeave'],\n            [enteringMatches, 'onEnter'],\n            [stayingMatches, 'onStay'],\n          ] as const\n        ).forEach(([matches, hook]) => {\n          matches.forEach((match) => {\n            this.looseRoutesById[match.routeId]!.options[hook]?.(match)\n          })\n        })\n\n        this.emit({\n          type: 'onLoad',\n          fromLocation: prevLocation,\n          toLocation: next,\n          pathChanged: pathDidChange,\n        })\n\n        resolve()\n      } catch (err) {\n        // Only apply the latest transition\n        if ((latestPromise = this.checkLatest(promise))) {\n          return latestPromise\n        }\n\n        reject(err)\n      }\n    })\n\n    this.latestLoadPromise = promise\n\n    return this.latestLoadPromise\n  }\n\n  cleanCache = () => {\n    // This is where all of the garbage collection magic happens\n    this.__store.setState((s) => {\n      return {\n        ...s,\n        cachedMatches: s.cachedMatches.filter((d) => {\n          const route = this.looseRoutesById[d.routeId]!\n\n          if (!route.options.loader) {\n            return false\n          }\n\n          // If the route was preloaded, use the preloadGcTime\n          // otherwise, use the gcTime\n          const gcTime =\n            (d.preload\n              ? route.options.preloadGcTime ?? this.options.defaultPreloadGcTime\n              : route.options.gcTime ?? this.options.defaultGcTime) ??\n            5 * 60 * 1000\n\n          return d.status !== 'error' && Date.now() - d.updatedAt < gcTime\n        }),\n      }\n    })\n  }\n\n  preloadRoute = async (\n    navigateOpts: ToOptions<TRouteTree> = this.state.location as any,\n  ) => {\n    let next = this.buildLocation(navigateOpts as any)\n\n    let matches = this.matchRoutes(next.pathname, next.search, {\n      throwOnError: true,\n    })\n\n    const loadedMatchIds = Object.fromEntries(\n      [\n        ...this.state.matches,\n        ...(this.state.pendingMatches ?? []),\n        ...this.state.cachedMatches,\n      ]?.map((d) => [d.id, true]),\n    )\n\n    this.__store.batch(() => {\n      matches.forEach((match) => {\n        if (!loadedMatchIds[match.id]) {\n          this.__store.setState((s) => ({\n            ...s,\n            cachedMatches: [...(s.cachedMatches as any), match],\n          }))\n        }\n      })\n    })\n\n    matches = await this.loadMatches({\n      matches,\n      preload: true,\n      checkLatest: () => undefined,\n    })\n\n    return matches\n  }\n\n  matchRoute: MatchRouteFn<TRouteTree> = (location, opts) => {\n    location = {\n      ...location,\n      to: location.to\n        ? this.resolvePathWithBase((location.from || '') as string, location.to)\n        : undefined,\n    } as any\n\n    const next = this.buildLocation(location as any)\n\n    if (opts?.pending && this.state.status !== 'pending') {\n      return false\n    }\n\n    const baseLocation = opts?.pending\n      ? this.latestLocation\n      : this.state.resolvedLocation\n\n    if (!baseLocation) {\n      return false\n    }\n\n    const match = matchPathname(this.basepath, baseLocation.pathname, {\n      ...opts,\n      to: next.pathname,\n    }) as any\n\n    if (!match) {\n      return false\n    }\n\n    if (match && (opts?.includeSearch ?? true)) {\n      return deepEqual(baseLocation.search, next.search, true) ? match : false\n    }\n\n    return match\n  }\n\n  injectHtml = async (html: string | (() => Promise<string> | string)) => {\n    this.injectedHtml.push(html)\n  }\n\n  dehydrateData = <T>(key: any, getData: T | (() => Promise<T> | T)) => {\n    if (typeof document === 'undefined') {\n      const strKey = typeof key === 'string' ? key : JSON.stringify(key)\n\n      this.injectHtml(async () => {\n        const id = `__TSR_DEHYDRATED__${strKey}`\n        const data =\n          typeof getData === 'function' ? await (getData as any)() : getData\n        return `<script id='${id}' suppressHydrationWarning>window[\"__TSR_DEHYDRATED__${escapeJSON(\n          strKey,\n        )}\"] = ${JSON.stringify(data)}\n          ;(() => {\n            var el = document.getElementById('${id}')\n            el.parentElement.removeChild(el)\n          })()\n          </script>`\n      })\n\n      return () => this.hydrateData<T>(key)\n    }\n\n    return () => undefined\n  }\n\n  hydrateData = <T extends any = unknown>(key: any) => {\n    if (typeof document !== 'undefined') {\n      const strKey = typeof key === 'string' ? key : JSON.stringify(key)\n\n      return window[`__TSR_DEHYDRATED__${strKey}` as any] as T\n    }\n\n    return undefined\n  }\n\n  dehydrate = (): DehydratedRouter => {\n    return {\n      state: {\n        dehydratedMatches: this.state.matches.map((d) =>\n          pick(d, ['id', 'status', 'updatedAt', 'loaderData']),\n        ),\n      },\n    }\n  }\n\n  hydrate = async (__do_not_use_server_ctx?: HydrationCtx) => {\n    let _ctx = __do_not_use_server_ctx\n    // Client hydrates from window\n    if (typeof document !== 'undefined') {\n      _ctx = window.__TSR_DEHYDRATED__\n    }\n\n    invariant(\n      _ctx,\n      'Expected to find a __TSR_DEHYDRATED__ property on window... but we did not. Did you forget to render <DehydrateRouter /> in your app?',\n    )\n\n    const ctx = _ctx\n    this.dehydratedData = ctx.payload as any\n    this.options.hydrate?.(ctx.payload as any)\n    const dehydratedState = ctx.router.state\n\n    let matches = this.matchRoutes(\n      this.state.location.pathname,\n      this.state.location.search,\n    ).map((match) => {\n      const dehydratedMatch = dehydratedState.dehydratedMatches.find(\n        (d) => d.id === match.id,\n      )\n\n      invariant(\n        dehydratedMatch,\n        `Could not find a client-side match for dehydrated match with id: ${match.id}!`,\n      )\n\n      if (dehydratedMatch) {\n        return {\n          ...match,\n          ...dehydratedMatch,\n        }\n      }\n      return match\n    })\n\n    this.__store.setState((s) => {\n      return {\n        ...s,\n        matches: matches as any,\n      }\n    })\n  }\n\n  // resolveMatchPromise = (matchId: string, key: string, value: any) => {\n  //   state.matches\n  //     .find((d) => d.id === matchId)\n  //     ?.__promisesByKey[key]?.resolve(value)\n  // }\n}\n\n// A function that takes an import() argument which is a function and returns a new function that will\n// proxy arguments from the caller to the imported function, retaining all type\n// information along the way\nexport function lazyFn<\n  T extends Record<string, (...args: any[]) => any>,\n  TKey extends keyof T = 'default',\n>(fn: () => Promise<T>, key?: TKey) {\n  return async (...args: Parameters<T[TKey]>): Promise<ReturnType<T[TKey]>> => {\n    const imported = await fn()\n    return imported[key || 'default'](...args)\n  }\n}\n\nexport class SearchParamError extends Error {}\n\nexport class PathParamError extends Error {}\n\nexport function getInitialRouterState(\n  location: ParsedLocation,\n): RouterState<any> {\n  return {\n    isLoading: false,\n    isTransitioning: false,\n    status: 'idle',\n    resolvedLocation: { ...location },\n    location,\n    matches: [],\n    pendingMatches: [],\n    cachedMatches: [],\n    lastUpdated: Date.now(),\n  }\n}\n","import * as React from 'react'\n\nconst useLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\nimport { ParsedLocation } from './location'\nimport { useRouter } from './RouterProvider'\nimport { NonNullableUpdater, functionalUpdate } from './utils'\n\nconst windowKey = 'window'\nconst delimiter = '___'\n\nlet weakScrolledElements = new WeakSet<any>()\n\ntype CacheValue = Record<string, { scrollX: number; scrollY: number }>\ntype CacheState = {\n  cached: CacheValue\n  next: CacheValue\n}\n\ntype Cache = {\n  state: CacheState\n  set: (updater: NonNullableUpdater<CacheState>) => void\n}\n\nconst sessionsStorage = typeof window !== 'undefined' && window.sessionStorage\n\nlet cache: Cache = sessionsStorage\n  ? (() => {\n      const storageKey = 'tsr-scroll-restoration-v2'\n\n      const state: CacheState = JSON.parse(\n        window.sessionStorage.getItem(storageKey) || 'null',\n      ) || { cached: {}, next: {} }\n\n      return {\n        state,\n        set: (updater) => {\n          cache.state = functionalUpdate(updater, cache.state)\n          window.sessionStorage.setItem(storageKey, JSON.stringify(cache.state))\n        },\n      }\n    })()\n  : (undefined as any)\n\nexport type ScrollRestorationOptions = {\n  getKey?: (location: ParsedLocation) => string\n}\n\nconst defaultGetKey = (location: ParsedLocation) => location.state.key!\n\nexport function useScrollRestoration(options?: ScrollRestorationOptions) {\n  const router = useRouter()\n\n  useLayoutEffect(() => {\n    const getKey = options?.getKey || defaultGetKey\n\n    const { history } = window\n    if (history.scrollRestoration) {\n      history.scrollRestoration = 'manual'\n    }\n\n    const onScroll = (event: Event) => {\n      if (weakScrolledElements.has(event.target)) return\n      weakScrolledElements.add(event.target)\n\n      let elementSelector = ''\n\n      if (event.target === document || event.target === window) {\n        elementSelector = windowKey\n      } else {\n        const attrId = (event.target as Element).getAttribute(\n          'data-scroll-restoration-id',\n        )\n\n        if (attrId) {\n          elementSelector = `[data-scroll-restoration-id=\"${attrId}\"]`\n        } else {\n          elementSelector = getCssSelector(event.target)\n        }\n      }\n\n      if (!cache.state.next[elementSelector]) {\n        cache.set((c) => ({\n          ...c,\n          next: {\n            ...c.next,\n            [elementSelector]: {\n              scrollX: NaN,\n              scrollY: NaN,\n            },\n          },\n        }))\n      }\n    }\n\n    if (typeof document !== 'undefined') {\n      document.addEventListener('scroll', onScroll, true)\n    }\n\n    const unsubOnBeforeLoad = router.subscribe('onBeforeLoad', (event) => {\n      if (event.pathChanged) {\n        const restoreKey = getKey(event.fromLocation)\n        for (const elementSelector in cache.state.next) {\n          const entry = cache.state.next[elementSelector]!\n          if (elementSelector === windowKey) {\n            entry.scrollX = window.scrollX || 0\n            entry.scrollY = window.scrollY || 0\n          } else if (elementSelector) {\n            const element = document.querySelector(elementSelector)\n            entry.scrollX = element?.scrollLeft || 0\n            entry.scrollY = element?.scrollTop || 0\n          }\n\n          cache.set((c) => {\n            const next = { ...c.next }\n            delete next[elementSelector]\n\n            return {\n              ...c,\n              next,\n              cached: {\n                ...c.cached,\n                [[restoreKey, elementSelector].join(delimiter)]: entry,\n              },\n            }\n          })\n        }\n      }\n    })\n\n    const unsubOnResolved = router.subscribe('onResolved', (event) => {\n      if (event.pathChanged) {\n        if (!router.resetNextScroll) {\n          return\n        }\n\n        router.resetNextScroll = true\n\n        const getKey = options?.getKey || defaultGetKey\n\n        const restoreKey = getKey(event.toLocation)\n        let windowRestored = false\n\n        for (const cacheKey in cache.state.cached) {\n          const entry = cache.state.cached[cacheKey]!\n          const [key, elementSelector] = cacheKey.split(delimiter)\n          if (key === restoreKey) {\n            if (elementSelector === windowKey) {\n              windowRestored = true\n              window.scrollTo(entry.scrollX, entry.scrollY)\n            } else if (elementSelector) {\n              const element = document.querySelector(elementSelector)\n              if (element) {\n                element.scrollLeft = entry.scrollX\n                element.scrollTop = entry.scrollY\n              }\n            }\n          }\n        }\n\n        if (!windowRestored) {\n          window.scrollTo(0, 0)\n        }\n\n        cache.set((c) => ({ ...c, next: {} }))\n        weakScrolledElements = new WeakSet<any>()\n      }\n    })\n\n    return () => {\n      document.removeEventListener('scroll', onScroll)\n      unsubOnBeforeLoad()\n      unsubOnResolved()\n    }\n  }, [])\n}\n\nexport function ScrollRestoration(props: ScrollRestorationOptions) {\n  useScrollRestoration(props)\n  return null\n}\n\nexport function useElementScrollRestoration(\n  options: (\n    | {\n        id: string\n        getElement?: () => Element | undefined | null\n      }\n    | {\n        id?: string\n        getElement: () => Element | undefined | null\n      }\n  ) & {\n    getKey?: (location: ParsedLocation) => string\n  },\n) {\n  const router = useRouter()\n  const getKey = options?.getKey || defaultGetKey\n\n  let elementSelector = ''\n\n  if (options.id) {\n    elementSelector = `[data-scroll-restoration-id=\"${options.id}\"]`\n  } else {\n    const element = options.getElement?.()\n    if (!element) {\n      return\n    }\n    elementSelector = getCssSelector(element)\n  }\n\n  const restoreKey = getKey(router.latestLocation)\n  const cacheKey = [restoreKey, elementSelector].join(delimiter)\n  return cache.state.cached[cacheKey]\n}\n\nfunction getCssSelector(el: any): string {\n  let path = [],\n    parent\n  while ((parent = el.parentNode)) {\n    path.unshift(\n      `${el.tagName}:nth-child(${\n        ([].indexOf as any).call(parent.children, el) + 1\n      })`,\n    )\n    el = parent\n  }\n  return `${path.join(' > ')}`.toLowerCase()\n}\n","import * as React from 'react'\nimport { ReactNode } from './route'\nimport { useRouter } from './RouterProvider'\nimport { BlockerFn } from '@tanstack/history'\n\nexport function useBlocker(\n  blockerFn: BlockerFn,\n  condition: boolean | any = true,\n): void {\n  const { history } = useRouter()\n\n  React.useEffect(() => {\n    if (!condition) return\n    return history.block(blockerFn)\n  })\n}\n\nexport function Block({ blocker, condition, children }: PromptProps) {\n  useBlocker(blocker, condition)\n  return (children ?? null) as ReactNode\n}\n\nexport type PromptProps = {\n  blocker: BlockerFn\n  condition?: boolean | any\n  children?: ReactNode\n}\n","import { ParsePathParams } from './link'\nimport {\n  AnyRoute,\n  ResolveFullPath,\n  ResolveFullSearchSchema,\n  MergeFromFromParent,\n  RouteContext,\n  AnyContext,\n  RouteOptions,\n  UpdatableRouteOptions,\n  Route,\n  AnyPathParams,\n  RootRouteId,\n  TrimPathLeft,\n  RouteConstraints,\n} from './route'\nimport { Assign, Expand, IsAny } from './utils'\n\nexport interface FileRoutesByPath {\n  // '/': {\n  //   parentRoute: typeof rootRoute\n  // }\n}\n\ntype Replace<\n  S extends string,\n  From extends string,\n  To extends string,\n> = S extends `${infer Start}${From}${infer Rest}`\n  ? `${Start}${To}${Replace<Rest, From, To>}`\n  : S\n\nexport type TrimLeft<\n  T extends string,\n  S extends string,\n> = T extends `${S}${infer U}` ? U : T\n\nexport type TrimRight<\n  T extends string,\n  S extends string,\n> = T extends `${infer U}${S}` ? U : T\n\nexport type Trim<T extends string, S extends string> = TrimLeft<\n  TrimRight<T, S>,\n  S\n>\n\nexport type RemoveUnderScores<T extends string> = Replace<\n  Replace<TrimRight<TrimLeft<T, '/_'>, '_'>, '_/', '/'>,\n  '/_',\n  '/'\n>\n\nexport type ResolveFilePath<\n  TParentRoute extends AnyRoute,\n  TFilePath extends string,\n> = TParentRoute['id'] extends RootRouteId\n  ? TrimPathLeft<TFilePath>\n  : Replace<\n      TrimPathLeft<TFilePath>,\n      TrimPathLeft<TParentRoute['types']['customId']>,\n      ''\n    >\n\nexport type FileRoutePath<\n  TParentRoute extends AnyRoute,\n  TFilePath extends string,\n> = ResolveFilePath<TParentRoute, TFilePath> extends `_${infer _}`\n  ? string\n  : ResolveFilePath<TParentRoute, TFilePath>\n\nexport class FileRoute<\n  TFilePath extends keyof FileRoutesByPath,\n  TParentRoute extends AnyRoute = FileRoutesByPath[TFilePath]['parentRoute'],\n  TId extends RouteConstraints['TId'] = TFilePath,\n  TPath extends RouteConstraints['TPath'] = FileRoutePath<\n    TParentRoute,\n    TFilePath\n  >,\n  TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\n    TParentRoute,\n    RemoveUnderScores<TPath>\n  >,\n> {\n  constructor(public path: TFilePath) {}\n\n  createRoute = <\n    TSearchSchema extends RouteConstraints['TSearchSchema'] = {},\n    TFullSearchSchema extends\n      RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchema<\n      TParentRoute,\n      TSearchSchema\n    >,\n    TParams extends RouteConstraints['TParams'] = Expand<\n      Record<ParsePathParams<TPath>, string>\n    >,\n    TAllParams extends RouteConstraints['TAllParams'] = MergeFromFromParent<\n      TParentRoute['types']['allParams'],\n      TParams\n    >,\n    TRouteContext extends RouteConstraints['TRouteContext'] = RouteContext,\n    TContext extends Expand<\n      Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n    > = Expand<\n      Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n    >,\n    TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n    TLoaderDeps extends Record<string, any> = {},\n    TLoaderData extends any = unknown,\n    TChildren extends RouteConstraints['TChildren'] = unknown,\n    TRouteTree extends RouteConstraints['TRouteTree'] = AnyRoute,\n  >(\n    options?: Omit<\n      RouteOptions<\n        TParentRoute,\n        string,\n        TPath,\n        TSearchSchema,\n        TFullSearchSchema,\n        TParams,\n        TAllParams,\n        TRouteContext,\n        TContext,\n        TLoaderDeps,\n        TLoaderData\n      >,\n      'getParentRoute' | 'path' | 'id'\n    > &\n      UpdatableRouteOptions<TFullSearchSchema>,\n  ): Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TFilePath,\n    TId,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContext,\n    TContext,\n    TRouterContext,\n    TLoaderDeps,\n    TLoaderData,\n    TChildren,\n    TRouteTree\n  > => {\n    const route = new Route(options as any)\n    ;(route as any).isRoot = false\n    return route as any\n  }\n}\n","import * as React from 'react'\nimport { useMatch } from './Matches'\nimport { useRouter } from './RouterProvider'\nimport { LinkOptions, NavigateOptions } from './link'\nimport { AnyRoute } from './route'\nimport { RoutePaths } from './routeInfo'\nimport { RegisteredRouter } from './router'\nimport { useLayoutEffect } from './utils'\n\nexport function useNavigate<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TDefaultFrom extends RoutePaths<TRouteTree> = '/',\n>(defaultOpts?: { from?: TDefaultFrom }) {\n  const { navigate } = useRouter()\n  const matchPathname = useMatch({\n    strict: false,\n    select: (s) => s.pathname,\n  })\n  return React.useCallback(\n    <\n      TFrom extends RoutePaths<TRouteTree> = TDefaultFrom,\n      TTo extends string = '',\n      TMaskFrom extends RoutePaths<TRouteTree> = '/',\n      TMaskTo extends string = '',\n    >(\n      opts?: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n    ) => {\n      return navigate({\n        from: opts?.to ? matchPathname : undefined,\n        ...defaultOpts,\n        ...(opts as any),\n      })\n    },\n    [],\n  )\n}\n\n// NOTE: I don't know of anyone using this. It's undocumented, so let's wait until someone needs it\n// export function typedNavigate<\n//   TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n//   TDefaultFrom extends RoutePaths<TRouteTree> = '/',\n// >(navigate: (opts: NavigateOptions<any>) => Promise<void>) {\n//   return navigate as <\n//     TFrom extends RoutePaths<TRouteTree> = TDefaultFrom,\n//     TTo extends string = '',\n//     TMaskFrom extends RoutePaths<TRouteTree> = '/',\n//     TMaskTo extends string = '',\n//   >(\n//     opts?: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n//   ) => Promise<void>\n// } //\n\nexport function Navigate<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n>(props: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>): null {\n  const { navigate } = useRouter()\n  const match = useMatch({ strict: false })\n\n  React.useEffect(() => {\n    navigate({\n      from: props.to ? match.pathname : undefined,\n      ...props,\n    } as any)\n  }, [])\n\n  return null\n}\n\nexport type UseLinkPropsOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ActiveLinkOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> &\n  React.AnchorHTMLAttributes<HTMLAnchorElement>\n\nexport type LinkProps<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ActiveLinkOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> &\n  Omit<React.AnchorHTMLAttributes<HTMLAnchorElement>, 'children'> & {\n    // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n    children?:\n      | React.ReactNode\n      | ((state: { isActive: boolean }) => React.ReactNode)\n  }\n\nexport type ActiveLinkOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = LinkOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // A function that returns additional props for the `active` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n  activeProps?:\n    | React.AnchorHTMLAttributes<HTMLAnchorElement>\n    | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>)\n  // A function that returns additional props for the `inactive` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n  inactiveProps?:\n    | React.AnchorHTMLAttributes<HTMLAnchorElement>\n    | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>)\n}\n","import * as React from 'react'\nimport { AsyncRouteComponent } from './route'\n\nexport function lazyRouteComponent<\n  T extends Record<string, any>,\n  TKey extends keyof T = 'default',\n>(\n  importer: () => Promise<T>,\n  exportName?: TKey,\n): T[TKey] extends (props: infer TProps) => any\n  ? AsyncRouteComponent<TProps>\n  : never {\n  let loadPromise: Promise<any>\n\n  const load = () => {\n    if (!loadPromise) {\n      loadPromise = importer()\n    }\n\n    return loadPromise\n  }\n\n  const lazyComp = React.lazy(async () => {\n    const moduleExports = await load()\n    const comp = moduleExports[exportName ?? 'default']\n    return {\n      default: comp,\n    }\n  })\n  ;(lazyComp as any).preload = load\n\n  return lazyComp as any\n}\n","var isProduction = process.env.NODE_ENV === 'production';\nfunction warning(condition, message) {\n  if (!isProduction) {\n    if (condition) {\n      return;\n    }\n\n    var text = \"Warning: \" + message;\n\n    if (typeof console !== 'undefined') {\n      console.warn(text);\n    }\n\n    try {\n      throw Error(text);\n    } catch (x) {}\n  }\n}\n\nexport default warning;\n"],"names":["pushStateEvent","popStateEvent","beforeUnloadEvent","beforeUnloadListener","event","preventDefault","returnValue","stopBlocking","removeEventListener","capture","createHistory","opts","location","getLocation","subscribers","Set","blockers","onUpdate","forEach","subscriber","tryNavigation","async","document","length","blocker","onBlocked","task","subscribe","cb","add","delete","push","path","state","assignKey","pushState","replace","replaceState","go","index","back","forward","createHref","str","block","addEventListener","filter","b","flush","destroy","notify","key","createRandomKey","createBrowserHistory","win","window","undefined","parseLocation","parseHref","pathname","search","hash","history","rollbackLocation","currentLocation","next","scheduled","tracking","isPush","href","fn","queueHistoryAction","type","destHref","Promise","resolve","then","onPushPop","originalPushState","originalReplaceState","n","res","apply","arguments","createMemoryHistory","initialEntries","entries","initialIndex","currentState","Math","min","max","hashIndex","indexOf","searchIndex","substring","slice","random","toString","prefix","invariant","condition","message","Error","withSelectorModule","exports","h","require$$0","require$$1","q","Object","is","a","r","useSyncExternalStore","t","useRef","u","useEffect","v","useMemo","w","useDebugValue","withSelector_production_min","useSyncExternalStoreWithSelector","e","l","g","c","current","f","hasValue","value","d","k","m","Store","constructor","initialState","options","this","listeners","_batching","_flushing","_nextPriority","listener","unsub","onSubscribe","setState","updater","previous","updateFn","priority","defaultPriority","_flush","flushId","batch","shallow","objA","objB","keysA","keys","i","prototype","hasOwnProperty","call","CatchBoundary","props","errorComponent","ErrorComponent","React","createElement","CatchBoundaryImpl","getResetKey","onCatch","children","error","Component","getDerivedStateFromProps","resetKey","getDerivedStateFromError","componentDidUpdate","prevProps","prevState","componentDidCatch","console","render","show","setShow","useState","process","style","padding","maxWidth","display","alignItems","gap","fontSize","appearance","border","fontWeight","borderRadius","onClick","height","color","overflow","isServer","last","arr","functionalUpdate","pick","parent","reduce","obj","replaceEqualDeep","prev","_next","array","Array","isArray","isPlainObject","prevSize","nextItems","nextSize","copy","equalItems","o","hasObjectPrototype","ctor","prot","deepEqual","partial","aKeys","bKeys","some","item","useLayoutEffect","escapeJSON","jsonString","matchContext","createContext","Matches","router","useRouter","matchId","useRouterState","select","s","getRenderedMatches","id","Provider","resolvedLocation","Match","SafeFragment","Fragment","routeId","find","route","routesById","PendingComponent","pendingComponent","defaultPendingComponent","pendingElement","routeErrorComponent","defaultErrorComponent","ResolvedSuspenseBoundary","wrapInSuspense","component","preload","Suspense","ResolvedCatchBoundary","fallback","MatchInner","match","status","showPending","loadPromise","Comp","defaultComponent","Outlet","memo","useContext","childMatchId","matches","findIndex","useMatchRoute","matchRoute","useCallback","pending","caseSensitive","rest","pendingMatches","useMatch","nearestMatchId","nearestMatchRouteId","matchRouteId","from","strict","useMatches","useLoaderDeps","loaderDeps","useLoaderData","loaderData","Transitioner","routerState","isTransitioning","startReactTransition","useTransition","__store","tryLoad","load","err","latestLocation","nextLocation","buildLocation","params","commitLocation","isLoading","emit","fromLocation","toLocation","pathChanged","querySelector","el","getElementById","scrollIntoView","__TSR_DEHYDRATED__","getRouteMatch","cachedMatches","store","selector","useStore","resolvedContext","__TSR_ROUTER_CONTEXT__","routerContext","isDehydratedDeferred","useAwaited","promise","__deferredState","uid","hydrateData","data","setTimeout","dehydrateData","joinPaths","paths","cleanPath","Boolean","join","trimPathLeft","trimPathRight","trimPath","resolvePath","basepath","base","to","RegExp","baseSegments","parsePathname","toSegments","toSegment","pop","map","segments","split","part","charAt","interpolatePath","leaveWildcards","segment","matchPathname","currentPathname","matchLocation","pathParams","matchByPath","removeBasepath","routeSegments","startsWith","unshift","baseSegment","routeSegment","isLastBaseSegment","isLastRouteSegment","toLowerCase","fuzzy","useParams","useSearch","rootRouteId","Route","isRoot","getParentRoute","$$typeof","Symbol","for","init","originalIndex","parentRoute","customId","fullPath","addChildren","update","assign","useRouteContext","context","RootRoute","super","preloadWarning","useLinkProps","target","activeProps","className","inactiveProps","activeOptions","disabled","mask","userPreload","preloadDelay","userPreloadDelay","startTransition","resetScroll","onFocus","onMouseEnter","onMouseLeave","onTouchStart","dest","URL","defaultPreload","defaultPreloadDelay","isActive","currentPathSplit","pathIsFuzzyEqual","every","pathTest","exact","hashTest","includeHash","searchTest","includeSearch","composeHandlers","handlers","persist","handler","defaultPrevented","resolvedActiveProps","resolvedInactiveProps","maskedLocation","metaKey","altKey","ctrlKey","shiftKey","isCtrlEvent","button","preloadRoute","catch","warn","preloadTimeout","clearTimeout","role","Link","forwardRef","ref","linkProps","_extends","encode","pfx","tmp","encodeURIComponent","toValue","mix","decodeURIComponent","decode","out","shift","concat","isRedirect","defaultParseSearch","parseSearchWith","JSON","parse","defaultStringifySearch","stringifySearchWith","stringify","parser","searchStr","query","val","stringifyValue","componentTypes","SearchParamError","PathParamError","getInitialRouterState","lastUpdated","Date","now","windowKey","delimiter","weakScrolledElements","WeakSet","cache","sessionStorage","storageKey","getItem","cached","set","setItem","defaultGetKey","useScrollRestoration","getKey","scrollRestoration","onScroll","has","elementSelector","attrId","getAttribute","getCssSelector","scrollX","NaN","scrollY","unsubOnBeforeLoad","restoreKey","entry","element","scrollLeft","scrollTop","unsubOnResolved","resetNextScroll","windowRestored","cacheKey","scrollTo","parentNode","tagName","useBlocker","blockerFn","awaited","createRoute","navigate","tempLocationKey","round","navigateTimeout","latestLoadPromise","injectedHtml","defaultPendingMs","defaultPendingMinMs","stringifySearch","parseSearch","newOptions","routeTree","buildRouteTree","routesByPath","notFoundRoute","recurseRoutes","childRoutes","childRoute","String","trimmedFullPath","endsWith","scoredRoutes","values","trimmed","parsed","scores","child","flatRoutes","sort","minLength","rank","eventType","routerEvent","checkLatest","previousLocation","parsedSearch","reverse","__tempLocation","__tempKey","parsedTempLocation","resolvePathWithBase","looseRoutesById","matchRoutes","locationSearch","routeParams","foundRoute","matchedParams","routeCursor","matchedRoutes","parseErrors","parsedParamsError","parseParams","parsedParams","cause","throwOnError","parentMatch","preMatchSearch","searchError","parentSearch","validator","validateSearch","loaderDepsHash","interpolatedPath","existingMatch","hasLoaders","loader","updatedAt","isFetching","paramsError","routeContext","abortController","AbortController","fetchCount","invalid","cancelMatch","abort","cancelMatches","build","fromSearch","at","fromPathname","fromMatches","stayingMatches","prevParams","nextParams","stringifyParams","preSearchFilters","flat","postSearchFilters","preFilteredSearch","destSearch","hashStr","nextState","unmaskOnReload","buildWithMatches","maskedDest","maskedNext","foundMask","routeMasks","nextMatches","maskedMatches","maskedFinal","final","nextHistory","buildAndCommitLocation","fromString","isExternal","loadMatches","latestPromise","firstBadMatchIndex","updateMatch","isPending","isMatched","matchesKey","handleErrorAndRedirect","code","routerCode","onError","errorHandlerErr","parentContext","beforeLoadContext","beforeLoad","validResolvedMatches","matchPromises","parentMatchPromise","didShowPending","pendingMs","pendingMinMs","shouldPending","loaderContext","deps","fetch","componentsPromise","all","loaderPromise","onErrorError","age","shouldReload","staleAge","preloadStaleTime","defaultPreloadStaleTime","staleTime","defaultStaleTime","shouldReloadOption","invalidate","reject","prevLocation","pathDidChange","previousMatches","cleanCache","debug","exitingMatches","enteringMatches","hook","gcTime","preloadGcTime","defaultPreloadGcTime","defaultGcTime","navigateOpts","loadedMatchIds","fromEntries","baseLocation","injectHtml","html","getData","strKey","dehydrate","dehydratedMatches","hydrate","_ctx","__do_not_use_server_ctx","ctx","dehydratedData","payload","dehydratedState","dehydratedMatch","InnerWrap","provider","Wrap","_promise","args","importer","exportName","lazyComp","lazy","default","throw","getElement","defaultOpts","contextMatchId","fnRef"],"mappings":"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","x_google_ignoreList":[1,2,3,4,5,26]}