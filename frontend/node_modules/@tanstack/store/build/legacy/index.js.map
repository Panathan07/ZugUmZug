{"version":3,"sources":["../../src/index.ts"],"sourcesContent":["export type AnyUpdater = (...args: any[]) => any\n\nexport type Listener = (opts: { priority: Priority }) => void\n\nexport type Priority = 'high' | 'low'\n\ninterface StoreOptions<\n  TState,\n  TUpdater extends AnyUpdater = (cb: TState) => TState,\n> {\n  updateFn?: (previous: TState) => (updater: TUpdater) => TState\n  onSubscribe?: (\n    listener: Listener,\n    store: Store<TState, TUpdater>,\n  ) => () => void\n  onUpdate?: (opts: { priority: Priority }) => void\n  defaultPriority?: Priority\n}\n\nexport class Store<\n  TState,\n  TUpdater extends AnyUpdater = (cb: TState) => TState,\n> {\n  listeners = new Set<Listener>()\n  state: TState\n  options?: StoreOptions<TState, TUpdater>\n  _batching = false\n  _flushing = 0\n  _nextPriority: null | Priority = null\n\n  constructor(initialState: TState, options?: StoreOptions<TState, TUpdater>) {\n    this.state = initialState\n    this.options = options\n  }\n\n  subscribe = (listener: Listener) => {\n    this.listeners.add(listener)\n    const unsub = this.options?.onSubscribe?.(listener, this)\n    return () => {\n      this.listeners.delete(listener)\n      unsub?.()\n    }\n  }\n\n  setState = (\n    updater: TUpdater,\n    opts?: {\n      priority: Priority\n    },\n  ) => {\n    const previous = this.state\n    this.state = this.options?.updateFn\n      ? this.options.updateFn(previous)(updater)\n      : (updater as any)(previous)\n\n    const priority = opts?.priority ?? this.options?.defaultPriority ?? 'high'\n    if (this._nextPriority === null) {\n      this._nextPriority = priority\n    } else if (this._nextPriority === 'high') {\n      this._nextPriority = priority\n    } else {\n      this._nextPriority = this.options?.defaultPriority ?? 'high'\n    }\n\n    // Always run onUpdate, regardless of batching\n    this.options?.onUpdate?.({\n      priority: this._nextPriority,\n    })\n\n    // Attempt to flush\n    this._flush()\n  }\n\n  _flush = () => {\n    if (this._batching) return\n    const flushId = ++this._flushing\n    this.listeners.forEach((listener) => {\n      if (this._flushing !== flushId) return\n      listener({\n        priority: this._nextPriority ?? 'high',\n      })\n    })\n  }\n\n  batch = (cb: () => void) => {\n    if (this._batching) return cb()\n    this._batching = true\n    cb()\n    this._batching = false\n    this._flush()\n  }\n}\n"],"mappings":";AAmBO,IAAM,QAAN,MAGL;AAAA,EAQA,YAAY,cAAsB,SAA0C;AAP5E,qBAAY,oBAAI,IAAc;AAG9B,qBAAY;AACZ,qBAAY;AACZ,yBAAiC;AAOjC,qBAAY,CAAC,aAAuB;AAnCtC;AAoCI,WAAK,UAAU,IAAI,QAAQ;AAC3B,YAAM,SAAQ,gBAAK,YAAL,mBAAc,gBAAd,4BAA4B,UAAU;AACpD,aAAO,MAAM;AACX,aAAK,UAAU,OAAO,QAAQ;AAC9B;AAAA,MACF;AAAA,IACF;AAEA,oBAAW,CACT,SACA,SAGG;AAjDP;AAkDI,YAAM,WAAW,KAAK;AACtB,WAAK,UAAQ,UAAK,YAAL,mBAAc,YACvB,KAAK,QAAQ,SAAS,QAAQ,EAAE,OAAO,IACtC,QAAgB,QAAQ;AAE7B,YAAM,YAAW,6BAAM,eAAY,UAAK,YAAL,mBAAc,oBAAmB;AACpE,UAAI,KAAK,kBAAkB,MAAM;AAC/B,aAAK,gBAAgB;AAAA,MACvB,WAAW,KAAK,kBAAkB,QAAQ;AACxC,aAAK,gBAAgB;AAAA,MACvB,OAAO;AACL,aAAK,kBAAgB,UAAK,YAAL,mBAAc,oBAAmB;AAAA,MACxD;AAGA,uBAAK,YAAL,mBAAc,aAAd,4BAAyB;AAAA,QACvB,UAAU,KAAK;AAAA,MACjB;AAGA,WAAK,OAAO;AAAA,IACd;AAEA,kBAAS,MAAM;AACb,UAAI,KAAK;AAAW;AACpB,YAAM,UAAU,EAAE,KAAK;AACvB,WAAK,UAAU,QAAQ,CAAC,aAAa;AACnC,YAAI,KAAK,cAAc;AAAS;AAChC,iBAAS;AAAA,UACP,UAAU,KAAK,iBAAiB;AAAA,QAClC,CAAC;AAAA,MACH,CAAC;AAAA,IACH;AAEA,iBAAQ,CAAC,OAAmB;AAC1B,UAAI,KAAK;AAAW,eAAO,GAAG;AAC9B,WAAK,YAAY;AACjB,SAAG;AACH,WAAK,YAAY;AACjB,WAAK,OAAO;AAAA,IACd;AA3DE,SAAK,QAAQ;AACb,SAAK,UAAU;AAAA,EACjB;AA0DF;","names":[]}