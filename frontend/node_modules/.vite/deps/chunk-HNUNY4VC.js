import {
  require_react
} from "./chunk-57B3BVVS.js";
import {
  __commonJS,
  __publicField,
  __toESM
} from "./chunk-3SPBDNLE.js";

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React2 = require_react();
        var ReactSharedInternals = React2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useState2 = React2.useState, useEffect2 = React2.useEffect, useLayoutEffect3 = React2.useLayoutEffect, useDebugValue = React2.useDebugValue;
        var didWarnOld18Alpha = false;
        var didWarnUncachedGetSnapshot = false;
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          {
            if (!didWarnOld18Alpha) {
              if (React2.startTransition !== void 0) {
                didWarnOld18Alpha = true;
                error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
              }
            }
          }
          var value = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedValue = getSnapshot();
              if (!objectIs(value, cachedValue)) {
                error("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var _useState = useState2({
            inst: {
              value,
              getSnapshot
            }
          }), inst = _useState[0].inst, forceUpdate = _useState[1];
          useLayoutEffect3(function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
          }, [subscribe, value, getSnapshot]);
          useEffect2(function() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            };
            return subscribe(handleStoreChange);
          }, [subscribe]);
          useDebugValue(value);
          return value;
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error2) {
            return true;
          }
        }
        function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
          return getSnapshot();
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var isServerEnvironment = !canUseDOM;
        var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;
        var useSyncExternalStore$2 = React2.useSyncExternalStore !== void 0 ? React2.useSyncExternalStore : shim;
        exports.useSyncExternalStore = useSyncExternalStore$2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js
var require_with_selector_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React2 = require_react();
        var shim = require_shim();
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useSyncExternalStore = shim.useSyncExternalStore;
        var useRef2 = React2.useRef, useEffect2 = React2.useEffect, useMemo = React2.useMemo, useDebugValue = React2.useDebugValue;
        function useSyncExternalStoreWithSelector2(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
          var instRef = useRef2(null);
          var inst;
          if (instRef.current === null) {
            inst = {
              hasValue: false,
              value: null
            };
            instRef.current = inst;
          } else {
            inst = instRef.current;
          }
          var _useMemo = useMemo(function() {
            var hasMemo = false;
            var memoizedSnapshot;
            var memoizedSelection;
            var memoizedSelector = function(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                var _nextSelection = selector(nextSnapshot);
                if (isEqual !== void 0) {
                  if (inst.hasValue) {
                    var currentSelection = inst.value;
                    if (isEqual(currentSelection, _nextSelection)) {
                      memoizedSelection = currentSelection;
                      return currentSelection;
                    }
                  }
                }
                memoizedSelection = _nextSelection;
                return _nextSelection;
              }
              var prevSnapshot = memoizedSnapshot;
              var prevSelection = memoizedSelection;
              if (objectIs(prevSnapshot, nextSnapshot)) {
                return prevSelection;
              }
              var nextSelection = selector(nextSnapshot);
              if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {
                return prevSelection;
              }
              memoizedSnapshot = nextSnapshot;
              memoizedSelection = nextSelection;
              return nextSelection;
            };
            var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
            var getSnapshotWithSelector = function() {
              return memoizedSelector(getSnapshot());
            };
            var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {
              return memoizedSelector(maybeGetServerSnapshot());
            };
            return [getSnapshotWithSelector, getServerSnapshotWithSelector];
          }, [getSnapshot, getServerSnapshot, selector, isEqual]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];
          var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);
          useEffect2(function() {
            inst.hasValue = true;
            inst.value = value;
          }, [value]);
          useDebugValue(value);
          return value;
        }
        exports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/use-sync-external-store/shim/with-selector.js
var require_with_selector = __commonJS({
  "node_modules/use-sync-external-store/shim/with-selector.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_with_selector_development();
    }
  }
});

// node_modules/@tanstack/history/build/esm/index.js
var pushStateEvent = "pushstate";
var popStateEvent = "popstate";
var beforeUnloadEvent = "beforeunload";
var beforeUnloadListener = (event) => {
  event.preventDefault();
  return event.returnValue = "";
};
var stopBlocking = () => {
  removeEventListener(beforeUnloadEvent, beforeUnloadListener, {
    capture: true
  });
};
function createHistory(opts) {
  let location = opts.getLocation();
  let subscribers = /* @__PURE__ */ new Set();
  let blockers = [];
  const onUpdate = () => {
    location = opts.getLocation();
    subscribers.forEach((subscriber) => subscriber());
  };
  const tryNavigation = async (task) => {
    var _a;
    if (typeof document !== "undefined" && blockers.length) {
      for (let blocker of blockers) {
        const allowed = await blocker();
        if (!allowed) {
          (_a = opts.onBlocked) == null ? void 0 : _a.call(opts, onUpdate);
          return;
        }
      }
    }
    task();
  };
  return {
    get location() {
      return location;
    },
    subscribe: (cb) => {
      subscribers.add(cb);
      return () => {
        subscribers.delete(cb);
      };
    },
    push: (path, state) => {
      state = assignKey(state);
      tryNavigation(() => {
        opts.pushState(path, state, onUpdate);
      });
    },
    replace: (path, state) => {
      state = assignKey(state);
      tryNavigation(() => {
        opts.replaceState(path, state, onUpdate);
      });
    },
    go: (index) => {
      tryNavigation(() => {
        opts.go(index);
      });
    },
    back: () => {
      tryNavigation(() => {
        opts.back();
      });
    },
    forward: () => {
      tryNavigation(() => {
        opts.forward();
      });
    },
    createHref: (str) => opts.createHref(str),
    block: (blocker) => {
      blockers.push(blocker);
      if (blockers.length === 1) {
        addEventListener(beforeUnloadEvent, beforeUnloadListener, {
          capture: true
        });
      }
      return () => {
        blockers = blockers.filter((b) => b !== blocker);
        if (!blockers.length) {
          stopBlocking();
        }
      };
    },
    flush: () => {
      var _a;
      return (_a = opts.flush) == null ? void 0 : _a.call(opts);
    },
    destroy: () => {
      var _a;
      return (_a = opts.destroy) == null ? void 0 : _a.call(opts);
    },
    notify: onUpdate
  };
}
function assignKey(state) {
  if (!state) {
    state = {};
  }
  return {
    ...state,
    key: createRandomKey()
  };
}
function createBrowserHistory(opts) {
  const win = (opts == null ? void 0 : opts.window) ?? (typeof document !== "undefined" ? window : void 0);
  const createHref = (opts == null ? void 0 : opts.createHref) ?? ((path) => path);
  const parseLocation = (opts == null ? void 0 : opts.parseLocation) ?? (() => parseHref(`${win.location.pathname}${win.location.search}${win.location.hash}`, win.history.state));
  let currentLocation = parseLocation();
  let rollbackLocation;
  const getLocation = () => currentLocation;
  let next;
  let tracking = true;
  let scheduled;
  const untrack = (fn) => {
    tracking = false;
    fn();
    tracking = true;
  };
  const flush = () => {
    untrack(() => {
      if (!next)
        return;
      win.history[next.isPush ? "pushState" : "replaceState"](next.state, "", next.href);
      next = void 0;
      scheduled = void 0;
      rollbackLocation = void 0;
    });
  };
  const queueHistoryAction = (type, destHref, state, onUpdate) => {
    const href = createHref(destHref);
    if (!scheduled) {
      rollbackLocation = currentLocation;
    }
    currentLocation = parseHref(destHref, state);
    next = {
      href,
      state,
      isPush: (next == null ? void 0 : next.isPush) || type === "push"
    };
    onUpdate();
    if (!scheduled) {
      scheduled = Promise.resolve().then(() => flush());
    }
  };
  const onPushPop = () => {
    currentLocation = parseLocation();
    history.notify();
  };
  var originalPushState = win.history.pushState;
  var originalReplaceState = win.history.replaceState;
  const history = createHistory({
    getLocation,
    pushState: (href, state, onUpdate) => queueHistoryAction("push", href, state, onUpdate),
    replaceState: (href, state, onUpdate) => queueHistoryAction("replace", href, state, onUpdate),
    back: () => win.history.back(),
    forward: () => win.history.forward(),
    go: (n) => win.history.go(n),
    createHref: (href) => createHref(href),
    flush,
    destroy: () => {
      win.history.pushState = originalPushState;
      win.history.replaceState = originalReplaceState;
      win.removeEventListener(pushStateEvent, onPushPop);
      win.removeEventListener(popStateEvent, onPushPop);
    },
    onBlocked: (onUpdate) => {
      if (rollbackLocation && currentLocation !== rollbackLocation) {
        currentLocation = rollbackLocation;
        onUpdate();
      }
    }
  });
  win.addEventListener(pushStateEvent, onPushPop);
  win.addEventListener(popStateEvent, onPushPop);
  win.history.pushState = function() {
    let res = originalPushState.apply(win.history, arguments);
    if (tracking)
      history.notify();
    return res;
  };
  win.history.replaceState = function() {
    let res = originalReplaceState.apply(win.history, arguments);
    if (tracking)
      history.notify();
    return res;
  };
  return history;
}
function createHashHistory(opts) {
  const win = (opts == null ? void 0 : opts.window) ?? (typeof document !== "undefined" ? window : void 0);
  return createBrowserHistory({
    window: win,
    parseLocation: () => {
      const hashHref = win.location.hash.split("#").slice(1).join("#") ?? "/";
      return parseHref(hashHref, win.history.state);
    },
    createHref: (href) => `${win.location.pathname}${win.location.search}#${href}`
  });
}
function createMemoryHistory(opts = {
  initialEntries: ["/"]
}) {
  const entries = opts.initialEntries;
  let index = opts.initialIndex ?? entries.length - 1;
  let currentState = {
    key: createRandomKey()
  };
  const getLocation = () => parseHref(entries[index], currentState);
  return createHistory({
    getLocation,
    pushState: (path, state) => {
      currentState = state;
      entries.push(path);
      index++;
    },
    replaceState: (path, state) => {
      currentState = state;
      entries[index] = path;
    },
    back: () => {
      index--;
    },
    forward: () => {
      index = Math.min(index + 1, entries.length - 1);
    },
    go: (n) => {
      index = Math.min(Math.max(index + n, 0), entries.length - 1);
    },
    createHref: (path) => path
  });
}
function parseHref(href, state) {
  let hashIndex = href.indexOf("#");
  let searchIndex = href.indexOf("?");
  return {
    href,
    pathname: href.substring(0, hashIndex > 0 ? searchIndex > 0 ? Math.min(hashIndex, searchIndex) : hashIndex : searchIndex > 0 ? searchIndex : href.length),
    hash: hashIndex > -1 ? href.substring(hashIndex) : "",
    search: searchIndex > -1 ? href.slice(searchIndex, hashIndex === -1 ? void 0 : hashIndex) : "",
    state: state || {}
  };
}
function createRandomKey() {
  return (Math.random() + 1).toString(36).substring(7);
}

// node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var isProduction = false;
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  var provided = typeof message === "function" ? message() : message;
  var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
  throw new Error(value);
}

// node_modules/tiny-warning/dist/tiny-warning.esm.js
var isProduction2 = false;
function warning(condition, message) {
  if (!isProduction2) {
    if (condition) {
      return;
    }
    var text = "Warning: " + message;
    if (typeof console !== "undefined") {
      console.warn(text);
    }
    try {
      throw Error(text);
    } catch (x) {
    }
  }
}
var tiny_warning_esm_default = warning;

// node_modules/@tanstack/react-router/build/esm/index.js
var React = __toESM(require_react());

// node_modules/@tanstack/react-store/build/modern/index.js
var import_with_selector = __toESM(require_with_selector());

// node_modules/@tanstack/store/build/modern/index.js
var Store = class {
  constructor(initialState, options) {
    this.listeners = /* @__PURE__ */ new Set();
    this._batching = false;
    this._flushing = 0;
    this._nextPriority = null;
    this.subscribe = (listener) => {
      var _a, _b;
      this.listeners.add(listener);
      const unsub = (_b = (_a = this.options) == null ? void 0 : _a.onSubscribe) == null ? void 0 : _b.call(_a, listener, this);
      return () => {
        this.listeners.delete(listener);
        unsub == null ? void 0 : unsub();
      };
    };
    this.setState = (updater, opts) => {
      var _a, _b, _c, _d, _e;
      const previous = this.state;
      this.state = ((_a = this.options) == null ? void 0 : _a.updateFn) ? this.options.updateFn(previous)(updater) : updater(previous);
      const priority = (opts == null ? void 0 : opts.priority) ?? ((_b = this.options) == null ? void 0 : _b.defaultPriority) ?? "high";
      if (this._nextPriority === null) {
        this._nextPriority = priority;
      } else if (this._nextPriority === "high") {
        this._nextPriority = priority;
      } else {
        this._nextPriority = ((_c = this.options) == null ? void 0 : _c.defaultPriority) ?? "high";
      }
      (_e = (_d = this.options) == null ? void 0 : _d.onUpdate) == null ? void 0 : _e.call(_d, {
        priority: this._nextPriority
      });
      this._flush();
    };
    this._flush = () => {
      if (this._batching)
        return;
      const flushId = ++this._flushing;
      this.listeners.forEach((listener) => {
        if (this._flushing !== flushId)
          return;
        listener({
          priority: this._nextPriority ?? "high"
        });
      });
    };
    this.batch = (cb) => {
      if (this._batching)
        return cb();
      this._batching = true;
      cb();
      this._batching = false;
      this._flush();
    };
    this.state = initialState;
    this.options = options;
  }
};

// node_modules/@tanstack/react-store/build/modern/index.js
function useStore(store, selector = (d) => d) {
  const slice = (0, import_with_selector.useSyncExternalStoreWithSelector)(
    store.subscribe,
    () => store.state,
    () => store.state,
    selector,
    shallow
  );
  return slice;
}
function shallow(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  for (let i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
}

// node_modules/@tanstack/react-router/build/esm/index.js
function CatchBoundary(props) {
  const errorComponent = props.errorComponent ?? ErrorComponent;
  return React.createElement(CatchBoundaryImpl, {
    getResetKey: props.getResetKey,
    onCatch: props.onCatch,
    children: ({
      error
    }) => {
      if (error) {
        return React.createElement(errorComponent, {
          error
        });
      }
      return props.children;
    }
  });
}
var CatchBoundaryImpl = class extends React.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      error: null
    });
  }
  static getDerivedStateFromProps(props) {
    return {
      resetKey: props.getResetKey()
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  componentDidUpdate(prevProps, prevState) {
    if (prevState.error && prevState.resetKey !== this.state.resetKey) {
      this.setState({
        error: null
      });
    }
  }
  componentDidCatch(error) {
    var _a, _b;
    console.error(error);
    (_b = (_a = this.props).onCatch) == null ? void 0 : _b.call(_a, error);
  }
  render() {
    return this.props.children(this.state);
  }
};
function ErrorComponent({
  error
}) {
  const [show, setShow] = React.useState(true);
  return React.createElement("div", {
    style: {
      padding: ".5rem",
      maxWidth: "100%"
    }
  }, React.createElement("div", {
    style: {
      display: "flex",
      alignItems: "center",
      gap: ".5rem"
    }
  }, React.createElement("strong", {
    style: {
      fontSize: "1rem"
    }
  }, "Something went wrong!"), React.createElement("button", {
    style: {
      appearance: "none",
      fontSize: ".6em",
      border: "1px solid currentColor",
      padding: ".1rem .2rem",
      fontWeight: "bold",
      borderRadius: ".25rem"
    },
    onClick: () => setShow((d) => !d)
  }, show ? "Hide Error" : "Show Error")), React.createElement("div", {
    style: {
      height: ".25rem"
    }
  }), show ? React.createElement("div", null, React.createElement("pre", {
    style: {
      fontSize: ".7em",
      border: "1px solid red",
      borderRadius: ".25rem",
      padding: ".3rem",
      color: "red",
      overflow: "auto"
    }
  }, error.message ? React.createElement("code", null, error.message) : null)) : null);
}
var isServer = typeof document === "undefined";
function last(arr) {
  return arr[arr.length - 1];
}
function isFunction(d) {
  return typeof d === "function";
}
function functionalUpdate(updater, previous) {
  if (isFunction(updater)) {
    return updater(previous);
  }
  return updater;
}
function pick(parent, keys) {
  return keys.reduce((obj, key) => {
    obj[key] = parent[key];
    return obj;
  }, {});
}
function replaceEqualDeep(prev, _next) {
  if (prev === _next) {
    return prev;
  }
  const next = _next;
  const array = Array.isArray(prev) && Array.isArray(next);
  if (array || isPlainObject(prev) && isPlainObject(next)) {
    const prevSize = array ? prev.length : Object.keys(prev).length;
    const nextItems = array ? next : Object.keys(next);
    const nextSize = nextItems.length;
    const copy = array ? [] : {};
    let equalItems = 0;
    for (let i = 0; i < nextSize; i++) {
      const key = array ? i : nextItems[i];
      copy[key] = replaceEqualDeep(prev[key], next[key]);
      if (copy[key] === prev[key]) {
        equalItems++;
      }
    }
    return prevSize === nextSize && equalItems === prevSize ? prev : copy;
  }
  return next;
}
function isPlainObject(o) {
  if (!hasObjectPrototype(o)) {
    return false;
  }
  const ctor = o.constructor;
  if (typeof ctor === "undefined") {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function deepEqual(a, b, partial = false) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const aKeys = Object.keys(a);
    const bKeys = Object.keys(b);
    if (!partial && aKeys.length !== bKeys.length) {
      return false;
    }
    return !bKeys.some((key) => !(key in a) || !deepEqual(a[key], b[key], partial));
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    return !a.some((item, index) => !deepEqual(item, b[index], partial));
  }
  return false;
}
function useStableCallback(fn) {
  const fnRef = React.useRef(fn);
  fnRef.current = fn;
  const ref = React.useRef((...args) => fnRef.current(...args));
  return ref.current;
}
function shallow2(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  for (let i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
}
function useRouteContext(opts) {
  return useMatch({
    ...opts,
    select: (match) => (opts == null ? void 0 : opts.select) ? opts.select(match.context) : match.context
  });
}
var useLayoutEffect$1 = typeof window !== "undefined" ? React.useLayoutEffect : React.useEffect;
function escapeJSON(jsonString) {
  return jsonString.replace(/\\/g, "\\\\").replace(/'/g, "\\'").replace(/"/g, '\\"');
}
var matchContext = React.createContext(void 0);
function Matches() {
  const router = useRouter();
  const matchId = useRouterState({
    select: (s) => {
      var _a;
      return (_a = getRenderedMatches(s)[0]) == null ? void 0 : _a.id;
    }
  });
  return React.createElement(matchContext.Provider, {
    value: matchId
  }, React.createElement(CatchBoundary, {
    getResetKey: () => {
      var _a;
      return (_a = router.state.resolvedLocation.state) == null ? void 0 : _a.key;
    },
    errorComponent: ErrorComponent,
    onCatch: () => {
      tiny_warning_esm_default(false, `Error in router! Consider setting an 'errorComponent' in your RootRoute! ðŸ‘`);
    }
  }, matchId ? React.createElement(Match, {
    matchId
  }) : null));
}
function SafeFragment(props) {
  return React.createElement(React.Fragment, null, props.children);
}
function Match({
  matchId
}) {
  var _a, _b, _c;
  const router = useRouter();
  const routeId = useRouterState({
    select: (s) => {
      var _a2;
      return (_a2 = getRenderedMatches(s).find((d) => d.id === matchId)) == null ? void 0 : _a2.routeId;
    }
  });
  invariant(routeId, `Could not find routeId for matchId "${matchId}". Please file an issue!`);
  const route = router.routesById[routeId];
  const PendingComponent = route.options.pendingComponent ?? router.options.defaultPendingComponent;
  const pendingElement = PendingComponent ? React.createElement(PendingComponent, null) : null;
  const routeErrorComponent = route.options.errorComponent ?? router.options.defaultErrorComponent ?? ErrorComponent;
  const ResolvedSuspenseBoundary = route.options.wrapInSuspense ?? PendingComponent ?? ((_a = route.options.component) == null ? void 0 : _a.preload) ?? ((_b = route.options.pendingComponent) == null ? void 0 : _b.preload) ?? ((_c = route.options.errorComponent) == null ? void 0 : _c.preload) ? React.Suspense : SafeFragment;
  const ResolvedCatchBoundary = routeErrorComponent ? CatchBoundary : SafeFragment;
  return React.createElement(matchContext.Provider, {
    value: matchId
  }, React.createElement(ResolvedSuspenseBoundary, {
    fallback: pendingElement
  }, React.createElement(ResolvedCatchBoundary, {
    getResetKey: () => {
      var _a2;
      return (_a2 = router.state.resolvedLocation.state) == null ? void 0 : _a2.key;
    },
    errorComponent: routeErrorComponent,
    onCatch: () => {
      tiny_warning_esm_default(false, `Error in route match: ${matchId}`);
    }
  }, React.createElement(MatchInner, {
    matchId,
    pendingElement
  }))));
}
function MatchInner({
  matchId,
  pendingElement
}) {
  const router = useRouter();
  const routeId = useRouterState({
    select: (s) => {
      var _a;
      return (_a = getRenderedMatches(s).find((d) => d.id === matchId)) == null ? void 0 : _a.routeId;
    }
  });
  const route = router.routesById[routeId];
  const match = useRouterState({
    select: (s) => pick(getRenderedMatches(s).find((d) => d.id === matchId), ["status", "error", "showPending", "loadPromise"])
  });
  if (match.status === "error") {
    throw match.error;
  }
  if (match.status === "pending") {
    if (match.showPending) {
      return pendingElement;
    }
    throw match.loadPromise;
  }
  if (match.status === "success") {
    let Comp = route.options.component ?? router.options.defaultComponent;
    if (Comp) {
      return React.createElement(Comp, null);
    }
    return React.createElement(Outlet, null);
  }
  invariant(false, "Idle routeMatch status encountered during rendering! You should never see this. File an issue!");
}
var Outlet = React.memo(function Outlet2() {
  const matchId = React.useContext(matchContext);
  const childMatchId = useRouterState({
    select: (s) => {
      var _a;
      const matches = getRenderedMatches(s);
      const index = matches.findIndex((d) => d.id === matchId);
      return (_a = matches[index + 1]) == null ? void 0 : _a.id;
    }
  });
  if (!childMatchId) {
    return null;
  }
  return React.createElement(Match, {
    matchId: childMatchId
  });
});
function useMatchRoute() {
  useRouterState({
    select: (s) => [s.location, s.resolvedLocation]
  });
  const {
    matchRoute
  } = useRouter();
  return React.useCallback((opts) => {
    const {
      pending,
      caseSensitive,
      ...rest
    } = opts;
    return matchRoute(rest, {
      pending,
      caseSensitive
    });
  }, []);
}
function MatchRoute(props) {
  const matchRoute = useMatchRoute();
  const params = matchRoute(props);
  if (typeof props.children === "function") {
    return props.children(params);
  }
  return !!params ? props.children : null;
}
function getRenderedMatches(state) {
  var _a;
  return ((_a = state.pendingMatches) == null ? void 0 : _a.some((d) => d.showPending)) ? state.pendingMatches : state.matches;
}
function useMatch(opts) {
  var _a;
  const router = useRouter();
  const nearestMatchId = React.useContext(matchContext);
  const nearestMatchRouteId = (_a = getRenderedMatches(router.state).find((d) => d.id === nearestMatchId)) == null ? void 0 : _a.routeId;
  const matchRouteId = (() => {
    const matches = getRenderedMatches(router.state);
    const match = (opts == null ? void 0 : opts.from) ? matches.find((d) => d.routeId === (opts == null ? void 0 : opts.from)) : matches.find((d) => d.id === nearestMatchId);
    return match.routeId;
  })();
  if ((opts == null ? void 0 : opts.strict) ?? true) {
    invariant(nearestMatchRouteId == matchRouteId, `useMatch("${matchRouteId}") is being called in a component that is meant to render the '${nearestMatchRouteId}' route. Did you mean to 'useMatch("${matchRouteId}", { strict: false })' or 'useRoute("${matchRouteId}")' instead?`);
  }
  const matchSelection = useRouterState({
    select: (state) => {
      const match = getRenderedMatches(state).find((d) => d.id === nearestMatchId);
      invariant(match, `Could not find ${(opts == null ? void 0 : opts.from) ? `an active match from "${opts.from}"` : "a nearest match!"}`);
      return (opts == null ? void 0 : opts.select) ? opts.select(match) : match;
    }
  });
  return matchSelection;
}
function useMatches(opts) {
  return useRouterState({
    select: (state) => {
      let matches = getRenderedMatches(state);
      return (opts == null ? void 0 : opts.select) ? opts.select(matches) : matches;
    }
  });
}
function useParentMatches(opts) {
  const contextMatchId = React.useContext(matchContext);
  return useMatches({
    select: (matches) => {
      matches = matches.slice(matches.findIndex((d) => d.id === contextMatchId));
      return (opts == null ? void 0 : opts.select) ? opts.select(matches) : matches;
    }
  });
}
function useLoaderDeps(opts) {
  return useMatch({
    ...opts,
    select: (s) => {
      return typeof opts.select === "function" ? opts.select(s == null ? void 0 : s.loaderDeps) : s == null ? void 0 : s.loaderDeps;
    }
  });
}
function useLoaderData(opts) {
  return useMatch({
    ...opts,
    select: (s) => {
      return typeof opts.select === "function" ? opts.select(s == null ? void 0 : s.loaderData) : s == null ? void 0 : s.loaderData;
    }
  });
}
var routerContext = React.createContext(null);
if (typeof document !== "undefined") {
  if (window.__TSR_ROUTER_CONTEXT__) {
    routerContext = window.__TSR_ROUTER_CONTEXT__;
  } else {
    window.__TSR_ROUTER_CONTEXT__ = routerContext;
  }
}
function RouterProvider({
  router,
  ...rest
}) {
  router.update({
    ...router.options,
    ...rest,
    context: {
      ...router.options.context,
      ...rest == null ? void 0 : rest.context
    }
  });
  const matches = router.options.InnerWrap ? React.createElement(router.options.InnerWrap, null, React.createElement(Matches, null)) : React.createElement(Matches, null);
  const provider = React.createElement(routerContext.Provider, {
    value: router
  }, matches, React.createElement(Transitioner, null));
  if (router.options.Wrap) {
    return React.createElement(router.options.Wrap, null, provider);
  }
  return provider;
}
function Transitioner() {
  const router = useRouter();
  const routerState = useRouterState({
    select: (s) => pick(s, ["isLoading", "location", "resolvedLocation", "isTransitioning"])
  });
  const [isTransitioning, startReactTransition] = React.useTransition();
  router.startReactTransition = startReactTransition;
  React.useEffect(() => {
    if (isTransitioning) {
      router.__store.setState((s) => ({
        ...s,
        isTransitioning
      }));
    }
  }, [isTransitioning]);
  const tryLoad = () => {
    const apply = (cb) => {
      if (!routerState.isTransitioning) {
        startReactTransition(() => cb());
      } else {
        cb();
      }
    };
    apply(() => {
      try {
        router.load();
      } catch (err) {
        console.error(err);
      }
    });
  };
  useLayoutEffect$1(() => {
    const unsub = router.history.subscribe(() => {
      router.latestLocation = router.parseLocation(router.latestLocation);
      if (routerState.location !== router.latestLocation) {
        tryLoad();
      }
    });
    const nextLocation = router.buildLocation({
      search: true,
      params: true,
      hash: true,
      state: true
    });
    if (routerState.location.href !== nextLocation.href) {
      router.commitLocation({
        ...nextLocation,
        replace: true
      });
    }
    return () => {
      unsub();
    };
  }, [router.history]);
  useLayoutEffect$1(() => {
    var _a;
    if (routerState.isTransitioning && !isTransitioning && !routerState.isLoading && routerState.resolvedLocation !== routerState.location) {
      router.emit({
        type: "onResolved",
        fromLocation: routerState.resolvedLocation,
        toLocation: routerState.location,
        pathChanged: routerState.location.href !== ((_a = routerState.resolvedLocation) == null ? void 0 : _a.href)
      });
      if (document.querySelector) {
        if (routerState.location.hash !== "") {
          const el = document.getElementById(routerState.location.hash);
          if (el) {
            el.scrollIntoView();
          }
        }
      }
      router.__store.setState((s) => ({
        ...s,
        isTransitioning: false,
        resolvedLocation: s.location
      }));
    }
  }, [routerState.isTransitioning, isTransitioning, routerState.isLoading, routerState.resolvedLocation, routerState.location]);
  useLayoutEffect$1(() => {
    if (!window.__TSR_DEHYDRATED__) {
      tryLoad();
    }
  }, []);
  return null;
}
function getRouteMatch(state, id) {
  return [...state.cachedMatches, ...state.pendingMatches ?? [], ...state.matches].find((d) => d.id === id);
}
function useRouterState(opts) {
  const router = useRouter();
  return useStore(router.__store, opts == null ? void 0 : opts.select);
}
function useRouter() {
  const resolvedContext = typeof document !== "undefined" ? window.__TSR_ROUTER_CONTEXT__ || routerContext : routerContext;
  const value = React.useContext(resolvedContext);
  tiny_warning_esm_default(value, "useRouter must be used inside a <RouterProvider> component!");
  return value;
}
function defer(_promise) {
  const promise = _promise;
  if (!promise.__deferredState) {
    promise.__deferredState = {
      uid: Math.random().toString(36).slice(2),
      status: "pending"
    };
    const state = promise.__deferredState;
    promise.then((data) => {
      state.status = "success";
      state.data = data;
    }).catch((error) => {
      state.status = "error";
      state.error = error;
    });
  }
  return promise;
}
function isDehydratedDeferred(obj) {
  return typeof obj === "object" && obj !== null && !(obj instanceof Promise) && !obj.then && "__deferredState" in obj;
}
function useAwaited({
  promise
}) {
  const router = useRouter();
  let state = promise.__deferredState;
  const key = `__TSR__DEFERRED__${state.uid}`;
  if (isDehydratedDeferred(promise)) {
    state = router.hydrateData(key);
    promise = Promise.resolve(state.data);
    promise.__deferredState = state;
  }
  if (state.status === "pending") {
    throw new Promise((r) => setTimeout(r, 1)).then(() => promise);
  }
  if (state.status === "error") {
    throw state.error;
  }
  router.dehydrateData(key, state);
  return [state.data];
}
function Await(props) {
  const awaited = useAwaited(props);
  return props.children(...awaited);
}
function joinPaths(paths) {
  return cleanPath(paths.filter(Boolean).join("/"));
}
function cleanPath(path) {
  return path.replace(/\/{2,}/g, "/");
}
function trimPathLeft(path) {
  return path === "/" ? path : path.replace(/^\/{1,}/, "");
}
function trimPathRight(path) {
  return path === "/" ? path : path.replace(/\/{1,}$/, "");
}
function trimPath(path) {
  return trimPathRight(trimPathLeft(path));
}
function resolvePath(basepath, base, to) {
  base = base.replace(new RegExp(`^${basepath}`), "/");
  to = to.replace(new RegExp(`^${basepath}`), "/");
  let baseSegments = parsePathname(base);
  const toSegments = parsePathname(to);
  toSegments.forEach((toSegment, index) => {
    var _a;
    if (toSegment.value === "/") {
      if (!index) {
        baseSegments = [toSegment];
      } else if (index === toSegments.length - 1) {
        baseSegments.push(toSegment);
      } else
        ;
    } else if (toSegment.value === "..") {
      if (baseSegments.length > 1 && ((_a = last(baseSegments)) == null ? void 0 : _a.value) === "/") {
        baseSegments.pop();
      }
      baseSegments.pop();
    } else if (toSegment.value === ".") {
      return;
    } else {
      baseSegments.push(toSegment);
    }
  });
  const joined = joinPaths([basepath, ...baseSegments.map((d) => d.value)]);
  return cleanPath(joined);
}
function parsePathname(pathname) {
  if (!pathname) {
    return [];
  }
  pathname = cleanPath(pathname);
  const segments = [];
  if (pathname.slice(0, 1) === "/") {
    pathname = pathname.substring(1);
    segments.push({
      type: "pathname",
      value: "/"
    });
  }
  if (!pathname) {
    return segments;
  }
  const split = pathname.split("/").filter(Boolean);
  segments.push(...split.map((part) => {
    if (part === "$" || part === "*") {
      return {
        type: "wildcard",
        value: part
      };
    }
    if (part.charAt(0) === "$") {
      return {
        type: "param",
        value: part
      };
    }
    return {
      type: "pathname",
      value: part
    };
  }));
  if (pathname.slice(-1) === "/") {
    pathname = pathname.substring(1);
    segments.push({
      type: "pathname",
      value: "/"
    });
  }
  return segments;
}
function interpolatePath(path, params, leaveWildcards = false) {
  const interpolatedPathSegments = parsePathname(path);
  return joinPaths(interpolatedPathSegments.map((segment) => {
    if (segment.type === "wildcard") {
      const value = params[segment.value];
      if (leaveWildcards)
        return `${segment.value}${value ?? ""}`;
      return value;
    }
    if (segment.type === "param") {
      return params[segment.value.substring(1)] ?? "undefined";
    }
    return segment.value;
  }));
}
function matchPathname(basepath, currentPathname, matchLocation) {
  const pathParams = matchByPath(basepath, currentPathname, matchLocation);
  if (matchLocation.to && !pathParams) {
    return;
  }
  return pathParams ?? {};
}
function removeBasepath(basepath, pathname) {
  return basepath != "/" ? pathname.substring(basepath.length) : pathname;
}
function matchByPath(basepath, from, matchLocation) {
  from = removeBasepath(basepath, from);
  const to = `${matchLocation.to ?? "$"}`;
  const baseSegments = parsePathname(from);
  const routeSegments = parsePathname(to);
  if (!from.startsWith("/")) {
    baseSegments.unshift({
      type: "pathname",
      value: "/"
    });
  }
  if (!to.startsWith("/")) {
    routeSegments.unshift({
      type: "pathname",
      value: "/"
    });
  }
  const params = {};
  let isMatch = (() => {
    for (let i = 0; i < Math.max(baseSegments.length, routeSegments.length); i++) {
      const baseSegment = baseSegments[i];
      const routeSegment = routeSegments[i];
      const isLastBaseSegment = i >= baseSegments.length - 1;
      const isLastRouteSegment = i >= routeSegments.length - 1;
      if (routeSegment) {
        if (routeSegment.type === "wildcard") {
          if (baseSegment == null ? void 0 : baseSegment.value) {
            params["*"] = joinPaths(baseSegments.slice(i).map((d) => d.value));
            return true;
          }
          return false;
        }
        if (routeSegment.type === "pathname") {
          if (routeSegment.value === "/" && !(baseSegment == null ? void 0 : baseSegment.value)) {
            return true;
          }
          if (baseSegment) {
            if (matchLocation.caseSensitive) {
              if (routeSegment.value !== baseSegment.value) {
                return false;
              }
            } else if (routeSegment.value.toLowerCase() !== baseSegment.value.toLowerCase()) {
              return false;
            }
          }
        }
        if (!baseSegment) {
          return false;
        }
        if (routeSegment.type === "param") {
          if ((baseSegment == null ? void 0 : baseSegment.value) === "/") {
            return false;
          }
          if (baseSegment.value.charAt(0) !== "$") {
            params[routeSegment.value.substring(1)] = baseSegment.value;
          }
        }
      }
      if (!isLastBaseSegment && isLastRouteSegment) {
        params["**"] = joinPaths(baseSegments.slice(i + 1).map((d) => d.value));
        return !!matchLocation.fuzzy && (routeSegment == null ? void 0 : routeSegment.value) !== "/";
      }
    }
    return true;
  })();
  return isMatch ? params : void 0;
}
function useParams(opts) {
  return useRouterState({
    select: (state) => {
      var _a;
      const params = (_a = last(state.matches)) == null ? void 0 : _a.params;
      return (opts == null ? void 0 : opts.select) ? opts.select(params) : params;
    }
  });
}
function useSearch(opts) {
  return useMatch({
    ...opts,
    select: (match) => {
      return (opts == null ? void 0 : opts.select) ? opts.select(match.search) : match.search;
    }
  });
}
var rootRouteId = "__root__";
var RouteApi = class {
  constructor({
    id
  }) {
    __publicField(this, "useMatch", (opts) => {
      return useMatch({
        ...opts,
        from: this.id
      });
    });
    __publicField(this, "useRouteContext", (opts) => {
      return useMatch({
        ...opts,
        from: this.id,
        select: (d) => (opts == null ? void 0 : opts.select) ? opts.select(d.context) : d.context
      });
    });
    __publicField(this, "useSearch", (opts) => {
      return useSearch({
        ...opts,
        from: this.id
      });
    });
    __publicField(this, "useParams", (opts) => {
      return useParams({
        ...opts,
        from: this.id
      });
    });
    __publicField(this, "useLoaderDeps", (opts) => {
      return useLoaderDeps({
        ...opts,
        from: this.id
      });
    });
    __publicField(this, "useLoaderData", (opts) => {
      return useLoaderData({
        ...opts,
        from: this.id
      });
    });
    this.id = id;
  }
};
var Route = class {
  // Set up in this.init()
  // customId!: TCustomId
  // Optional
  constructor(options) {
    __publicField(this, "init", (opts) => {
      var _a, _b;
      this.originalIndex = opts.originalIndex;
      const options = this.options;
      const isRoot = !(options == null ? void 0 : options.path) && !(options == null ? void 0 : options.id);
      this.parentRoute = (_b = (_a = this.options) == null ? void 0 : _a.getParentRoute) == null ? void 0 : _b.call(_a);
      if (isRoot) {
        this.path = rootRouteId;
      } else {
        invariant(this.parentRoute, `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`);
      }
      let path = isRoot ? rootRouteId : options.path;
      if (path && path !== "/") {
        path = trimPath(path);
      }
      const customId = (options == null ? void 0 : options.id) || path;
      let id = isRoot ? rootRouteId : joinPaths([this.parentRoute.id === rootRouteId ? "" : this.parentRoute.id, customId]);
      if (path === rootRouteId) {
        path = "/";
      }
      if (id !== rootRouteId) {
        id = joinPaths(["/", id]);
      }
      const fullPath = id === rootRouteId ? "/" : joinPaths([this.parentRoute.fullPath, path]);
      this.path = path;
      this.id = id;
      this.fullPath = fullPath;
      this.to = fullPath;
    });
    __publicField(this, "addChildren", (children) => {
      this.children = children;
      return this;
    });
    __publicField(this, "update", (options) => {
      Object.assign(this.options, options);
      return this;
    });
    __publicField(this, "useMatch", (opts) => {
      return useMatch({
        ...opts,
        from: this.id
      });
    });
    __publicField(this, "useRouteContext", (opts) => {
      return useMatch({
        ...opts,
        from: this.id,
        select: (d) => (opts == null ? void 0 : opts.select) ? opts.select(d.context) : d.context
      });
    });
    __publicField(this, "useSearch", (opts) => {
      return useSearch({
        ...opts,
        from: this.id
      });
    });
    __publicField(this, "useParams", (opts) => {
      return useParams({
        ...opts,
        from: this.id
      });
    });
    __publicField(this, "useLoaderDeps", (opts) => {
      return useLoaderDeps({
        ...opts,
        from: this.id
      });
    });
    __publicField(this, "useLoaderData", (opts) => {
      return useLoaderData({
        ...opts,
        from: this.id
      });
    });
    this.options = options || {};
    this.isRoot = !(options == null ? void 0 : options.getParentRoute);
    invariant(!((options == null ? void 0 : options.id) && (options == null ? void 0 : options.path)), `Route cannot have both an 'id' and a 'path' option.`);
    this.$$typeof = Symbol.for("react.memo");
  }
};
function rootRouteWithContext() {
  return (options) => {
    return new RootRoute(options);
  };
}
var RootRoute = class extends Route {
  constructor(options) {
    super(options);
  }
};
function createRouteMask(opts) {
  return opts;
}
var NotFoundRoute = class extends Route {
  constructor(options) {
    super({
      ...options,
      id: "404"
    });
  }
};
var FileRoute = class {
  constructor(path) {
    __publicField(this, "createRoute", (options) => {
      const route = new Route(options);
      route.isRoot = false;
      return route;
    });
    this.path = path;
  }
};
function lazyRouteComponent(importer, exportName) {
  let loadPromise;
  const load = () => {
    if (!loadPromise) {
      loadPromise = importer();
    }
    return loadPromise;
  };
  const lazyComp = React.lazy(async () => {
    const moduleExports = await load();
    const comp = moduleExports[exportName ?? "default"];
    return {
      default: comp
    };
  });
  lazyComp.preload = load;
  return lazyComp;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var preloadWarning = "Error preloading route! â˜ï¸";
function useLinkProps(options) {
  const router = useRouter();
  const matchPathname2 = useMatch({
    strict: false,
    select: (s) => s.pathname
  });
  const {
    // custom props
    children,
    target,
    activeProps = () => ({
      className: "active"
    }),
    inactiveProps = () => ({}),
    activeOptions,
    disabled,
    hash,
    search,
    params,
    to,
    state,
    mask,
    preload: userPreload,
    preloadDelay: userPreloadDelay,
    replace,
    startTransition,
    resetScroll,
    // element props
    style,
    className,
    onClick,
    onFocus,
    onMouseEnter,
    onMouseLeave,
    onTouchStart,
    ...rest
  } = options;
  const dest = {
    from: options.to ? matchPathname2 : void 0,
    ...options
  };
  let type = "internal";
  try {
    new URL(`${to}`);
    type = "external";
  } catch {
  }
  if (type === "external") {
    return {
      href: to
    };
  }
  const next = router.buildLocation(dest);
  const preload = userPreload ?? router.options.defaultPreload;
  const preloadDelay = userPreloadDelay ?? router.options.defaultPreloadDelay ?? 0;
  const isActive = useRouterState({
    select: (s) => {
      const currentPathSplit = s.location.pathname.split("/");
      const nextPathSplit = next.pathname.split("/");
      const pathIsFuzzyEqual = nextPathSplit.every((d, i) => d === currentPathSplit[i]);
      const pathTest = (activeOptions == null ? void 0 : activeOptions.exact) ? s.location.pathname === next.pathname : pathIsFuzzyEqual;
      const hashTest = (activeOptions == null ? void 0 : activeOptions.includeHash) ? s.location.hash === next.hash : true;
      const searchTest = (activeOptions == null ? void 0 : activeOptions.includeSearch) ?? true ? deepEqual(s.location.search, next.search, !(activeOptions == null ? void 0 : activeOptions.exact)) : true;
      return pathTest && hashTest && searchTest;
    }
  });
  const handleClick = (e) => {
    if (!disabled && !isCtrlEvent(e) && !e.defaultPrevented && (!target || target === "_self") && e.button === 0) {
      e.preventDefault();
      router.commitLocation({
        ...next,
        replace,
        resetScroll,
        startTransition
      });
    }
  };
  const handleFocus = (e) => {
    if (preload) {
      router.preloadRoute(dest).catch((err) => {
        console.warn(err);
        console.warn(preloadWarning);
      });
    }
  };
  const handleTouchStart = (e) => {
    if (preload) {
      router.preloadRoute(dest).catch((err) => {
        console.warn(err);
        console.warn(preloadWarning);
      });
    }
  };
  const handleEnter = (e) => {
    const target2 = e.target || {};
    if (preload) {
      if (target2.preloadTimeout) {
        return;
      }
      target2.preloadTimeout = setTimeout(() => {
        target2.preloadTimeout = null;
        router.preloadRoute(dest).catch((err) => {
          console.warn(err);
          console.warn(preloadWarning);
        });
      }, preloadDelay);
    }
  };
  const handleLeave = (e) => {
    const target2 = e.target || {};
    if (target2.preloadTimeout) {
      clearTimeout(target2.preloadTimeout);
      target2.preloadTimeout = null;
    }
  };
  const composeHandlers = (handlers) => (e) => {
    if (e.persist)
      e.persist();
    handlers.filter(Boolean).forEach((handler) => {
      if (e.defaultPrevented)
        return;
      handler(e);
    });
  };
  const resolvedActiveProps = isActive ? functionalUpdate(activeProps, {}) ?? {} : {};
  const resolvedInactiveProps = isActive ? {} : functionalUpdate(inactiveProps, {}) ?? {};
  return {
    ...resolvedActiveProps,
    ...resolvedInactiveProps,
    ...rest,
    href: disabled ? void 0 : next.maskedLocation ? next.maskedLocation.href : next.href,
    onClick: composeHandlers([onClick, handleClick]),
    onFocus: composeHandlers([onFocus, handleFocus]),
    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),
    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),
    onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),
    target,
    style: {
      ...style,
      ...resolvedActiveProps.style,
      ...resolvedInactiveProps.style
    },
    className: [className, resolvedActiveProps.className, resolvedInactiveProps.className].filter(Boolean).join(" ") || void 0,
    ...disabled ? {
      role: "link",
      "aria-disabled": true
    } : void 0,
    ["data-status"]: isActive ? "active" : void 0
  };
}
var Link = React.forwardRef((props, ref) => {
  const linkProps = useLinkProps(props);
  return React.createElement("a", _extends({
    ref
  }, linkProps, {
    children: typeof props.children === "function" ? props.children({
      isActive: linkProps["data-status"] === "active"
    }) : props.children
  }));
});
function isCtrlEvent(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
function encode(obj, pfx) {
  var k, i, tmp, str = "";
  for (k in obj) {
    if ((tmp = obj[k]) !== void 0) {
      if (Array.isArray(tmp)) {
        for (i = 0; i < tmp.length; i++) {
          str && (str += "&");
          str += encodeURIComponent(k) + "=" + encodeURIComponent(tmp[i]);
        }
      } else {
        str && (str += "&");
        str += encodeURIComponent(k) + "=" + encodeURIComponent(tmp);
      }
    }
  }
  return (pfx || "") + str;
}
function toValue(mix) {
  if (!mix)
    return "";
  var str = decodeURIComponent(mix);
  if (str === "false")
    return false;
  if (str === "true")
    return true;
  return +str * 0 === 0 && +str + "" === str ? +str : str;
}
function decode(str) {
  var tmp, k, out = {}, arr = str.split("&");
  while (tmp = arr.shift()) {
    tmp = tmp.split("=");
    k = tmp.shift();
    if (out[k] !== void 0) {
      out[k] = [].concat(out[k], toValue(tmp.shift()));
    } else {
      out[k] = toValue(tmp.shift());
    }
  }
  return out;
}
function redirect(opts) {
  opts.isRedirect = true;
  if (opts.throw) {
    throw opts;
  }
  return opts;
}
function isRedirect(obj) {
  return !!(obj == null ? void 0 : obj.isRedirect);
}
var defaultParseSearch = parseSearchWith(JSON.parse);
var defaultStringifySearch = stringifySearchWith(JSON.stringify, JSON.parse);
function parseSearchWith(parser) {
  return (searchStr) => {
    if (searchStr.substring(0, 1) === "?") {
      searchStr = searchStr.substring(1);
    }
    let query = decode(searchStr);
    for (let key in query) {
      const value = query[key];
      if (typeof value === "string") {
        try {
          query[key] = parser(value);
        } catch (err) {
        }
      }
    }
    return query;
  };
}
function stringifySearchWith(stringify, parser) {
  function stringifyValue(val) {
    if (typeof val === "object" && val !== null) {
      try {
        return stringify(val);
      } catch (err) {
      }
    } else if (typeof val === "string" && typeof parser === "function") {
      try {
        parser(val);
        return stringify(val);
      } catch (err) {
      }
    }
    return val;
  }
  return (search) => {
    search = {
      ...search
    };
    if (search) {
      Object.keys(search).forEach((key) => {
        const val = search[key];
        if (typeof val === "undefined" || val === void 0) {
          delete search[key];
        } else {
          search[key] = stringifyValue(val);
        }
      });
    }
    const searchStr = encode(search).toString();
    return searchStr ? `?${searchStr}` : "";
  };
}
var componentTypes = ["component", "errorComponent", "pendingComponent"];
var Router = class {
  // Must build in constructor
  constructor(options) {
    // Option-independent properties
    __publicField(this, "tempLocationKey", `${Math.round(Math.random() * 1e7)}`);
    __publicField(this, "resetNextScroll", true);
    __publicField(this, "navigateTimeout", null);
    __publicField(this, "latestLoadPromise", Promise.resolve());
    __publicField(this, "subscribers", /* @__PURE__ */ new Set());
    __publicField(this, "injectedHtml", []);
    // These are default implementations that can optionally be overridden
    // by the router provider once rendered. We provide these so that the
    // router can be used in a non-react environment if necessary
    __publicField(this, "startReactTransition", (fn) => fn());
    __publicField(this, "update", (newOptions) => {
      this.options = {
        ...this.options,
        ...newOptions
      };
      this.basepath = `/${trimPath(newOptions.basepath ?? "") ?? ""}`;
      if (!this.history || this.options.history && this.options.history !== this.history) {
        this.history = this.options.history ?? (typeof document !== "undefined" ? createBrowserHistory() : createMemoryHistory());
        this.latestLocation = this.parseLocation();
      }
      if (this.options.routeTree !== this.routeTree) {
        this.routeTree = this.options.routeTree;
        this.buildRouteTree();
      }
      if (!this.__store) {
        this.__store = new Store(getInitialRouterState(this.latestLocation), {
          onUpdate: () => {
            this.__store.state = {
              ...this.state,
              status: this.state.isTransitioning || this.state.isLoading ? "pending" : "idle"
            };
          }
        });
      }
    });
    __publicField(this, "buildRouteTree", () => {
      this.routesById = {};
      this.routesByPath = {};
      const notFoundRoute = this.options.notFoundRoute;
      if (notFoundRoute) {
        notFoundRoute.init({
          originalIndex: 99999999999
        });
        this.routesById[notFoundRoute.id] = notFoundRoute;
      }
      const recurseRoutes = (childRoutes) => {
        childRoutes.forEach((childRoute, i) => {
          childRoute.init({
            originalIndex: i
          });
          const existingRoute = this.routesById[childRoute.id];
          invariant(!existingRoute, `Duplicate routes found with id: ${String(childRoute.id)}`);
          this.routesById[childRoute.id] = childRoute;
          if (!childRoute.isRoot && childRoute.path) {
            const trimmedFullPath = trimPathRight(childRoute.fullPath);
            if (!this.routesByPath[trimmedFullPath] || childRoute.fullPath.endsWith("/")) {
              this.routesByPath[trimmedFullPath] = childRoute;
            }
          }
          const children = childRoute.children;
          if (children == null ? void 0 : children.length) {
            recurseRoutes(children);
          }
        });
      };
      recurseRoutes([this.routeTree]);
      const scoredRoutes = [];
      Object.values(this.routesById).forEach((d, i) => {
        var _a;
        if (d.isRoot || !d.path) {
          return;
        }
        const trimmed = trimPathLeft(d.fullPath);
        const parsed = parsePathname(trimmed);
        while (parsed.length > 1 && ((_a = parsed[0]) == null ? void 0 : _a.value) === "/") {
          parsed.shift();
        }
        const scores = parsed.map((d2) => {
          if (d2.value === "/") {
            return 0.75;
          }
          if (d2.type === "param") {
            return 0.5;
          }
          if (d2.type === "wildcard") {
            return 0.25;
          }
          return 1;
        });
        scoredRoutes.push({
          child: d,
          trimmed,
          parsed,
          index: i,
          scores
        });
      });
      this.flatRoutes = scoredRoutes.sort((a, b) => {
        const minLength = Math.min(a.scores.length, b.scores.length);
        for (let i = 0; i < minLength; i++) {
          if (a.scores[i] !== b.scores[i]) {
            return b.scores[i] - a.scores[i];
          }
        }
        if (a.scores.length !== b.scores.length) {
          return b.scores.length - a.scores.length;
        }
        for (let i = 0; i < minLength; i++) {
          if (a.parsed[i].value !== b.parsed[i].value) {
            return a.parsed[i].value > b.parsed[i].value ? 1 : -1;
          }
        }
        return a.index - b.index;
      }).map((d, i) => {
        d.child.rank = i;
        return d.child;
      });
    });
    __publicField(this, "subscribe", (eventType, fn) => {
      const listener = {
        eventType,
        fn
      };
      this.subscribers.add(listener);
      return () => {
        this.subscribers.delete(listener);
      };
    });
    __publicField(this, "emit", (routerEvent) => {
      this.subscribers.forEach((listener) => {
        if (listener.eventType === routerEvent.type) {
          listener.fn(routerEvent);
        }
      });
    });
    __publicField(this, "checkLatest", (promise) => {
      return this.latestLoadPromise !== promise ? this.latestLoadPromise : void 0;
    });
    __publicField(this, "parseLocation", (previousLocation) => {
      const parse = ({
        pathname,
        search,
        hash,
        state
      }) => {
        const parsedSearch = this.options.parseSearch(search);
        return {
          pathname,
          searchStr: search,
          search: replaceEqualDeep(previousLocation == null ? void 0 : previousLocation.search, parsedSearch),
          hash: hash.split("#").reverse()[0] ?? "",
          href: `${pathname}${search}${hash}`,
          state: replaceEqualDeep(previousLocation == null ? void 0 : previousLocation.state, state)
        };
      };
      const location = parse(this.history.location);
      let {
        __tempLocation,
        __tempKey
      } = location.state;
      if (__tempLocation && (!__tempKey || __tempKey === this.tempLocationKey)) {
        const parsedTempLocation = parse(__tempLocation);
        parsedTempLocation.state.key = location.state.key;
        delete parsedTempLocation.state.__tempLocation;
        return {
          ...parsedTempLocation,
          maskedLocation: location
        };
      }
      return location;
    });
    __publicField(this, "resolvePathWithBase", (from, path) => {
      return resolvePath(this.basepath, from, cleanPath(path));
    });
    __publicField(this, "matchRoutes", (pathname, locationSearch, opts) => {
      let routeParams = {};
      let foundRoute = this.flatRoutes.find((route) => {
        const matchedParams = matchPathname(this.basepath, trimPathRight(pathname), {
          to: route.fullPath,
          caseSensitive: route.options.caseSensitive ?? this.options.caseSensitive,
          fuzzy: true
        });
        if (matchedParams) {
          routeParams = matchedParams;
          return true;
        }
        return false;
      });
      let routeCursor = foundRoute || this.routesById["__root__"];
      let matchedRoutes = [routeCursor];
      if (
        // If we found a route, and it's not an index route and we have left over path
        (foundRoute ? foundRoute.path !== "/" && routeParams["**"] : (
          // Or if we didn't find a route and we have left over path
          trimPathRight(pathname)
        )) && // And we have a 404 route configured
        this.options.notFoundRoute
      ) {
        matchedRoutes.push(this.options.notFoundRoute);
      }
      while (routeCursor == null ? void 0 : routeCursor.parentRoute) {
        routeCursor = routeCursor.parentRoute;
        if (routeCursor)
          matchedRoutes.unshift(routeCursor);
      }
      const parseErrors = matchedRoutes.map((route) => {
        let parsedParamsError;
        if (route.options.parseParams) {
          try {
            const parsedParams = route.options.parseParams(routeParams);
            Object.assign(routeParams, parsedParams);
          } catch (err) {
            parsedParamsError = new PathParamError(err.message, {
              cause: err
            });
            if (opts == null ? void 0 : opts.throwOnError) {
              throw parsedParamsError;
            }
            return parsedParamsError;
          }
        }
        return;
      });
      const matches = [];
      matchedRoutes.forEach((route, index) => {
        var _a, _b;
        const parentMatch = matches[index - 1];
        const [preMatchSearch, searchError] = (() => {
          const parentSearch = (parentMatch == null ? void 0 : parentMatch.search) ?? locationSearch;
          try {
            const validator = typeof route.options.validateSearch === "object" ? route.options.validateSearch.parse : route.options.validateSearch;
            let search = (validator == null ? void 0 : validator(parentSearch)) ?? {};
            return [{
              ...parentSearch,
              ...search
            }, void 0];
          } catch (err) {
            const searchError2 = new SearchParamError(err.message, {
              cause: err
            });
            if (opts == null ? void 0 : opts.throwOnError) {
              throw searchError2;
            }
            return [parentSearch, searchError2];
          }
        })();
        const loaderDeps = ((_b = (_a = route.options).loaderDeps) == null ? void 0 : _b.call(_a, {
          search: preMatchSearch
        })) ?? "";
        const loaderDepsHash = loaderDeps ? JSON.stringify(loaderDeps) : "";
        const interpolatedPath = interpolatePath(route.fullPath, routeParams);
        const matchId = interpolatePath(route.id, routeParams, true) + loaderDepsHash;
        const existingMatch = getRouteMatch(this.state, matchId);
        const cause = this.state.matches.find((d) => d.id === matchId) ? "stay" : "enter";
        const hasLoaders = !!(route.options.loader || componentTypes.some((d) => {
          var _a2;
          return (_a2 = route.options[d]) == null ? void 0 : _a2.preload;
        }));
        const match = existingMatch ? {
          ...existingMatch,
          cause
        } : {
          id: matchId,
          routeId: route.id,
          params: routeParams,
          pathname: joinPaths([this.basepath, interpolatedPath]),
          updatedAt: Date.now(),
          search: {},
          searchError: void 0,
          status: hasLoaders ? "pending" : "success",
          showPending: false,
          isFetching: false,
          error: void 0,
          paramsError: parseErrors[index],
          loadPromise: Promise.resolve(),
          routeContext: void 0,
          context: void 0,
          abortController: new AbortController(),
          fetchCount: 0,
          cause,
          loaderDeps,
          invalid: false,
          preload: false
        };
        match.search = replaceEqualDeep(match.search, preMatchSearch);
        match.searchError = searchError;
        matches.push(match);
      });
      return matches;
    });
    __publicField(this, "cancelMatch", (id) => {
      var _a, _b;
      (_b = (_a = getRouteMatch(this.state, id)) == null ? void 0 : _a.abortController) == null ? void 0 : _b.abort();
    });
    __publicField(this, "cancelMatches", () => {
      var _a;
      (_a = this.state.pendingMatches) == null ? void 0 : _a.forEach((match) => {
        this.cancelMatch(match.id);
      });
    });
    __publicField(this, "buildLocation", (opts) => {
      const build = (dest = {}, matches) => {
        var _a, _b;
        const from = this.latestLocation;
        const fromSearch = ((_a = (this.state.pendingMatches || this.state.matches).at(-1)) == null ? void 0 : _a.search) || from.search;
        const fromPathname = dest.from ?? from.pathname;
        let pathname = this.resolvePathWithBase(fromPathname, `${dest.to ?? ""}`);
        const fromMatches = this.matchRoutes(fromPathname, fromSearch);
        const stayingMatches = matches == null ? void 0 : matches.filter((d) => fromMatches == null ? void 0 : fromMatches.find((e) => e.routeId === d.routeId));
        const prevParams = {
          ...(_b = last(fromMatches)) == null ? void 0 : _b.params
        };
        let nextParams = (dest.params ?? true) === true ? prevParams : functionalUpdate(dest.params, prevParams);
        if (nextParams) {
          matches == null ? void 0 : matches.map((d) => this.looseRoutesById[d.routeId].options.stringifyParams).filter(Boolean).forEach((fn) => {
            nextParams = {
              ...nextParams,
              ...fn(nextParams)
            };
          });
        }
        pathname = interpolatePath(pathname, nextParams ?? {});
        const preSearchFilters = (stayingMatches == null ? void 0 : stayingMatches.map((match) => this.looseRoutesById[match.routeId].options.preSearchFilters ?? []).flat().filter(Boolean)) ?? [];
        const postSearchFilters = (stayingMatches == null ? void 0 : stayingMatches.map((match) => this.looseRoutesById[match.routeId].options.postSearchFilters ?? []).flat().filter(Boolean)) ?? [];
        const preFilteredSearch = (preSearchFilters == null ? void 0 : preSearchFilters.length) ? preSearchFilters == null ? void 0 : preSearchFilters.reduce((prev, next) => next(prev), fromSearch) : fromSearch;
        const destSearch = dest.search === true ? preFilteredSearch : dest.search ? functionalUpdate(dest.search, preFilteredSearch) ?? {} : (preSearchFilters == null ? void 0 : preSearchFilters.length) ? preFilteredSearch : {};
        const postFilteredSearch = (postSearchFilters == null ? void 0 : postSearchFilters.length) ? postSearchFilters.reduce((prev, next) => next(prev), destSearch) : destSearch;
        const search = replaceEqualDeep(fromSearch, postFilteredSearch);
        const searchStr = this.options.stringifySearch(search);
        const hash = dest.hash === true ? from.hash : dest.hash ? functionalUpdate(dest.hash, from.hash) : from.hash;
        const hashStr = hash ? `#${hash}` : "";
        let nextState = dest.state === true ? from.state : dest.state ? functionalUpdate(dest.state, from.state) : from.state;
        nextState = replaceEqualDeep(from.state, nextState);
        return {
          pathname,
          search,
          searchStr,
          state: nextState,
          hash,
          href: `${pathname}${searchStr}${hashStr}`,
          unmaskOnReload: dest.unmaskOnReload
        };
      };
      const buildWithMatches = (dest = {}, maskedDest) => {
        var _a;
        let next = build(dest);
        let maskedNext = maskedDest ? build(maskedDest) : void 0;
        if (!maskedNext) {
          let params = {};
          let foundMask = (_a = this.options.routeMasks) == null ? void 0 : _a.find((d) => {
            const match = matchPathname(this.basepath, next.pathname, {
              to: d.from,
              caseSensitive: false,
              fuzzy: false
            });
            if (match) {
              params = match;
              return true;
            }
            return false;
          });
          if (foundMask) {
            foundMask = {
              ...foundMask,
              from: interpolatePath(foundMask.from, params)
            };
            maskedDest = foundMask;
            maskedNext = build(maskedDest);
          }
        }
        const nextMatches = this.matchRoutes(next.pathname, next.search);
        const maskedMatches = maskedNext ? this.matchRoutes(maskedNext.pathname, maskedNext.search) : void 0;
        const maskedFinal = maskedNext ? build(maskedDest, maskedMatches) : void 0;
        const final = build(dest, nextMatches);
        if (maskedFinal) {
          final.maskedLocation = maskedFinal;
        }
        return final;
      };
      if (opts.mask) {
        return buildWithMatches(opts, {
          ...pick(opts, ["from"]),
          ...opts.mask
        });
      }
      return buildWithMatches(opts);
    });
    __publicField(this, "commitLocation", async ({
      startTransition,
      ...next
    }) => {
      if (this.navigateTimeout)
        clearTimeout(this.navigateTimeout);
      const isSameUrl = this.latestLocation.href === next.href;
      if (!isSameUrl || !next.replace) {
        let {
          maskedLocation,
          ...nextHistory
        } = next;
        if (maskedLocation) {
          nextHistory = {
            ...maskedLocation,
            state: {
              ...maskedLocation.state,
              __tempKey: void 0,
              __tempLocation: {
                ...nextHistory,
                search: nextHistory.searchStr,
                state: {
                  ...nextHistory.state,
                  __tempKey: void 0,
                  __tempLocation: void 0,
                  key: void 0
                }
              }
            }
          };
          if (nextHistory.unmaskOnReload ?? this.options.unmaskOnReload ?? false) {
            nextHistory.state.__tempKey = this.tempLocationKey;
          }
        }
        const apply = () => {
          this.history[next.replace ? "replace" : "push"](nextHistory.href, nextHistory.state);
        };
        if (startTransition ?? true) {
          this.startReactTransition(apply);
        } else {
          apply();
        }
      }
      this.resetNextScroll = next.resetScroll ?? true;
      return this.latestLoadPromise;
    });
    __publicField(this, "buildAndCommitLocation", ({
      replace,
      resetScroll,
      startTransition,
      ...rest
    } = {}) => {
      const location = this.buildLocation(rest);
      return this.commitLocation({
        ...location,
        startTransition,
        replace,
        resetScroll
      });
    });
    __publicField(this, "navigate", ({
      from,
      to = "",
      ...rest
    }) => {
      const toString = String(to);
      const fromString = typeof from === "undefined" ? from : String(from);
      let isExternal;
      try {
        new URL(`${toString}`);
        isExternal = true;
      } catch (e) {
      }
      invariant(!isExternal, "Attempting to navigate to external url with this.navigate!");
      return this.buildAndCommitLocation({
        ...rest,
        from: fromString,
        to: toString
      });
    });
    __publicField(this, "loadMatches", async ({
      checkLatest,
      matches,
      preload
    }) => {
      var _a, _b;
      let latestPromise;
      let firstBadMatchIndex;
      const updateMatch = (match) => {
        var _a2;
        const isPending = (_a2 = this.state.pendingMatches) == null ? void 0 : _a2.find((d) => d.id === match.id);
        const isMatched = this.state.matches.find((d) => d.id === match.id);
        const matchesKey = isPending ? "pendingMatches" : isMatched ? "matches" : "cachedMatches";
        this.__store.setState((s) => {
          var _a3;
          return {
            ...s,
            [matchesKey]: (_a3 = s[matchesKey]) == null ? void 0 : _a3.map((d) => d.id === match.id ? match : d)
          };
        });
      };
      try {
        for (let [index, match] of matches.entries()) {
          const parentMatch = matches[index - 1];
          const route = this.looseRoutesById[match.routeId];
          const abortController = new AbortController();
          const handleErrorAndRedirect = (err, code) => {
            var _a2, _b2;
            err.routerCode = code;
            firstBadMatchIndex = firstBadMatchIndex ?? index;
            if (isRedirect(err)) {
              throw err;
            }
            try {
              (_b2 = (_a2 = route.options).onError) == null ? void 0 : _b2.call(_a2, err);
            } catch (errorHandlerErr) {
              err = errorHandlerErr;
              if (isRedirect(errorHandlerErr)) {
                throw errorHandlerErr;
              }
            }
            matches[index] = match = {
              ...match,
              error: err,
              status: "error",
              updatedAt: Date.now(),
              abortController: new AbortController()
            };
          };
          try {
            if (match.paramsError) {
              handleErrorAndRedirect(match.paramsError, "PARSE_PARAMS");
            }
            if (match.searchError) {
              handleErrorAndRedirect(match.searchError, "VALIDATE_SEARCH");
            }
            const parentContext = (parentMatch == null ? void 0 : parentMatch.context) ?? this.options.context ?? {};
            const beforeLoadContext = await ((_b = (_a = route.options).beforeLoad) == null ? void 0 : _b.call(_a, {
              search: match.search,
              abortController,
              params: match.params,
              preload: !!preload,
              context: parentContext,
              location: this.state.location,
              // TOOD: just expose state and router, etc
              navigate: (opts) => this.navigate({
                ...opts,
                from: match.pathname
              }),
              buildLocation: this.buildLocation,
              cause: preload ? "preload" : match.cause
            })) ?? {};
            if (isRedirect(beforeLoadContext)) {
              throw beforeLoadContext;
            }
            const context = {
              ...parentContext,
              ...beforeLoadContext
            };
            matches[index] = match = {
              ...match,
              routeContext: replaceEqualDeep(match.routeContext, beforeLoadContext),
              context: replaceEqualDeep(match.context, context),
              abortController
            };
          } catch (err) {
            handleErrorAndRedirect(err, "BEFORE_LOAD");
            break;
          }
        }
      } catch (err) {
        if (isRedirect(err)) {
          if (!preload)
            this.navigate(err);
          return matches;
        }
        throw err;
      }
      const validResolvedMatches = matches.slice(0, firstBadMatchIndex);
      const matchPromises = [];
      validResolvedMatches.forEach((match, index) => {
        matchPromises.push(new Promise(async (resolve) => {
          const parentMatchPromise = matchPromises[index - 1];
          const route = this.looseRoutesById[match.routeId];
          const handleErrorAndRedirect = (err) => {
            if (isRedirect(err)) {
              if (!preload) {
                this.navigate(err);
              }
              return true;
            }
            return false;
          };
          let loadPromise;
          matches[index] = match = {
            ...match,
            showPending: false
          };
          let didShowPending = false;
          const pendingMs = route.options.pendingMs ?? this.options.defaultPendingMs;
          const pendingMinMs = route.options.pendingMinMs ?? this.options.defaultPendingMinMs;
          const shouldPending = !preload && pendingMs && (route.options.pendingComponent ?? this.options.defaultPendingComponent);
          const loaderContext = {
            params: match.params,
            deps: match.loaderDeps,
            preload: !!preload,
            parentMatchPromise,
            abortController: match.abortController,
            context: match.context,
            location: this.state.location,
            navigate: (opts) => this.navigate({
              ...opts,
              from: match.pathname
            }),
            cause: preload ? "preload" : match.cause
          };
          const fetch = async () => {
            var _a2, _b2, _c, _d, _e;
            if (match.isFetching) {
              loadPromise = (_a2 = getRouteMatch(this.state, match.id)) == null ? void 0 : _a2.loadPromise;
            } else {
              if (match.fetchCount && match.status === "success") {
                resolve();
              }
              matches[index] = match = {
                ...match,
                isFetching: true,
                fetchCount: match.fetchCount + 1
              };
              const componentsPromise = Promise.all(componentTypes.map(async (type) => {
                const component = route.options[type];
                if (component == null ? void 0 : component.preload) {
                  await component.preload();
                }
              }));
              const loaderPromise = (_c = (_b2 = route.options).loader) == null ? void 0 : _c.call(_b2, loaderContext);
              loadPromise = Promise.all([componentsPromise, loaderPromise]).then((d) => d[1]);
            }
            matches[index] = match = {
              ...match,
              loadPromise
            };
            updateMatch(match);
            try {
              const loaderData = await loadPromise;
              if (latestPromise = checkLatest())
                return await latestPromise;
              if (isRedirect(loaderData)) {
                if (handleErrorAndRedirect(loaderData))
                  return;
              }
              if (didShowPending && pendingMinMs) {
                await new Promise((r) => setTimeout(r, pendingMinMs));
              }
              if (latestPromise = checkLatest())
                return await latestPromise;
              matches[index] = match = {
                ...match,
                error: void 0,
                status: "success",
                isFetching: false,
                updatedAt: Date.now(),
                loaderData,
                loadPromise: void 0
              };
            } catch (error) {
              if (latestPromise = checkLatest())
                return await latestPromise;
              if (handleErrorAndRedirect(error))
                return;
              try {
                (_e = (_d = route.options).onError) == null ? void 0 : _e.call(_d, error);
              } catch (onErrorError) {
                error = onErrorError;
                if (handleErrorAndRedirect(onErrorError))
                  return;
              }
              matches[index] = match = {
                ...match,
                error,
                status: "error",
                isFetching: false
              };
            }
            updateMatch(match);
          };
          const age = Date.now() - match.updatedAt;
          let staleAge = preload ? route.options.preloadStaleTime ?? this.options.defaultPreloadStaleTime ?? 3e4 : route.options.staleTime ?? this.options.defaultStaleTime ?? 0;
          let shouldReload;
          const shouldReloadOption = route.options.shouldReload;
          shouldReload = typeof shouldReloadOption === "function" ? shouldReloadOption(loaderContext) : shouldReloadOption;
          matches[index] = match = {
            ...match,
            preload: !!preload && !this.state.matches.find((d) => d.id === match.id)
          };
          if (match.status !== "success") {
            if (shouldPending) {
              new Promise((r) => setTimeout(r, pendingMs)).then(async () => {
                if (latestPromise = checkLatest())
                  return latestPromise;
                didShowPending = true;
                matches[index] = match = {
                  ...match,
                  showPending: true
                };
                updateMatch(match);
                resolve();
              });
            }
            await fetch();
          } else if (match.invalid || (shouldReload ?? age > staleAge)) {
            fetch();
          }
          resolve();
        }));
      });
      await Promise.all(matchPromises);
      return matches;
    });
    __publicField(this, "invalidate", () => {
      const invalidate = (d) => ({
        ...d,
        invalid: true
      });
      this.__store.setState((s) => {
        var _a;
        return {
          ...s,
          matches: s.matches.map(invalidate),
          cachedMatches: s.cachedMatches.map(invalidate),
          pendingMatches: (_a = s.pendingMatches) == null ? void 0 : _a.map(invalidate)
        };
      });
      this.load();
    });
    __publicField(this, "load", async () => {
      const promise = new Promise(async (resolve, reject) => {
        const next = this.latestLocation;
        const prevLocation = this.state.resolvedLocation;
        const pathDidChange = prevLocation.href !== next.href;
        let latestPromise;
        this.cancelMatches();
        this.emit({
          type: "onBeforeLoad",
          fromLocation: prevLocation,
          toLocation: next,
          pathChanged: pathDidChange
        });
        let pendingMatches;
        const previousMatches = this.state.matches;
        this.__store.batch(() => {
          this.cleanCache();
          pendingMatches = this.matchRoutes(next.pathname, next.search, {
            debug: true
          });
          this.__store.setState((s) => ({
            ...s,
            isLoading: true,
            location: next,
            pendingMatches,
            cachedMatches: s.cachedMatches.filter((d) => {
              return !pendingMatches.find((e) => e.id === d.id);
            })
          }));
        });
        try {
          try {
            await this.loadMatches({
              matches: pendingMatches,
              checkLatest: () => this.checkLatest(promise)
            });
          } catch (err) {
          }
          if (latestPromise = this.checkLatest(promise)) {
            return latestPromise;
          }
          const exitingMatches = previousMatches.filter((match) => !pendingMatches.find((d) => d.id === match.id));
          const enteringMatches = pendingMatches.filter((match) => !previousMatches.find((d) => d.id === match.id));
          const stayingMatches = previousMatches.filter((match) => pendingMatches.find((d) => d.id === match.id));
          this.__store.batch(() => {
            this.__store.setState((s) => ({
              ...s,
              isLoading: false,
              matches: s.pendingMatches,
              pendingMatches: void 0,
              cachedMatches: [...s.cachedMatches, ...exitingMatches.filter((d) => d.status !== "error")]
            }));
            this.cleanCache();
          });
          [[exitingMatches, "onLeave"], [enteringMatches, "onEnter"], [stayingMatches, "onStay"]].forEach(([matches, hook]) => {
            matches.forEach((match) => {
              var _a, _b;
              (_b = (_a = this.looseRoutesById[match.routeId].options)[hook]) == null ? void 0 : _b.call(_a, match);
            });
          });
          this.emit({
            type: "onLoad",
            fromLocation: prevLocation,
            toLocation: next,
            pathChanged: pathDidChange
          });
          resolve();
        } catch (err) {
          if (latestPromise = this.checkLatest(promise)) {
            return latestPromise;
          }
          reject(err);
        }
      });
      this.latestLoadPromise = promise;
      return this.latestLoadPromise;
    });
    __publicField(this, "cleanCache", () => {
      this.__store.setState((s) => {
        return {
          ...s,
          cachedMatches: s.cachedMatches.filter((d) => {
            const route = this.looseRoutesById[d.routeId];
            if (!route.options.loader) {
              return false;
            }
            const gcTime = (d.preload ? route.options.preloadGcTime ?? this.options.defaultPreloadGcTime : route.options.gcTime ?? this.options.defaultGcTime) ?? 5 * 60 * 1e3;
            return d.status !== "error" && Date.now() - d.updatedAt < gcTime;
          })
        };
      });
    });
    __publicField(this, "preloadRoute", async (navigateOpts = this.state.location) => {
      var _a;
      let next = this.buildLocation(navigateOpts);
      let matches = this.matchRoutes(next.pathname, next.search, {
        throwOnError: true
      });
      const loadedMatchIds = Object.fromEntries((_a = [...this.state.matches, ...this.state.pendingMatches ?? [], ...this.state.cachedMatches]) == null ? void 0 : _a.map((d) => [d.id, true]));
      this.__store.batch(() => {
        matches.forEach((match) => {
          if (!loadedMatchIds[match.id]) {
            this.__store.setState((s) => ({
              ...s,
              cachedMatches: [...s.cachedMatches, match]
            }));
          }
        });
      });
      matches = await this.loadMatches({
        matches,
        preload: true,
        checkLatest: () => void 0
      });
      return matches;
    });
    __publicField(this, "matchRoute", (location, opts) => {
      location = {
        ...location,
        to: location.to ? this.resolvePathWithBase(location.from || "", location.to) : void 0
      };
      const next = this.buildLocation(location);
      if ((opts == null ? void 0 : opts.pending) && this.state.status !== "pending") {
        return false;
      }
      const baseLocation = (opts == null ? void 0 : opts.pending) ? this.latestLocation : this.state.resolvedLocation;
      if (!baseLocation) {
        return false;
      }
      const match = matchPathname(this.basepath, baseLocation.pathname, {
        ...opts,
        to: next.pathname
      });
      if (!match) {
        return false;
      }
      if (match && ((opts == null ? void 0 : opts.includeSearch) ?? true)) {
        return deepEqual(baseLocation.search, next.search, true) ? match : false;
      }
      return match;
    });
    __publicField(this, "injectHtml", async (html) => {
      this.injectedHtml.push(html);
    });
    __publicField(this, "dehydrateData", (key, getData) => {
      if (typeof document === "undefined") {
        const strKey = typeof key === "string" ? key : JSON.stringify(key);
        this.injectHtml(async () => {
          const id = `__TSR_DEHYDRATED__${strKey}`;
          const data = typeof getData === "function" ? await getData() : getData;
          return `<script id='${id}' suppressHydrationWarning>window["__TSR_DEHYDRATED__${escapeJSON(strKey)}"] = ${JSON.stringify(data)}
          ;(() => {
            var el = document.getElementById('${id}')
            el.parentElement.removeChild(el)
          })()
          <\/script>`;
        });
        return () => this.hydrateData(key);
      }
      return () => void 0;
    });
    __publicField(this, "hydrateData", (key) => {
      if (typeof document !== "undefined") {
        const strKey = typeof key === "string" ? key : JSON.stringify(key);
        return window[`__TSR_DEHYDRATED__${strKey}`];
      }
      return void 0;
    });
    __publicField(this, "dehydrate", () => {
      return {
        state: {
          dehydratedMatches: this.state.matches.map((d) => pick(d, ["id", "status", "updatedAt", "loaderData"]))
        }
      };
    });
    __publicField(this, "hydrate", async (__do_not_use_server_ctx) => {
      var _a, _b;
      let _ctx = __do_not_use_server_ctx;
      if (typeof document !== "undefined") {
        _ctx = window.__TSR_DEHYDRATED__;
      }
      invariant(_ctx, "Expected to find a __TSR_DEHYDRATED__ property on window... but we did not. Did you forget to render <DehydrateRouter /> in your app?");
      const ctx = _ctx;
      this.dehydratedData = ctx.payload;
      (_b = (_a = this.options).hydrate) == null ? void 0 : _b.call(_a, ctx.payload);
      const dehydratedState = ctx.router.state;
      let matches = this.matchRoutes(this.state.location.pathname, this.state.location.search).map((match) => {
        const dehydratedMatch = dehydratedState.dehydratedMatches.find((d) => d.id === match.id);
        invariant(dehydratedMatch, `Could not find a client-side match for dehydrated match with id: ${match.id}!`);
        if (dehydratedMatch) {
          return {
            ...match,
            ...dehydratedMatch
          };
        }
        return match;
      });
      this.__store.setState((s) => {
        return {
          ...s,
          matches
        };
      });
    });
    this.update({
      defaultPreloadDelay: 50,
      defaultPendingMs: 1e3,
      defaultPendingMinMs: 500,
      context: void 0,
      ...options,
      stringifySearch: (options == null ? void 0 : options.stringifySearch) ?? defaultStringifySearch,
      parseSearch: (options == null ? void 0 : options.parseSearch) ?? defaultParseSearch
    });
  }
  get state() {
    return this.__store.state;
  }
  get looseRoutesById() {
    return this.routesById;
  }
  // resolveMatchPromise = (matchId: string, key: string, value: any) => {
  //   state.matches
  //     .find((d) => d.id === matchId)
  //     ?.__promisesByKey[key]?.resolve(value)
  // }
};
function lazyFn(fn, key) {
  return async (...args) => {
    const imported = await fn();
    return imported[key || "default"](...args);
  };
}
var SearchParamError = class extends Error {
};
var PathParamError = class extends Error {
};
function getInitialRouterState(location) {
  return {
    isLoading: false,
    isTransitioning: false,
    status: "idle",
    resolvedLocation: {
      ...location
    },
    location,
    matches: [],
    pendingMatches: [],
    cachedMatches: [],
    lastUpdated: Date.now()
  };
}
var useLayoutEffect2 = typeof window !== "undefined" ? React.useLayoutEffect : React.useEffect;
var windowKey = "window";
var delimiter = "___";
var weakScrolledElements = /* @__PURE__ */ new WeakSet();
var sessionsStorage = typeof window !== "undefined" && window.sessionStorage;
var cache = sessionsStorage ? (() => {
  const storageKey = "tsr-scroll-restoration-v2";
  const state = JSON.parse(window.sessionStorage.getItem(storageKey) || "null") || {
    cached: {},
    next: {}
  };
  return {
    state,
    set: (updater) => {
      cache.state = functionalUpdate(updater, cache.state);
      window.sessionStorage.setItem(storageKey, JSON.stringify(cache.state));
    }
  };
})() : void 0;
var defaultGetKey = (location) => location.state.key;
function useScrollRestoration(options) {
  const router = useRouter();
  useLayoutEffect2(() => {
    const getKey = (options == null ? void 0 : options.getKey) || defaultGetKey;
    const {
      history
    } = window;
    if (history.scrollRestoration) {
      history.scrollRestoration = "manual";
    }
    const onScroll = (event) => {
      if (weakScrolledElements.has(event.target))
        return;
      weakScrolledElements.add(event.target);
      let elementSelector = "";
      if (event.target === document || event.target === window) {
        elementSelector = windowKey;
      } else {
        const attrId = event.target.getAttribute("data-scroll-restoration-id");
        if (attrId) {
          elementSelector = `[data-scroll-restoration-id="${attrId}"]`;
        } else {
          elementSelector = getCssSelector(event.target);
        }
      }
      if (!cache.state.next[elementSelector]) {
        cache.set((c) => ({
          ...c,
          next: {
            ...c.next,
            [elementSelector]: {
              scrollX: NaN,
              scrollY: NaN
            }
          }
        }));
      }
    };
    if (typeof document !== "undefined") {
      document.addEventListener("scroll", onScroll, true);
    }
    const unsubOnBeforeLoad = router.subscribe("onBeforeLoad", (event) => {
      if (event.pathChanged) {
        const restoreKey = getKey(event.fromLocation);
        for (const elementSelector in cache.state.next) {
          const entry = cache.state.next[elementSelector];
          if (elementSelector === windowKey) {
            entry.scrollX = window.scrollX || 0;
            entry.scrollY = window.scrollY || 0;
          } else if (elementSelector) {
            const element = document.querySelector(elementSelector);
            entry.scrollX = (element == null ? void 0 : element.scrollLeft) || 0;
            entry.scrollY = (element == null ? void 0 : element.scrollTop) || 0;
          }
          cache.set((c) => {
            const next = {
              ...c.next
            };
            delete next[elementSelector];
            return {
              ...c,
              next,
              cached: {
                ...c.cached,
                [[restoreKey, elementSelector].join(delimiter)]: entry
              }
            };
          });
        }
      }
    });
    const unsubOnResolved = router.subscribe("onResolved", (event) => {
      if (event.pathChanged) {
        if (!router.resetNextScroll) {
          return;
        }
        router.resetNextScroll = true;
        const getKey2 = (options == null ? void 0 : options.getKey) || defaultGetKey;
        const restoreKey = getKey2(event.toLocation);
        let windowRestored = false;
        for (const cacheKey in cache.state.cached) {
          const entry = cache.state.cached[cacheKey];
          const [key, elementSelector] = cacheKey.split(delimiter);
          if (key === restoreKey) {
            if (elementSelector === windowKey) {
              windowRestored = true;
              window.scrollTo(entry.scrollX, entry.scrollY);
            } else if (elementSelector) {
              const element = document.querySelector(elementSelector);
              if (element) {
                element.scrollLeft = entry.scrollX;
                element.scrollTop = entry.scrollY;
              }
            }
          }
        }
        if (!windowRestored) {
          window.scrollTo(0, 0);
        }
        cache.set((c) => ({
          ...c,
          next: {}
        }));
        weakScrolledElements = /* @__PURE__ */ new WeakSet();
      }
    });
    return () => {
      document.removeEventListener("scroll", onScroll);
      unsubOnBeforeLoad();
      unsubOnResolved();
    };
  }, []);
}
function ScrollRestoration(props) {
  useScrollRestoration(props);
  return null;
}
function useElementScrollRestoration(options) {
  var _a;
  const router = useRouter();
  const getKey = (options == null ? void 0 : options.getKey) || defaultGetKey;
  let elementSelector = "";
  if (options.id) {
    elementSelector = `[data-scroll-restoration-id="${options.id}"]`;
  } else {
    const element = (_a = options.getElement) == null ? void 0 : _a.call(options);
    if (!element) {
      return;
    }
    elementSelector = getCssSelector(element);
  }
  const restoreKey = getKey(router.latestLocation);
  const cacheKey = [restoreKey, elementSelector].join(delimiter);
  return cache.state.cached[cacheKey];
}
function getCssSelector(el) {
  let path = [], parent;
  while (parent = el.parentNode) {
    path.unshift(`${el.tagName}:nth-child(${[].indexOf.call(parent.children, el) + 1})`);
    el = parent;
  }
  return `${path.join(" > ")}`.toLowerCase();
}
function useBlocker(blockerFn, condition = true) {
  const {
    history
  } = useRouter();
  React.useEffect(() => {
    if (!condition)
      return;
    return history.block(blockerFn);
  });
}
function Block({
  blocker,
  condition,
  children
}) {
  useBlocker(blocker, condition);
  return children ?? null;
}
function useNavigate(defaultOpts) {
  const {
    navigate
  } = useRouter();
  const matchPathname2 = useMatch({
    strict: false,
    select: (s) => s.pathname
  });
  return React.useCallback((opts) => {
    return navigate({
      from: (opts == null ? void 0 : opts.to) ? matchPathname2 : void 0,
      ...defaultOpts,
      ...opts
    });
  }, []);
}
function Navigate(props) {
  const {
    navigate
  } = useRouter();
  const match = useMatch({
    strict: false
  });
  React.useEffect(() => {
    navigate({
      from: props.to ? match.pathname : void 0,
      ...props
    });
  }, []);
  return null;
}

export {
  createHistory,
  createBrowserHistory,
  createHashHistory,
  createMemoryHistory,
  invariant,
  tiny_warning_esm_default,
  CatchBoundary,
  CatchBoundaryImpl,
  ErrorComponent,
  isServer,
  last,
  functionalUpdate,
  pick,
  replaceEqualDeep,
  isPlainObject,
  deepEqual,
  useStableCallback,
  shallow2 as shallow,
  useRouteContext,
  useLayoutEffect$1,
  escapeJSON,
  matchContext,
  Matches,
  Match,
  Outlet,
  useMatchRoute,
  MatchRoute,
  useMatch,
  useMatches,
  useParentMatches,
  useLoaderDeps,
  useLoaderData,
  routerContext,
  RouterProvider,
  getRouteMatch,
  useRouterState,
  useRouter,
  defer,
  isDehydratedDeferred,
  useAwaited,
  Await,
  joinPaths,
  cleanPath,
  trimPathLeft,
  trimPathRight,
  trimPath,
  resolvePath,
  parsePathname,
  interpolatePath,
  matchPathname,
  removeBasepath,
  matchByPath,
  useParams,
  useSearch,
  rootRouteId,
  RouteApi,
  Route,
  rootRouteWithContext,
  RootRoute,
  createRouteMask,
  NotFoundRoute,
  FileRoute,
  lazyRouteComponent,
  useLinkProps,
  Link,
  encode,
  decode,
  redirect,
  isRedirect,
  defaultParseSearch,
  defaultStringifySearch,
  parseSearchWith,
  stringifySearchWith,
  componentTypes,
  Router,
  lazyFn,
  SearchParamError,
  PathParamError,
  getInitialRouterState,
  useScrollRestoration,
  ScrollRestoration,
  useElementScrollRestoration,
  useBlocker,
  Block,
  useNavigate,
  Navigate
};
/*! Bundled license information:

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@tanstack/history/build/esm/index.js:
  (**
   * @tanstack/history/src/index.ts
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@tanstack/react-router/build/esm/index.js:
  (**
   * @tanstack/react-router/src/index.tsx
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)
*/
//# sourceMappingURL=chunk-HNUNY4VC.js.map
