{
  "version": 3,
  "sources": ["../../use-sync-external-store/cjs/use-sync-external-store-shim.development.js", "../../use-sync-external-store/shim/index.js", "../../use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js", "../../use-sync-external-store/shim/with-selector.js", "../../@tanstack/history/src/index.ts", "../../tiny-invariant/dist/esm/tiny-invariant.js", "../../tiny-warning/dist/tiny-warning.esm.js", "../../@tanstack/react-store/src/index.ts", "../../@tanstack/store/src/index.ts", "../../@tanstack/react-router/src/CatchBoundary.tsx", "../../@tanstack/react-router/src/utils.ts", "../../@tanstack/react-router/src/Matches.tsx", "../../@tanstack/react-router/src/RouterProvider.tsx", "../../@tanstack/react-router/src/defer.ts", "../../@tanstack/react-router/src/awaited.tsx", "../../@tanstack/react-router/src/path.ts", "../../@tanstack/react-router/src/useParams.tsx", "../../@tanstack/react-router/src/useSearch.tsx", "../../@tanstack/react-router/src/route.ts", "../../@tanstack/react-router/src/fileRoute.ts", "../../@tanstack/react-router/src/lazyRouteComponent.tsx", "../../@tanstack/react-router/src/link.tsx", "../../@tanstack/react-router/src/qss.ts", "../../@tanstack/react-router/src/redirects.ts", "../../@tanstack/react-router/src/searchParams.ts", "../../@tanstack/react-router/src/router.ts", "../../@tanstack/react-router/src/scroll-restoration.tsx", "../../@tanstack/react-router/src/useBlocker.tsx", "../../@tanstack/react-router/src/useNavigate.tsx"],
  "sourcesContent": ["/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n\n          'use strict';\n\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n}\n          var React = require('react');\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n  ;\n}\n\nvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\n// dispatch for CommonJS interop named imports.\n\nvar useState = React.useState,\n    useEffect = React.useEffect,\n    useLayoutEffect = React.useLayoutEffect,\n    useDebugValue = React.useDebugValue;\nvar didWarnOld18Alpha = false;\nvar didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works\n// because of a very particular set of implementation details and assumptions\n// -- change any one of them and it will break. The most important assumption\n// is that updates are always synchronous, because concurrent rendering is\n// only available in versions of React that also have a built-in\n// useSyncExternalStore API. And we only use this shim when the built-in API\n// does not exist.\n//\n// Do not assume that the clever hacks used by this hook also work in general.\n// The point of this shim is to replace the need for hacks by other libraries.\n\nfunction useSyncExternalStore(subscribe, getSnapshot, // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n// React do not expose a way to check if we're hydrating. So users of the shim\n// will need to track that themselves and return the correct value\n// from `getSnapshot`.\ngetServerSnapshot) {\n  {\n    if (!didWarnOld18Alpha) {\n      if (React.startTransition !== undefined) {\n        didWarnOld18Alpha = true;\n\n        error('You are using an outdated, pre-release alpha of React 18 that ' + 'does not support useSyncExternalStore. The ' + 'use-sync-external-store shim will not work correctly. Upgrade ' + 'to a newer pre-release.');\n      }\n    }\n  } // Read the current snapshot from the store on every render. Again, this\n  // breaks the rules of React, and only works here because of specific\n  // implementation details, most importantly that updates are\n  // always synchronous.\n\n\n  var value = getSnapshot();\n\n  {\n    if (!didWarnUncachedGetSnapshot) {\n      var cachedValue = getSnapshot();\n\n      if (!objectIs(value, cachedValue)) {\n        error('The result of getSnapshot should be cached to avoid an infinite loop');\n\n        didWarnUncachedGetSnapshot = true;\n      }\n    }\n  } // Because updates are synchronous, we don't queue them. Instead we force a\n  // re-render whenever the subscribed state changes by updating an some\n  // arbitrary useState hook. Then, during render, we call getSnapshot to read\n  // the current value.\n  //\n  // Because we don't actually use the state returned by the useState hook, we\n  // can save a bit of memory by storing other stuff in that slot.\n  //\n  // To implement the early bailout, we need to track some things on a mutable\n  // object. Usually, we would put that in a useRef hook, but we can stash it in\n  // our useState hook instead.\n  //\n  // To force a re-render, we call forceUpdate({inst}). That works because the\n  // new object always fails an equality check.\n\n\n  var _useState = useState({\n    inst: {\n      value: value,\n      getSnapshot: getSnapshot\n    }\n  }),\n      inst = _useState[0].inst,\n      forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated\n  // in the layout phase so we can access it during the tearing check that\n  // happens on subscribe.\n\n\n  useLayoutEffect(function () {\n    inst.value = value;\n    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the\n    // commit phase if there was an interleaved mutation. In concurrent mode\n    // this can happen all the time, but even in synchronous mode, an earlier\n    // effect may have mutated the store.\n\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({\n        inst: inst\n      });\n    }\n  }, [subscribe, value, getSnapshot]);\n  useEffect(function () {\n    // Check for changes right before subscribing. Subsequent changes will be\n    // detected in the subscription handler.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({\n        inst: inst\n      });\n    }\n\n    var handleStoreChange = function () {\n      // TODO: Because there is no cross-renderer API for batching updates, it's\n      // up to the consumer of this library to wrap their subscription event\n      // with unstable_batchedUpdates. Should we try to detect when this isn't\n      // the case and print a warning in development?\n      // The store changed. Check if the snapshot changed since the last time we\n      // read from the store.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({\n          inst: inst\n        });\n      }\n    }; // Subscribe to the store and return a clean-up function.\n\n\n    return subscribe(handleStoreChange);\n  }, [subscribe]);\n  useDebugValue(value);\n  return value;\n}\n\nfunction checkIfSnapshotChanged(inst) {\n  var latestGetSnapshot = inst.getSnapshot;\n  var prevValue = inst.value;\n\n  try {\n    var nextValue = latestGetSnapshot();\n    return !objectIs(prevValue, nextValue);\n  } catch (error) {\n    return true;\n  }\n}\n\nfunction useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\n  // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n  // React do not expose a way to check if we're hydrating. So users of the shim\n  // will need to track that themselves and return the correct value\n  // from `getSnapshot`.\n  return getSnapshot();\n}\n\nvar canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\n\nvar isServerEnvironment = !canUseDOM;\n\nvar shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;\nvar useSyncExternalStore$2 = React.useSyncExternalStore !== undefined ? React.useSyncExternalStore : shim;\n\nexports.useSyncExternalStore = useSyncExternalStore$2;\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n}\n        \n  })();\n}\n", "'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.min.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n", "/**\n * @license React\n * use-sync-external-store-shim/with-selector.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n\n          'use strict';\n\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n}\n          var React = require('react');\nvar shim = require('use-sync-external-store/shim');\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n  ;\n}\n\nvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\nvar useSyncExternalStore = shim.useSyncExternalStore;\n\n// for CommonJS interop.\n\nvar useRef = React.useRef,\n    useEffect = React.useEffect,\n    useMemo = React.useMemo,\n    useDebugValue = React.useDebugValue; // Same as useSyncExternalStore, but supports selector and isEqual arguments.\n\nfunction useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {\n  // Use this to track the rendered snapshot.\n  var instRef = useRef(null);\n  var inst;\n\n  if (instRef.current === null) {\n    inst = {\n      hasValue: false,\n      value: null\n    };\n    instRef.current = inst;\n  } else {\n    inst = instRef.current;\n  }\n\n  var _useMemo = useMemo(function () {\n    // Track the memoized state using closure variables that are local to this\n    // memoized instance of a getSnapshot function. Intentionally not using a\n    // useRef hook, because that state would be shared across all concurrent\n    // copies of the hook/component.\n    var hasMemo = false;\n    var memoizedSnapshot;\n    var memoizedSelection;\n\n    var memoizedSelector = function (nextSnapshot) {\n      if (!hasMemo) {\n        // The first time the hook is called, there is no memoized result.\n        hasMemo = true;\n        memoizedSnapshot = nextSnapshot;\n\n        var _nextSelection = selector(nextSnapshot);\n\n        if (isEqual !== undefined) {\n          // Even if the selector has changed, the currently rendered selection\n          // may be equal to the new selection. We should attempt to reuse the\n          // current value if possible, to preserve downstream memoizations.\n          if (inst.hasValue) {\n            var currentSelection = inst.value;\n\n            if (isEqual(currentSelection, _nextSelection)) {\n              memoizedSelection = currentSelection;\n              return currentSelection;\n            }\n          }\n        }\n\n        memoizedSelection = _nextSelection;\n        return _nextSelection;\n      } // We may be able to reuse the previous invocation's result.\n\n\n      // We may be able to reuse the previous invocation's result.\n      var prevSnapshot = memoizedSnapshot;\n      var prevSelection = memoizedSelection;\n\n      if (objectIs(prevSnapshot, nextSnapshot)) {\n        // The snapshot is the same as last time. Reuse the previous selection.\n        return prevSelection;\n      } // The snapshot has changed, so we need to compute a new selection.\n\n\n      // The snapshot has changed, so we need to compute a new selection.\n      var nextSelection = selector(nextSnapshot); // If a custom isEqual function is provided, use that to check if the data\n      // has changed. If it hasn't, return the previous selection. That signals\n      // to React that the selections are conceptually equal, and we can bail\n      // out of rendering.\n\n      // If a custom isEqual function is provided, use that to check if the data\n      // has changed. If it hasn't, return the previous selection. That signals\n      // to React that the selections are conceptually equal, and we can bail\n      // out of rendering.\n      if (isEqual !== undefined && isEqual(prevSelection, nextSelection)) {\n        return prevSelection;\n      }\n\n      memoizedSnapshot = nextSnapshot;\n      memoizedSelection = nextSelection;\n      return nextSelection;\n    }; // Assigning this to a constant so that Flow knows it can't change.\n\n\n    // Assigning this to a constant so that Flow knows it can't change.\n    var maybeGetServerSnapshot = getServerSnapshot === undefined ? null : getServerSnapshot;\n\n    var getSnapshotWithSelector = function () {\n      return memoizedSelector(getSnapshot());\n    };\n\n    var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? undefined : function () {\n      return memoizedSelector(maybeGetServerSnapshot());\n    };\n    return [getSnapshotWithSelector, getServerSnapshotWithSelector];\n  }, [getSnapshot, getServerSnapshot, selector, isEqual]),\n      getSelection = _useMemo[0],\n      getServerSelection = _useMemo[1];\n\n  var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);\n  useEffect(function () {\n    inst.hasValue = true;\n    inst.value = value;\n  }, [value]);\n  useDebugValue(value);\n  return value;\n}\n\nexports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n}\n        \n  })();\n}\n", "'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.production.min.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.development.js');\n}\n", "// While the public API was clearly inspired by the \"history\" npm package,\n// This implementation attempts to be more lightweight by\n// making assumptions about the way TanStack Router works\n\nexport interface RouterHistory {\n  location: HistoryLocation\n  subscribe: (cb: () => void) => () => void\n  push: (path: string, state?: any) => void\n  replace: (path: string, state?: any) => void\n  go: (index: number) => void\n  back: () => void\n  forward: () => void\n  createHref: (href: string) => string\n  block: (blocker: BlockerFn) => () => void\n  flush: () => void\n  destroy: () => void\n  notify: () => void\n}\n\nexport interface HistoryLocation extends ParsedPath {\n  state: HistoryState\n}\n\nexport interface ParsedPath {\n  href: string\n  pathname: string\n  search: string\n  hash: string\n}\n\nexport interface HistoryState {\n  key: string\n}\n\ntype ShouldAllowNavigation = any\n\nexport type BlockerFn = () =>\n  | Promise<ShouldAllowNavigation>\n  | ShouldAllowNavigation\n\nconst pushStateEvent = 'pushstate'\nconst popStateEvent = 'popstate'\nconst beforeUnloadEvent = 'beforeunload'\n\nconst beforeUnloadListener = (event: Event) => {\n  event.preventDefault()\n  // @ts-ignore\n  return (event.returnValue = '')\n}\n\nconst stopBlocking = () => {\n  removeEventListener(beforeUnloadEvent, beforeUnloadListener, {\n    capture: true,\n  })\n}\n\nexport function createHistory(opts: {\n  getLocation: () => HistoryLocation\n  pushState: (path: string, state: any, onUpdate: () => void) => void\n  replaceState: (path: string, state: any, onUpdate: () => void) => void\n  go: (n: number) => void\n  back: () => void\n  forward: () => void\n  createHref: (path: string) => string\n  flush?: () => void\n  destroy?: () => void\n  onBlocked?: (onUpdate: () => void) => void\n}): RouterHistory {\n  let location = opts.getLocation()\n  let subscribers = new Set<() => void>()\n  let blockers: BlockerFn[] = []\n\n  const onUpdate = () => {\n    location = opts.getLocation()\n    subscribers.forEach((subscriber) => subscriber())\n  }\n\n  const tryNavigation = async (task: () => void) => {\n    if (typeof document !== 'undefined' && blockers.length) {\n      for (let blocker of blockers) {\n        const allowed = await blocker()\n        if (!allowed) {\n          opts.onBlocked?.(onUpdate)\n          return\n        }\n      }\n    }\n\n    task()\n  }\n\n  return {\n    get location() {\n      return location\n    },\n    subscribe: (cb: () => void) => {\n      subscribers.add(cb)\n\n      return () => {\n        subscribers.delete(cb)\n      }\n    },\n    push: (path: string, state: any) => {\n      state = assignKey(state)\n      tryNavigation(() => {\n        opts.pushState(path, state, onUpdate)\n      })\n    },\n    replace: (path: string, state: any) => {\n      state = assignKey(state)\n      tryNavigation(() => {\n        opts.replaceState(path, state, onUpdate)\n      })\n    },\n    go: (index) => {\n      tryNavigation(() => {\n        opts.go(index)\n      })\n    },\n    back: () => {\n      tryNavigation(() => {\n        opts.back()\n      })\n    },\n    forward: () => {\n      tryNavigation(() => {\n        opts.forward()\n      })\n    },\n    createHref: (str) => opts.createHref(str),\n    block: (blocker) => {\n      blockers.push(blocker)\n\n      if (blockers.length === 1) {\n        addEventListener(beforeUnloadEvent, beforeUnloadListener, {\n          capture: true,\n        })\n      }\n\n      return () => {\n        blockers = blockers.filter((b) => b !== blocker)\n\n        if (!blockers.length) {\n          stopBlocking()\n        }\n      }\n    },\n    flush: () => opts.flush?.(),\n    destroy: () => opts.destroy?.(),\n    notify: onUpdate,\n  }\n}\n\nfunction assignKey(state: HistoryState) {\n  if (!state) {\n    state = {} as HistoryState\n  }\n  return {\n    ...state,\n    key: createRandomKey(),\n  }\n}\n\n/**\n * Creates a history object that can be used to interact with the browser's\n * navigation. This is a lightweight API wrapping the browser's native methods.\n * It is designed to work with TanStack Router, but could be used as a standalone API as well.\n * IMPORTANT: This API implements history throttling via a microtask to prevent\n * excessive calls to the history API. In some browsers, calling history.pushState or\n * history.replaceState in quick succession can cause the browser to ignore subsequent\n * calls. This API smooths out those differences and ensures that your application\n * state will *eventually* match the browser state. In most cases, this is not a problem,\n * but if you need to ensure that the browser state is up to date, you can use the\n * `history.flush` method to immediately flush all pending state changes to the browser URL.\n * @param opts\n * @param opts.getHref A function that returns the current href (path + search + hash)\n * @param opts.createHref A function that takes a path and returns a href (path + search + hash)\n * @returns A history instance\n */\nexport function createBrowserHistory(opts?: {\n  parseLocation?: () => HistoryLocation\n  createHref?: (path: string) => string\n  window?: any\n}): RouterHistory {\n  const win =\n    opts?.window ??\n    (typeof document !== 'undefined' ? window : (undefined as any))\n\n  const createHref = opts?.createHref ?? ((path) => path)\n  const parseLocation =\n    opts?.parseLocation ??\n    (() =>\n      parseHref(\n        `${win.location.pathname}${win.location.search}${win.location.hash}`,\n        win.history.state,\n      ))\n\n  let currentLocation = parseLocation()\n  let rollbackLocation: HistoryLocation | undefined\n\n  const getLocation = () => currentLocation\n\n  let next:\n    | undefined\n    | {\n        // This is the latest location that we were attempting to push/replace\n        href: string\n        // This is the latest state that we were attempting to push/replace\n        state: any\n        // This is the latest type that we were attempting to push/replace\n        isPush: boolean\n      }\n\n  // Because we are proactively updating the location\n  // in memory before actually updating the browser history,\n  // we need to track when we are doing this so we don't\n  // notify subscribers twice on the last update.\n  let tracking = true\n\n  // We need to track the current scheduled update to prevent\n  // multiple updates from being scheduled at the same time.\n  let scheduled: Promise<void> | undefined\n\n  // This function is a wrapper to prevent any of the callback's\n  // side effects from causing a subscriber notification\n  const untrack = (fn: () => void) => {\n    tracking = false\n    fn()\n    tracking = true\n  }\n\n  // This function flushes the next update to the browser history\n  const flush = () => {\n    // Do not notify subscribers about this push/replace call\n    untrack(() => {\n      if (!next) return\n      win.history[next.isPush ? 'pushState' : 'replaceState'](\n        next.state,\n        '',\n        next.href,\n      )\n      // Reset the nextIsPush flag and clear the scheduled update\n      next = undefined\n      scheduled = undefined\n      rollbackLocation = undefined\n    })\n  }\n\n  // This function queues up a call to update the browser history\n  const queueHistoryAction = (\n    type: 'push' | 'replace',\n    destHref: string,\n    state: any,\n    onUpdate: () => void,\n  ) => {\n    const href = createHref(destHref)\n\n    if (!scheduled) {\n      rollbackLocation = currentLocation\n    }\n\n    // Update the location in memory\n    currentLocation = parseHref(destHref, state)\n\n    // Keep track of the next location we need to flush to the URL\n    next = {\n      href,\n      state,\n      isPush: next?.isPush || type === 'push',\n    }\n\n    // Notify subscribers\n    onUpdate()\n\n    if (!scheduled) {\n      // Schedule an update to the browser history\n      scheduled = Promise.resolve().then(() => flush())\n    }\n  }\n\n  const onPushPop = () => {\n    currentLocation = parseLocation()\n    history.notify()\n  }\n\n  var originalPushState = win.history.pushState\n  var originalReplaceState = win.history.replaceState\n\n  const history = createHistory({\n    getLocation,\n    pushState: (href, state, onUpdate) =>\n      queueHistoryAction('push', href, state, onUpdate),\n    replaceState: (href, state, onUpdate) =>\n      queueHistoryAction('replace', href, state, onUpdate),\n    back: () => win.history.back(),\n    forward: () => win.history.forward(),\n    go: (n) => win.history.go(n),\n    createHref: (href) => createHref(href),\n    flush,\n    destroy: () => {\n      win.history.pushState = originalPushState\n      win.history.replaceState = originalReplaceState\n      win.removeEventListener(pushStateEvent, onPushPop)\n      win.removeEventListener(popStateEvent, onPushPop)\n    },\n    onBlocked: (onUpdate) => {\n      // If a navigation is blocked, we need to rollback the location\n      // that we optimistically updated in memory.\n      if (rollbackLocation && currentLocation !== rollbackLocation) {\n        currentLocation = rollbackLocation\n        // Notify subscribers\n        onUpdate()\n      }\n    },\n  })\n\n  win.addEventListener(pushStateEvent, onPushPop)\n  win.addEventListener(popStateEvent, onPushPop)\n\n  win.history.pushState = function () {\n    let res = originalPushState.apply(win.history, arguments as any)\n    if (tracking) history.notify()\n    return res\n  }\n\n  win.history.replaceState = function () {\n    let res = originalReplaceState.apply(win.history, arguments as any)\n    if (tracking) history.notify()\n    return res\n  }\n\n  return history\n}\n\nexport function createHashHistory(opts?: { window?: any }): RouterHistory {\n  const win =\n    opts?.window ??\n    (typeof document !== 'undefined' ? window : (undefined as any))\n  return createBrowserHistory({\n    window: win,\n    parseLocation: () => {\n      const hashHref = win.location.hash.split('#').slice(1).join('#') ?? '/'\n      return parseHref(hashHref, win.history.state)\n    },\n    createHref: (href) =>\n      `${win.location.pathname}${win.location.search}#${href}`,\n  })\n}\n\nexport function createMemoryHistory(\n  opts: {\n    initialEntries: string[]\n    initialIndex?: number\n  } = {\n    initialEntries: ['/'],\n  },\n): RouterHistory {\n  const entries = opts.initialEntries\n  let index = opts.initialIndex ?? entries.length - 1\n  let currentState = {\n    key: createRandomKey(),\n  } as HistoryState\n\n  const getLocation = () => parseHref(entries[index]!, currentState)\n\n  return createHistory({\n    getLocation,\n    pushState: (path, state) => {\n      currentState = state\n      entries.push(path)\n      index++\n    },\n    replaceState: (path, state) => {\n      currentState = state\n      entries[index] = path\n    },\n    back: () => {\n      index--\n    },\n    forward: () => {\n      index = Math.min(index + 1, entries.length - 1)\n    },\n    go: (n) => {\n      index = Math.min(Math.max(index + n, 0), entries.length - 1)\n    },\n    createHref: (path) => path,\n  })\n}\n\nfunction parseHref(href: string, state: HistoryState): HistoryLocation {\n  let hashIndex = href.indexOf('#')\n  let searchIndex = href.indexOf('?')\n\n  return {\n    href,\n    pathname: href.substring(\n      0,\n      hashIndex > 0\n        ? searchIndex > 0\n          ? Math.min(hashIndex, searchIndex)\n          : hashIndex\n        : searchIndex > 0\n          ? searchIndex\n          : href.length,\n    ),\n    hash: hashIndex > -1 ? href.substring(hashIndex) : '',\n    search:\n      searchIndex > -1\n        ? href.slice(searchIndex, hashIndex === -1 ? undefined : hashIndex)\n        : '',\n    state: state || {},\n  }\n}\n\n// Thanks co-pilot!\nfunction createRandomKey() {\n  return (Math.random() + 1).toString(36).substring(7)\n}\n", "var isProduction = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new Error(prefix);\n    }\n    var provided = typeof message === 'function' ? message() : message;\n    var value = provided ? \"\".concat(prefix, \": \").concat(provided) : prefix;\n    throw new Error(value);\n}\n\nexport { invariant as default };\n", "var isProduction = process.env.NODE_ENV === 'production';\nfunction warning(condition, message) {\n  if (!isProduction) {\n    if (condition) {\n      return;\n    }\n\n    var text = \"Warning: \" + message;\n\n    if (typeof console !== 'undefined') {\n      console.warn(text);\n    }\n\n    try {\n      throw Error(text);\n    } catch (x) {}\n  }\n}\n\nexport default warning;\n", "import type { AnyUpdater, Store } from '@tanstack/store'\nimport { useSyncExternalStoreWithSelector } from 'use-sync-external-store/shim/with-selector.js'\n\nexport * from '@tanstack/store'\n\nexport type NoInfer<T> = [T][T extends any ? 0 : never]\n\nexport function useStore<\n  TState,\n  TSelected = NoInfer<TState>,\n  TUpdater extends AnyUpdater = AnyUpdater,\n>(\n  store: Store<TState, TUpdater>,\n  selector: (state: NoInfer<TState>) => TSelected = (d) => d as any,\n) {\n  const slice = useSyncExternalStoreWithSelector(\n    store.subscribe,\n    () => store.state,\n    () => store.state,\n    selector,\n    shallow,\n  )\n\n  return slice\n}\n\nexport function shallow<T>(objA: T, objB: T) {\n  if (Object.is(objA, objB)) {\n    return true\n  }\n\n  if (\n    typeof objA !== 'object' ||\n    objA === null ||\n    typeof objB !== 'object' ||\n    objB === null\n  ) {\n    return false\n  }\n\n  const keysA = Object.keys(objA)\n  if (keysA.length !== Object.keys(objB).length) {\n    return false\n  }\n\n  for (let i = 0; i < keysA.length; i++) {\n    if (\n      !Object.prototype.hasOwnProperty.call(objB, keysA[i] as string) ||\n      !Object.is(objA[keysA[i] as keyof T], objB[keysA[i] as keyof T])\n    ) {\n      return false\n    }\n  }\n  return true\n}\n", "export type AnyUpdater = (...args: any[]) => any\n\nexport type Listener = (opts: { priority: Priority }) => void\n\nexport type Priority = 'high' | 'low'\n\ninterface StoreOptions<\n  TState,\n  TUpdater extends AnyUpdater = (cb: TState) => TState,\n> {\n  updateFn?: (previous: TState) => (updater: TUpdater) => TState\n  onSubscribe?: (\n    listener: Listener,\n    store: Store<TState, TUpdater>,\n  ) => () => void\n  onUpdate?: (opts: { priority: Priority }) => void\n  defaultPriority?: Priority\n}\n\nexport class Store<\n  TState,\n  TUpdater extends AnyUpdater = (cb: TState) => TState,\n> {\n  listeners = new Set<Listener>()\n  state: TState\n  options?: StoreOptions<TState, TUpdater>\n  _batching = false\n  _flushing = 0\n  _nextPriority: null | Priority = null\n\n  constructor(initialState: TState, options?: StoreOptions<TState, TUpdater>) {\n    this.state = initialState\n    this.options = options\n  }\n\n  subscribe = (listener: Listener) => {\n    this.listeners.add(listener)\n    const unsub = this.options?.onSubscribe?.(listener, this)\n    return () => {\n      this.listeners.delete(listener)\n      unsub?.()\n    }\n  }\n\n  setState = (\n    updater: TUpdater,\n    opts?: {\n      priority: Priority\n    },\n  ) => {\n    const previous = this.state\n    this.state = this.options?.updateFn\n      ? this.options.updateFn(previous)(updater)\n      : (updater as any)(previous)\n\n    const priority = opts?.priority ?? this.options?.defaultPriority ?? 'high'\n    if (this._nextPriority === null) {\n      this._nextPriority = priority\n    } else if (this._nextPriority === 'high') {\n      this._nextPriority = priority\n    } else {\n      this._nextPriority = this.options?.defaultPriority ?? 'high'\n    }\n\n    // Always run onUpdate, regardless of batching\n    this.options?.onUpdate?.({\n      priority: this._nextPriority,\n    })\n\n    // Attempt to flush\n    this._flush()\n  }\n\n  _flush = () => {\n    if (this._batching) return\n    const flushId = ++this._flushing\n    this.listeners.forEach((listener) => {\n      if (this._flushing !== flushId) return\n      listener({\n        priority: this._nextPriority ?? 'high',\n      })\n    })\n  }\n\n  batch = (cb: () => void) => {\n    if (this._batching) return cb()\n    this._batching = true\n    cb()\n    this._batching = false\n    this._flush()\n  }\n}\n", "import * as React from 'react'\n\nexport function CatchBoundary(props: {\n  getResetKey: () => string\n  children: any\n  errorComponent?: any\n  onCatch: (error: any) => void\n}) {\n  const errorComponent = props.errorComponent ?? ErrorComponent\n\n  return (\n    <CatchBoundaryImpl\n      getResetKey={props.getResetKey}\n      onCatch={props.onCatch}\n      children={({ error }) => {\n        if (error) {\n          return React.createElement(errorComponent, {\n            error,\n          })\n        }\n\n        return props.children\n      }}\n    />\n  )\n}\n\nexport class CatchBoundaryImpl extends React.Component<{\n  getResetKey: () => string\n  children: (props: { error: any; reset: () => void }) => any\n  onCatch?: (error: any) => void\n}> {\n  state = { error: null } as any\n  static getDerivedStateFromProps(props: any) {\n    return { resetKey: props.getResetKey() }\n  }\n  static getDerivedStateFromError(error: any) {\n    return { error }\n  }\n  componentDidUpdate(\n    prevProps: Readonly<{\n      getResetKey: () => string\n      children: (props: { error: any; reset: () => void }) => any\n      onCatch?: ((error: any, info: any) => void) | undefined\n    }>,\n    prevState: any,\n  ): void {\n    if (prevState.error && prevState.resetKey !== this.state.resetKey) {\n      this.setState({ error: null })\n    }\n  }\n  componentDidCatch(error: any) {\n    console.error(error)\n    this.props.onCatch?.(error)\n  }\n  render() {\n    return this.props.children(this.state)\n  }\n}\n\nexport function ErrorComponent({ error }: { error: any }) {\n  const [show, setShow] = React.useState(process.env.NODE_ENV !== 'production')\n\n  return (\n    <div style={{ padding: '.5rem', maxWidth: '100%' }}>\n      <div style={{ display: 'flex', alignItems: 'center', gap: '.5rem' }}>\n        <strong style={{ fontSize: '1rem' }}>Something went wrong!</strong>\n        <button\n          style={{\n            appearance: 'none',\n            fontSize: '.6em',\n            border: '1px solid currentColor',\n            padding: '.1rem .2rem',\n            fontWeight: 'bold',\n            borderRadius: '.25rem',\n          }}\n          onClick={() => setShow((d) => !d)}\n        >\n          {show ? 'Hide Error' : 'Show Error'}\n        </button>\n      </div>\n      <div style={{ height: '.25rem' }} />\n      {show ? (\n        <div>\n          <pre\n            style={{\n              fontSize: '.7em',\n              border: '1px solid red',\n              borderRadius: '.25rem',\n              padding: '.3rem',\n              color: 'red',\n              overflow: 'auto',\n            }}\n          >\n            {error.message ? <code>{error.message}</code> : null}\n          </pre>\n        </div>\n      ) : null}\n    </div>\n  )\n}\n", "import * as React from 'react'\nimport { useMatch } from './Matches'\nimport { RouteMatch } from './Matches'\nimport { AnyRoute } from './route'\nimport { ParseRoute, RouteIds, RoutesById, RouteById } from './routeInfo'\nimport { RegisteredRouter } from './router'\n\nexport type NoInfer<T> = [T][T extends any ? 0 : never]\nexport type IsAny<T, Y, N = T> = 1 extends 0 & T ? Y : N\nexport type IsAnyBoolean<T> = 1 extends 0 & T ? true : false\nexport type IsKnown<T, Y, N> = unknown extends T ? N : Y\nexport type PickAsRequired<T, K extends keyof T> = Omit<T, K> &\n  Required<Pick<T, K>>\nexport type PickAsPartial<T, K extends keyof T> = Omit<T, K> &\n  Partial<Pick<T, K>>\nexport type PickUnsafe<T, K> = K extends keyof T ? Pick<T, K> : never\nexport type PickExtra<T, K> = {\n  [TKey in keyof K as string extends TKey\n    ? never\n    : TKey extends keyof T\n    ? never\n    : TKey]: K[TKey]\n}\n\nexport type PickRequired<T> = {\n  [K in keyof T as undefined extends T[K] ? never : K]: T[K]\n}\n\n// export type Expand<T> = T\nexport type Expand<T> = T extends object\n  ? T extends infer O\n    ? { [K in keyof O]: O[K] }\n    : never\n  : T\n\nexport type UnionToIntersection<U> = (\n  U extends any ? (k: U) => void : never\n) extends (k: infer I) => any\n  ? I\n  : never\n\n// type Compute<T> = { [K in keyof T]: T[K] } | never\n\n// type AllKeys<T> = T extends any ? keyof T : never\n\n// export type MergeUnion<T, Keys extends keyof T = keyof T> = Compute<\n//   {\n//     [K in Keys]: T[Keys]\n//   } & {\n//     [K in AllKeys<T>]?: T extends any\n//       ? K extends keyof T\n//         ? T[K]\n//         : never\n//       : never\n//   }\n// >\n\nexport type Assign<Left, Right> = Omit<Left, keyof Right> & Right\n\nexport type AssignAll<T extends any[]> = T extends [infer Left, ...infer Right]\n  ? Right extends any[]\n    ? Assign<Left, AssignAll<Right>>\n    : Left\n  : {}\n\n// // Sample types to merge\n// type TypeA = {\n//   shared: string\n//   onlyInA: string\n//   nested: {\n//     shared: string\n//     aProp: string\n//   }\n//   array: string[]\n// }\n\n// type TypeB = {\n//   shared: number\n//   onlyInB: number\n//   nested: {\n//     shared: number\n//     bProp: number\n//   }\n//   array: number[]\n// }\n\n// type TypeC = {\n//   shared: boolean\n//   onlyInC: boolean\n//   nested: {\n//     shared: boolean\n//     cProp: boolean\n//   }\n//   array: boolean[]\n// }\n\n// type Test = Expand<Assign<TypeA, TypeB>>\n\n// // Using DeepMerge to merge TypeA and TypeB\n// type MergedType = Expand<AssignAll<[TypeA, TypeB, TypeC]>>\n\nexport type Values<O> = O[ValueKeys<O>]\nexport type ValueKeys<O> = Extract<keyof O, PropertyKey>\n\nexport type DeepAwaited<T> = T extends Promise<infer A>\n  ? DeepAwaited<A>\n  : T extends Record<infer A, Promise<infer B>>\n  ? { [K in A]: DeepAwaited<B> }\n  : T\n\nexport type PathParamMask<TRoutePath extends string> =\n  TRoutePath extends `${infer L}/$${infer C}/${infer R}`\n    ? PathParamMask<`${L}/${string}/${R}`>\n    : TRoutePath extends `${infer L}/$${infer C}`\n    ? PathParamMask<`${L}/${string}`>\n    : TRoutePath\n\nexport type Timeout = ReturnType<typeof setTimeout>\n\nexport type Updater<TPrevious, TResult = TPrevious> =\n  | TResult\n  | ((prev?: TPrevious) => TResult)\n\nexport type NonNullableUpdater<TPrevious, TResult = TPrevious> =\n  | TResult\n  | ((prev: TPrevious) => TResult)\n\nexport type PickExtract<T, U> = {\n  [K in keyof T as T[K] extends U ? K : never]: T[K]\n}\n\nexport type PickExclude<T, U> = {\n  [K in keyof T as T[K] extends U ? never : K]: T[K]\n}\n\n// from https://github.com/type-challenges/type-challenges/issues/737\ntype LastInUnion<U> = UnionToIntersection<\n  U extends unknown ? (x: U) => 0 : never\n> extends (x: infer L) => 0\n  ? L\n  : never\nexport type UnionToTuple<U, Last = LastInUnion<U>> = [U] extends [never]\n  ? []\n  : [...UnionToTuple<Exclude<U, Last>>, Last]\n\n//\n\nexport const isServer = typeof document === 'undefined'\n\nexport function last<T>(arr: T[]) {\n  return arr[arr.length - 1]\n}\n\nfunction isFunction(d: any): d is Function {\n  return typeof d === 'function'\n}\n\nexport function functionalUpdate<TResult>(\n  updater: Updater<TResult> | NonNullableUpdater<TResult>,\n  previous: TResult,\n): TResult {\n  if (isFunction(updater)) {\n    return updater(previous as TResult)\n  }\n\n  return updater\n}\n\nexport function pick<T, K extends keyof T>(parent: T, keys: K[]): Pick<T, K> {\n  return keys.reduce((obj: any, key: K) => {\n    obj[key] = parent[key]\n    return obj\n  }, {} as any)\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between immutable JSON values for example.\n * Do not use this with signals\n */\nexport function replaceEqualDeep<T>(prev: any, _next: T): T {\n  if (prev === _next) {\n    return prev\n  }\n\n  const next = _next as any\n\n  const array = Array.isArray(prev) && Array.isArray(next)\n\n  if (array || (isPlainObject(prev) && isPlainObject(next))) {\n    const prevSize = array ? prev.length : Object.keys(prev).length\n    const nextItems = array ? next : Object.keys(next)\n    const nextSize = nextItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < nextSize; i++) {\n      const key = array ? i : nextItems[i]\n      copy[key] = replaceEqualDeep(prev[key], next[key])\n      if (copy[key] === prev[key]) {\n        equalItems++\n      }\n    }\n\n    return prevSize === nextSize && equalItems === prevSize ? prev : copy\n  }\n\n  return next\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any) {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any) {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function deepEqual(a: any, b: any, partial: boolean = false): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (isPlainObject(a) && isPlainObject(b)) {\n    const aKeys = Object.keys(a)\n    const bKeys = Object.keys(b)\n\n    if (!partial && aKeys.length !== bKeys.length) {\n      return false\n    }\n\n    return !bKeys.some(\n      (key) => !(key in a) || !deepEqual(a[key], b[key], partial),\n    )\n  }\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return !a.some((item, index) => !deepEqual(item, b[index], partial))\n  }\n\n  return false\n}\n\nexport function useStableCallback<T extends (...args: any[]) => any>(fn: T): T {\n  const fnRef = React.useRef(fn)\n  fnRef.current = fn\n\n  const ref = React.useRef((...args: any[]) => fnRef.current(...args))\n  return ref.current as T\n}\n\nexport function shallow<T>(objA: T, objB: T) {\n  if (Object.is(objA, objB)) {\n    return true\n  }\n\n  if (\n    typeof objA !== 'object' ||\n    objA === null ||\n    typeof objB !== 'object' ||\n    objB === null\n  ) {\n    return false\n  }\n\n  const keysA = Object.keys(objA)\n  if (keysA.length !== Object.keys(objB).length) {\n    return false\n  }\n\n  for (let i = 0; i < keysA.length; i++) {\n    if (\n      !Object.prototype.hasOwnProperty.call(objB, keysA[i] as string) ||\n      !Object.is(objA[keysA[i] as keyof T], objB[keysA[i] as keyof T])\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\nexport type StrictOrFrom<TFrom> =\n  | {\n      from: TFrom\n      strict?: true\n    }\n  | {\n      from?: never\n      strict: false\n    }\n\nexport type RouteFromIdOrRoute<\n  T,\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n> = T extends ParseRoute<TRouteTree>\n  ? T\n  : T extends RouteIds<TRouteTree>\n  ? RoutesById<TRouteTree>[T]\n  : T extends string\n  ? RouteIds<TRouteTree>\n  : never\n\nexport function useRouteContext<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TStrict extends boolean = true,\n  TRouteContext = RouteById<TRouteTree, TFrom>['types']['allContext'],\n  TSelected = TRouteContext,\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (search: TRouteContext) => TSelected\n  },\n): TStrict extends true ? TSelected : TSelected | undefined {\n  return useMatch({\n    ...(opts as any),\n    select: (match: RouteMatch) =>\n      opts?.select\n        ? opts.select(match.context as TRouteContext)\n        : match.context,\n  })\n}\n\nexport const useLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\nexport function escapeJSON(jsonString: string) {\n  return jsonString\n    .replace(/\\\\/g, '\\\\\\\\') // Escape backslashes\n    .replace(/'/g, \"\\\\'\") // Escape single quotes\n    .replace(/\"/g, '\\\\\"') // Escape double quotes\n}\n", "import * as React from 'react'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { CatchBoundary, ErrorComponent } from './CatchBoundary'\nimport { useRouter, useRouterState } from './RouterProvider'\nimport { ResolveRelativePath, ToOptions } from './link'\nimport { AnyRoute, ReactNode, rootRouteId } from './route'\nimport {\n  FullSearchSchema,\n  ParseRoute,\n  RouteById,\n  RouteByPath,\n  RouteIds,\n  RoutePaths,\n} from './routeInfo'\nimport { RegisteredRouter, RouterState } from './router'\nimport { NoInfer, StrictOrFrom, pick } from './utils'\n\nexport const matchContext = React.createContext<string | undefined>(undefined)\n\nexport interface RouteMatch<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id'],\n> {\n  id: string\n  routeId: TRouteId\n  pathname: string\n  params: RouteById<TRouteTree, TRouteId>['types']['allParams']\n  status: 'pending' | 'success' | 'error'\n  isFetching: boolean\n  showPending: boolean\n  error: unknown\n  paramsError: unknown\n  searchError: unknown\n  updatedAt: number\n  loadPromise?: Promise<void>\n  loaderData?: RouteById<TRouteTree, TRouteId>['types']['loaderData']\n  routeContext: RouteById<TRouteTree, TRouteId>['types']['routeContext']\n  context: RouteById<TRouteTree, TRouteId>['types']['allContext']\n  search: FullSearchSchema<TRouteTree> &\n    RouteById<TRouteTree, TRouteId>['types']['fullSearchSchema']\n  fetchCount: number\n  abortController: AbortController\n  cause: 'preload' | 'enter' | 'stay'\n  loaderDeps: RouteById<TRouteTree, TRouteId>['types']['loaderDeps']\n  preload: boolean\n  invalid: boolean\n}\n\nexport type AnyRouteMatch = RouteMatch<any, any>\n\nexport function Matches() {\n  const router = useRouter()\n  const matchId = useRouterState({\n    select: (s) => {\n      return getRenderedMatches(s)[0]?.id\n    },\n  })\n\n  return (\n    <matchContext.Provider value={matchId}>\n      <CatchBoundary\n        getResetKey={() => router.state.resolvedLocation.state?.key}\n        errorComponent={ErrorComponent}\n        onCatch={() => {\n          warning(\n            false,\n            `Error in router! Consider setting an 'errorComponent' in your RootRoute! ðŸ‘`,\n          )\n        }}\n      >\n        {matchId ? <Match matchId={matchId} /> : null}\n      </CatchBoundary>\n    </matchContext.Provider>\n  )\n}\n\nfunction SafeFragment(props: any) {\n  return <>{props.children}</>\n}\n\nexport function Match({ matchId }: { matchId: string }) {\n  const router = useRouter()\n  const routeId = useRouterState({\n    select: (s) =>\n      getRenderedMatches(s).find((d) => d.id === matchId)?.routeId as string,\n  })\n\n  invariant(\n    routeId,\n    `Could not find routeId for matchId \"${matchId}\". Please file an issue!`,\n  )\n\n  const route = router.routesById[routeId]!\n\n  const PendingComponent = (route.options.pendingComponent ??\n    router.options.defaultPendingComponent) as any\n\n  const pendingElement = PendingComponent ? <PendingComponent /> : null\n\n  const routeErrorComponent =\n    route.options.errorComponent ??\n    router.options.defaultErrorComponent ??\n    ErrorComponent\n\n  const ResolvedSuspenseBoundary =\n    route.options.wrapInSuspense ??\n    PendingComponent ??\n    route.options.component?.preload ??\n    route.options.pendingComponent?.preload ??\n    (route.options.errorComponent as any)?.preload\n      ? React.Suspense\n      : SafeFragment\n\n  const ResolvedCatchBoundary = routeErrorComponent\n    ? CatchBoundary\n    : SafeFragment\n\n  return (\n    <matchContext.Provider value={matchId}>\n      <ResolvedSuspenseBoundary fallback={pendingElement}>\n        <ResolvedCatchBoundary\n          getResetKey={() => router.state.resolvedLocation.state?.key}\n          errorComponent={routeErrorComponent}\n          onCatch={() => {\n            warning(false, `Error in route match: ${matchId}`)\n          }}\n        >\n          <MatchInner matchId={matchId!} pendingElement={pendingElement} />\n        </ResolvedCatchBoundary>\n      </ResolvedSuspenseBoundary>\n    </matchContext.Provider>\n  )\n}\n\nfunction MatchInner({\n  matchId,\n  pendingElement,\n}: {\n  matchId: string\n  pendingElement: any\n}): any {\n  const router = useRouter()\n  const routeId = useRouterState({\n    select: (s) =>\n      getRenderedMatches(s).find((d) => d.id === matchId)?.routeId as string,\n  })\n\n  const route = router.routesById[routeId]!\n\n  const match = useRouterState({\n    select: (s) =>\n      pick(getRenderedMatches(s).find((d) => d.id === matchId)!, [\n        'status',\n        'error',\n        'showPending',\n        'loadPromise',\n      ]),\n  })\n\n  if (match.status === 'error') {\n    throw match.error\n  }\n\n  if (match.status === 'pending') {\n    if (match.showPending) {\n      return pendingElement\n    }\n    throw match.loadPromise\n  }\n\n  if (match.status === 'success') {\n    let Comp = route.options.component ?? router.options.defaultComponent\n\n    if (Comp) {\n      return <Comp />\n    }\n\n    return <Outlet />\n  }\n\n  invariant(\n    false,\n    'Idle routeMatch status encountered during rendering! You should never see this. File an issue!',\n  )\n}\n\nexport const Outlet = React.memo(function Outlet() {\n  const matchId = React.useContext(matchContext)\n\n  const childMatchId = useRouterState({\n    select: (s) => {\n      const matches = getRenderedMatches(s)\n      const index = matches.findIndex((d) => d.id === matchId)\n      return matches[index + 1]?.id\n    },\n  })\n\n  if (!childMatchId) {\n    return null\n  }\n\n  return <Match matchId={childMatchId} />\n})\n\nexport interface MatchRouteOptions {\n  pending?: boolean\n  caseSensitive?: boolean\n  includeSearch?: boolean\n  fuzzy?: boolean\n}\n\nexport type UseMatchRouteOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ToOptions<AnyRoute, TFrom, TTo, TMaskFrom, TMaskTo> & MatchRouteOptions\n\nexport function useMatchRoute<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n>() {\n  useRouterState({ select: (s) => [s.location, s.resolvedLocation] })\n  const { matchRoute } = useRouter()\n\n  return React.useCallback(\n    <\n      TFrom extends RoutePaths<TRouteTree> = '/',\n      TTo extends string = '',\n      TMaskFrom extends RoutePaths<TRouteTree> = '/',\n      TMaskTo extends string = '',\n      TResolved extends string = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n    >(\n      opts: UseMatchRouteOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n    ): false | RouteById<TRouteTree, TResolved>['types']['allParams'] => {\n      const { pending, caseSensitive, ...rest } = opts\n\n      return matchRoute(rest as any, {\n        pending,\n        caseSensitive,\n      })\n    },\n    [],\n  )\n}\n\nexport type MakeMatchRouteOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ToOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> &\n  MatchRouteOptions & {\n    // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n    children?:\n      | ((\n          params?: RouteByPath<\n            TRouteTree,\n            ResolveRelativePath<TFrom, NoInfer<TTo>>\n          >['types']['allParams'],\n        ) => ReactNode)\n      | React.ReactNode\n  }\n\nexport function MatchRoute<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n>(\n  props: MakeMatchRouteOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n): any {\n  const matchRoute = useMatchRoute()\n  const params = matchRoute(props as any)\n\n  if (typeof props.children === 'function') {\n    return (props.children as any)(params)\n  }\n\n  return !!params ? props.children : null\n}\n\nfunction getRenderedMatches(state: RouterState) {\n  return state.pendingMatches?.some((d) => d.showPending)\n    ? state.pendingMatches\n    : state.matches\n}\n\nexport function useMatch<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TStrict extends boolean = true,\n  TRouteMatchState = RouteMatch<TRouteTree, TFrom>,\n  TSelected = TRouteMatchState,\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (match: TRouteMatchState) => TSelected\n  },\n): TStrict extends true ? TSelected : TSelected | undefined {\n  const router = useRouter()\n  const nearestMatchId = React.useContext(matchContext)\n\n  const nearestMatchRouteId = getRenderedMatches(router.state).find(\n    (d) => d.id === nearestMatchId,\n  )?.routeId\n\n  const matchRouteId = (() => {\n    const matches = getRenderedMatches(router.state)\n    const match = opts?.from\n      ? matches.find((d) => d.routeId === opts?.from)\n      : matches.find((d) => d.id === nearestMatchId)\n    return match!.routeId\n  })()\n\n  if (opts?.strict ?? true) {\n    invariant(\n      nearestMatchRouteId == matchRouteId,\n      `useMatch(\"${\n        matchRouteId as string\n      }\") is being called in a component that is meant to render the '${nearestMatchRouteId}' route. Did you mean to 'useMatch(\"${\n        matchRouteId as string\n      }\", { strict: false })' or 'useRoute(\"${\n        matchRouteId as string\n      }\")' instead?`,\n    )\n  }\n\n  const matchSelection = useRouterState({\n    select: (state) => {\n      const match = getRenderedMatches(state).find(\n        (d) => d.id === nearestMatchId,\n      )\n\n      invariant(\n        match,\n        `Could not find ${\n          opts?.from\n            ? `an active match from \"${opts.from}\"`\n            : 'a nearest match!'\n        }`,\n      )\n\n      return opts?.select ? opts.select(match as any) : match\n    },\n  })\n\n  return matchSelection as any\n}\n\nexport function useMatches<T = RouteMatch[]>(opts?: {\n  select?: (matches: RouteMatch[]) => T\n}): T {\n  return useRouterState({\n    select: (state) => {\n      let matches = getRenderedMatches(state)\n      return opts?.select ? opts.select(matches) : (matches as T)\n    },\n  })\n}\n\nexport function useParentMatches<T = RouteMatch[]>(opts?: {\n  select?: (matches: RouteMatch[]) => T\n}): T {\n  const contextMatchId = React.useContext(matchContext)\n\n  return useMatches({\n    select: (matches) => {\n      matches = matches.slice(matches.findIndex((d) => d.id === contextMatchId))\n      return opts?.select ? opts.select(matches) : (matches as T)\n    },\n  })\n}\n\nexport function useLoaderDeps<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TStrict extends boolean = true,\n  TRouteMatch extends RouteMatch<TRouteTree, TFrom> = RouteMatch<\n    TRouteTree,\n    TFrom\n  >,\n  TSelected = Required<TRouteMatch>['loaderDeps'],\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (match: TRouteMatch) => TSelected\n  },\n): TStrict extends true ? TSelected : TSelected | undefined {\n  return useMatch({\n    ...opts,\n    select: (s) => {\n      return typeof opts.select === 'function'\n        ? opts.select(s?.loaderDeps)\n        : s?.loaderDeps\n    },\n  })!\n}\n\nexport function useLoaderData<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TStrict extends boolean = true,\n  TRouteMatch extends RouteMatch<TRouteTree, TFrom> = RouteMatch<\n    TRouteTree,\n    TFrom\n  >,\n  TSelected = Required<TRouteMatch>['loaderData'],\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (match: TRouteMatch) => TSelected\n  },\n): TStrict extends true ? TSelected : TSelected | undefined {\n  return useMatch({\n    ...opts,\n    select: (s) => {\n      return typeof opts.select === 'function'\n        ? opts.select(s?.loaderData)\n        : s?.loaderData\n    },\n  })!\n}\n", "import * as React from 'react'\nimport warning from 'tiny-warning'\nimport { useStore } from '@tanstack/react-store'\nimport { Matches } from './Matches'\nimport { NavigateOptions, ResolveRelativePath, ToOptions } from './link'\nimport { ParsedLocation } from './location'\nimport { AnyRoute } from './route'\nimport { RouteById, RoutePaths } from './routeInfo'\nimport {\n  BuildNextOptions,\n  RegisteredRouter,\n  Router,\n  RouterOptions,\n  RouterState,\n} from './router'\nimport { NoInfer, pick, useLayoutEffect } from './utils'\nimport { MatchRouteOptions } from './Matches'\nimport { RouteMatch } from './Matches'\n\nexport interface CommitLocationOptions {\n  replace?: boolean\n  resetScroll?: boolean\n  startTransition?: boolean\n}\n\nexport interface MatchLocation {\n  to?: string | number | null\n  fuzzy?: boolean\n  caseSensitive?: boolean\n  from?: string\n}\n\nexport type NavigateFn<TRouteTree extends AnyRoute> = <\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n>(\n  opts: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n) => Promise<void>\n\nexport type MatchRouteFn<TRouteTree extends AnyRoute> = <\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n>(\n  location: ToOptions<TRouteTree, TFrom, TTo>,\n  opts?: MatchRouteOptions,\n) => false | RouteById<TRouteTree, TResolved>['types']['allParams']\n\nexport type BuildLocationFn<TRouteTree extends AnyRoute> = (\n  opts: ToOptions<TRouteTree>,\n) => ParsedLocation\n\nexport type InjectedHtmlEntry = string | (() => Promise<string> | string)\n\nexport let routerContext = React.createContext<Router<any>>(null!)\n\nif (typeof document !== 'undefined') {\n  if (window.__TSR_ROUTER_CONTEXT__) {\n    routerContext = window.__TSR_ROUTER_CONTEXT__\n  } else {\n    window.__TSR_ROUTER_CONTEXT__ = routerContext as any\n  }\n}\n\nexport function RouterProvider<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TDehydrated extends Record<string, any> = Record<string, any>,\n>({ router, ...rest }: RouterProps<TRouteTree, TDehydrated>) {\n  // Allow the router to update options on the router instance\n  router.update({\n    ...router.options,\n    ...rest,\n    context: {\n      ...router.options.context,\n      ...rest?.context,\n    },\n  } as any)\n\n  const matches = router.options.InnerWrap ? (\n    <router.options.InnerWrap>\n      <Matches />\n    </router.options.InnerWrap>\n  ) : (\n    <Matches />\n  )\n\n  const provider = (\n    <routerContext.Provider value={router}>\n      {matches}\n      <Transitioner />\n    </routerContext.Provider>\n  )\n\n  if (router.options.Wrap) {\n    return <router.options.Wrap>{provider}</router.options.Wrap>\n  }\n\n  return provider\n}\n\nfunction Transitioner() {\n  const router = useRouter()\n  const routerState = useRouterState({\n    select: (s) =>\n      pick(s, ['isLoading', 'location', 'resolvedLocation', 'isTransitioning']),\n  })\n\n  const [isTransitioning, startReactTransition] = React.useTransition()\n\n  router.startReactTransition = startReactTransition\n\n  React.useEffect(() => {\n    if (isTransitioning) {\n      router.__store.setState((s) => ({\n        ...s,\n        isTransitioning,\n      }))\n    }\n  }, [isTransitioning])\n\n  const tryLoad = () => {\n    const apply = (cb: () => void) => {\n      if (!routerState.isTransitioning) {\n        startReactTransition(() => cb())\n      } else {\n        cb()\n      }\n    }\n\n    apply(() => {\n      try {\n        router.load()\n      } catch (err) {\n        console.error(err)\n      }\n    })\n  }\n\n  useLayoutEffect(() => {\n    const unsub = router.history.subscribe(() => {\n      router.latestLocation = router.parseLocation(router.latestLocation)\n      if (routerState.location !== router.latestLocation) {\n        tryLoad()\n      }\n    })\n\n    const nextLocation = router.buildLocation({\n      search: true,\n      params: true,\n      hash: true,\n      state: true,\n    })\n\n    if (routerState.location.href !== nextLocation.href) {\n      router.commitLocation({ ...nextLocation, replace: true })\n    }\n\n    return () => {\n      unsub()\n    }\n  }, [router.history])\n\n  useLayoutEffect(() => {\n    if (\n      routerState.isTransitioning &&\n      !isTransitioning &&\n      !routerState.isLoading &&\n      routerState.resolvedLocation !== routerState.location\n    ) {\n      router.emit({\n        type: 'onResolved',\n        fromLocation: routerState.resolvedLocation,\n        toLocation: routerState.location,\n        pathChanged:\n          routerState.location!.href !== routerState.resolvedLocation?.href,\n      })\n\n      if ((document as any).querySelector) {\n        if (routerState.location.hash !== '') {\n          const el = document.getElementById(\n            routerState.location.hash,\n          ) as HTMLElement | null\n          if (el) {\n            el.scrollIntoView()\n          }\n        }\n      }\n\n      router.__store.setState((s) => ({\n        ...s,\n        isTransitioning: false,\n        resolvedLocation: s.location,\n      }))\n    }\n  }, [\n    routerState.isTransitioning,\n    isTransitioning,\n    routerState.isLoading,\n    routerState.resolvedLocation,\n    routerState.location,\n  ])\n\n  useLayoutEffect(() => {\n    if (!window.__TSR_DEHYDRATED__) {\n      tryLoad()\n    }\n  }, [])\n\n  return null\n}\n\nexport function getRouteMatch<TRouteTree extends AnyRoute>(\n  state: RouterState<TRouteTree>,\n  id: string,\n): undefined | RouteMatch<TRouteTree> {\n  return [\n    ...state.cachedMatches,\n    ...(state.pendingMatches ?? []),\n    ...state.matches,\n  ].find((d) => d.id === id)\n}\n\nexport function useRouterState<\n  TSelected = RouterState<RegisteredRouter['routeTree']>,\n>(opts?: {\n  select: (state: RouterState<RegisteredRouter['routeTree']>) => TSelected\n}): TSelected {\n  const router = useRouter()\n  return useStore(router.__store, opts?.select as any)\n}\n\nexport type RouterProps<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> = Omit<RouterOptions<TRouteTree, TDehydrated>, 'context'> & {\n  router: Router<TRouteTree>\n  context?: Partial<RouterOptions<TRouteTree, TDehydrated>['context']>\n}\n\nexport function useRouter<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n>(): Router<TRouteTree> {\n  const resolvedContext =\n    typeof document !== 'undefined'\n      ? window.__TSR_ROUTER_CONTEXT__ || routerContext\n      : routerContext\n  const value = React.useContext(resolvedContext)\n  warning(value, 'useRouter must be used inside a <RouterProvider> component!')\n  return value as any\n}\n", "export type DeferredPromiseState<T> = { uid: string } & (\n  | {\n      status: 'pending'\n      data?: T\n      error?: unknown\n    }\n  | {\n      status: 'success'\n      data: T\n    }\n  | {\n      status: 'error'\n      data?: T\n      error: unknown\n    }\n)\n\nexport type DeferredPromise<T> = Promise<T> & {\n  __deferredState: DeferredPromiseState<T>\n}\n\nexport function defer<T>(_promise: Promise<T>) {\n  const promise = _promise as DeferredPromise<T>\n\n  if (!promise.__deferredState) {\n    promise.__deferredState = {\n      uid: Math.random().toString(36).slice(2),\n      status: 'pending',\n    }\n\n    const state = promise.__deferredState\n\n    promise\n      .then((data) => {\n        state.status = 'success' as any\n        state.data = data\n      })\n      .catch((error) => {\n        state.status = 'error' as any\n        state.error = error\n      })\n  }\n\n  return promise\n}\n\nexport function isDehydratedDeferred(obj: any): boolean {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    !(obj instanceof Promise) &&\n    !obj.then &&\n    '__deferredState' in obj\n  )\n}\n", "import { useRouter } from './RouterProvider'\nimport { DeferredPromise, isDehydratedDeferred } from './defer'\n\nexport type AwaitOptions<T> = {\n  promise: DeferredPromise<T>\n}\n\nexport function useAwaited<T>({ promise }: AwaitOptions<T>): [T] {\n  const router = useRouter()\n\n  let state = promise.__deferredState\n  const key = `__TSR__DEFERRED__${state.uid}`\n\n  if (isDehydratedDeferred(promise)) {\n    state = router.hydrateData(key)!\n    promise = Promise.resolve(state.data) as DeferredPromise<any>\n    promise.__deferredState = state\n  }\n\n  if (state.status === 'pending') {\n    throw new Promise((r) => setTimeout(r, 1)).then(() => promise)\n  }\n\n  if (state.status === 'error') {\n    throw state.error\n  }\n\n  router.dehydrateData(key, state)\n\n  return [state.data]\n}\n\nexport function Await<T>(\n  props: AwaitOptions<T> & {\n    children: (result: T) => JSX.Element\n  },\n) {\n  const awaited = useAwaited(props)\n  return props.children(...awaited)\n}\n", "import { MatchLocation } from './RouterProvider'\nimport { AnyPathParams } from './route'\nimport { last } from './utils'\n\nexport interface Segment {\n  type: 'pathname' | 'param' | 'wildcard'\n  value: string\n}\n\nexport function joinPaths(paths: (string | undefined)[]) {\n  return cleanPath(paths.filter(Boolean).join('/'))\n}\n\nexport function cleanPath(path: string) {\n  // remove double slashes\n  return path.replace(/\\/{2,}/g, '/')\n}\n\nexport function trimPathLeft(path: string) {\n  return path === '/' ? path : path.replace(/^\\/{1,}/, '')\n}\n\nexport function trimPathRight(path: string) {\n  return path === '/' ? path : path.replace(/\\/{1,}$/, '')\n}\n\nexport function trimPath(path: string) {\n  return trimPathRight(trimPathLeft(path))\n}\n\nexport function resolvePath(basepath: string, base: string, to: string) {\n  base = base.replace(new RegExp(`^${basepath}`), '/')\n  to = to.replace(new RegExp(`^${basepath}`), '/')\n\n  let baseSegments = parsePathname(base)\n  const toSegments = parsePathname(to)\n\n  toSegments.forEach((toSegment, index) => {\n    if (toSegment.value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment]\n      } else if (index === toSegments.length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment)\n      } else {\n        // ignore inter-slashes\n      }\n    } else if (toSegment.value === '..') {\n      // Extra trailing slash? pop it off\n      if (baseSegments.length > 1 && last(baseSegments)?.value === '/') {\n        baseSegments.pop()\n      }\n      baseSegments.pop()\n    } else if (toSegment.value === '.') {\n      return\n    } else {\n      baseSegments.push(toSegment)\n    }\n  })\n\n  const joined = joinPaths([basepath, ...baseSegments.map((d) => d.value)])\n\n  return cleanPath(joined)\n}\n\nexport function parsePathname(pathname?: string): Segment[] {\n  if (!pathname) {\n    return []\n  }\n\n  pathname = cleanPath(pathname)\n\n  const segments: Segment[] = []\n\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!pathname) {\n    return segments\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean)\n\n  segments.push(\n    ...split.map((part): Segment => {\n      if (part === '$' || part === '*') {\n        return {\n          type: 'wildcard',\n          value: part,\n        }\n      }\n\n      if (part.charAt(0) === '$') {\n        return {\n          type: 'param',\n          value: part,\n        }\n      }\n\n      return {\n        type: 'pathname',\n        value: part,\n      }\n    }),\n  )\n\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  return segments\n}\n\nexport function interpolatePath(\n  path: string | undefined,\n  params: any,\n  leaveWildcards: boolean = false,\n) {\n  const interpolatedPathSegments = parsePathname(path)\n\n  return joinPaths(\n    interpolatedPathSegments.map((segment) => {\n      if (segment.type === 'wildcard') {\n        const value = params[segment.value]\n        if (leaveWildcards) return `${segment.value}${value ?? ''}`\n        return value\n      }\n\n      if (segment.type === 'param') {\n        return params![segment.value.substring(1)] ?? 'undefined'\n      }\n\n      return segment.value\n    }),\n  )\n}\n\nexport function matchPathname(\n  basepath: string,\n  currentPathname: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'fuzzy' | 'caseSensitive'>,\n): AnyPathParams | undefined {\n  const pathParams = matchByPath(basepath, currentPathname, matchLocation)\n  // const searchMatched = matchBySearch(location.search, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return\n  }\n\n  return pathParams ?? {}\n}\n\nexport function removeBasepath(basepath: string, pathname: string) {\n  return basepath != '/' ? pathname.substring(basepath.length) : pathname\n}\n\nexport function matchByPath(\n  basepath: string,\n  from: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'caseSensitive' | 'fuzzy'>,\n): Record<string, string> | undefined {\n  // Remove the base path from the pathname\n  from = removeBasepath(basepath, from)\n  // Default to to $ (wildcard)\n  const to = `${matchLocation.to ?? '$'}`\n  // Parse the from and to\n  const baseSegments = parsePathname(from)\n  const routeSegments = parsePathname(to)\n\n  if (!from.startsWith('/')) {\n    baseSegments.unshift({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!to.startsWith('/')) {\n    routeSegments.unshift({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  const params: Record<string, string> = {}\n\n  let isMatch = (() => {\n    for (\n      let i = 0;\n      i < Math.max(baseSegments.length, routeSegments.length);\n      i++\n    ) {\n      const baseSegment = baseSegments[i]\n      const routeSegment = routeSegments[i]\n\n      const isLastBaseSegment = i >= baseSegments.length - 1\n      const isLastRouteSegment = i >= routeSegments.length - 1\n\n      if (routeSegment) {\n        if (routeSegment.type === 'wildcard') {\n          if (baseSegment?.value) {\n            params['*'] = joinPaths(baseSegments.slice(i).map((d) => d.value))\n            return true\n          }\n          return false\n        }\n\n        if (routeSegment.type === 'pathname') {\n          if (routeSegment.value === '/' && !baseSegment?.value) {\n            return true\n          }\n\n          if (baseSegment) {\n            if (matchLocation.caseSensitive) {\n              if (routeSegment.value !== baseSegment.value) {\n                return false\n              }\n            } else if (\n              routeSegment.value.toLowerCase() !==\n              baseSegment.value.toLowerCase()\n            ) {\n              return false\n            }\n          }\n        }\n\n        if (!baseSegment) {\n          return false\n        }\n\n        if (routeSegment.type === 'param') {\n          if (baseSegment?.value === '/') {\n            return false\n          }\n          if (baseSegment.value.charAt(0) !== '$') {\n            params[routeSegment.value.substring(1)] = baseSegment.value\n          }\n        }\n      }\n\n      if (!isLastBaseSegment && isLastRouteSegment) {\n        params['**'] = joinPaths(baseSegments.slice(i + 1).map((d) => d.value))\n        return !!matchLocation.fuzzy && routeSegment?.value !== '/'\n      }\n    }\n\n    return true\n  })()\n\n  return isMatch ? (params as Record<string, string>) : undefined\n}\n", "import { AnyRoute } from './route'\nimport { RouteIds, RouteById, AllParams } from './routeInfo'\nimport { RegisteredRouter } from './router'\nimport { last } from './utils'\nimport { useRouterState } from './RouterProvider'\nimport { StrictOrFrom } from './utils'\n\nexport function useParams<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TDefaultSelected = AllParams<TRouteTree> &\n    RouteById<TRouteTree, TFrom>['types']['allParams'],\n  TSelected = TDefaultSelected,\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (search: TDefaultSelected) => TSelected\n  },\n): TSelected {\n  return useRouterState({\n    select: (state: any) => {\n      const params = (last(state.matches) as any)?.params\n      return opts?.select ? opts.select(params) : params\n    },\n  })\n}\n", "import { AnyRoute } from './route'\nimport { RouteIds, RouteById } from './routeInfo'\nimport { RegisteredRouter } from './router'\nimport { RouteMatch } from './Matches'\nimport { useMatch } from './Matches'\nimport { StrictOrFrom } from './utils'\n\nexport function useSearch<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TStrict extends boolean = true,\n  TSearch = RouteById<TRouteTree, TFrom>['types']['fullSearchSchema'],\n  TSelected = TSearch,\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (search: TSearch) => TSelected\n  },\n): TStrict extends true ? TSelected : TSelected | undefined {\n  return useMatch({\n    ...(opts as any),\n    select: (match: RouteMatch) => {\n      return opts?.select ? opts.select(match.search as TSearch) : match.search\n    },\n  })\n}\n", "import * as React from 'react'\nimport invariant from 'tiny-invariant'\nimport { useLoaderData, useLoaderDeps, useMatch } from './Matches'\nimport { AnyRouteMatch } from './Matches'\nimport { NavigateOptions, ParsePathParams, ToSubOptions } from './link'\nimport { ParsedLocation } from './location'\nimport { joinPaths, trimPath } from './path'\nimport { RouteById, RouteIds, RoutePaths } from './routeInfo'\nimport { AnyRouter, RegisteredRouter } from './router'\nimport { useParams } from './useParams'\nimport { useSearch } from './useSearch'\nimport {\n  Assign,\n  Expand,\n  IsAny,\n  NoInfer,\n  PickRequired,\n  UnionToIntersection,\n} from './utils'\nimport { BuildLocationFn, NavigateFn } from './RouterProvider'\n\nexport const rootRouteId = '__root__' as const\nexport type RootRouteId = typeof rootRouteId\nexport type AnyPathParams = {}\n\nexport type AnySearchSchema = {}\n\nexport type AnyContext = {}\n\nexport interface RouteContext {}\n\nexport interface RouteMeta {}\n\nexport type PreloadableObj = { preload?: () => Promise<void> }\n\nexport type RoutePathOptions<TCustomId, TPath> =\n  | {\n      path: TPath\n    }\n  | {\n      id: TCustomId\n    }\n\nexport type RoutePathOptionsIntersection<TCustomId, TPath> =\n  UnionToIntersection<RoutePathOptions<TCustomId, TPath>>\n\nexport type MetaOptions = keyof PickRequired<RouteMeta> extends never\n  ? {\n      meta?: RouteMeta\n    }\n  : {\n      meta: RouteMeta\n    }\n\nexport type RouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TCustomId extends string = string,\n  TPath extends string = string,\n  TSearchSchema extends Record<string, any> = {},\n  TFullSearchSchema extends Record<string, any> = TSearchSchema,\n  TParams extends AnyPathParams = AnyPathParams,\n  TAllParams extends AnyPathParams = TParams,\n  TRouteContext extends RouteContext = RouteContext,\n  TAllContext extends Record<string, any> = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderData extends any = unknown,\n> = BaseRouteOptions<\n  TParentRoute,\n  TCustomId,\n  TPath,\n  TSearchSchema,\n  TFullSearchSchema,\n  TParams,\n  TAllParams,\n  TRouteContext,\n  TAllContext,\n  TLoaderDeps,\n  TLoaderData\n> &\n  UpdatableRouteOptions<NoInfer<TFullSearchSchema>>\n\nexport type ParamsFallback<\n  TPath extends string,\n  TParams,\n> = unknown extends TParams ? Record<ParsePathParams<TPath>, string> : TParams\n\nexport type BaseRouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TCustomId extends string = string,\n  TPath extends string = string,\n  TSearchSchema extends Record<string, any> = {},\n  TFullSearchSchema extends Record<string, any> = TSearchSchema,\n  TParams extends AnyPathParams = {},\n  TAllParams = ParamsFallback<TPath, TParams>,\n  TRouteContext extends RouteContext = RouteContext,\n  TAllContext extends Record<string, any> = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderData extends any = unknown,\n> = RoutePathOptions<TCustomId, TPath> & {\n  getParentRoute: () => TParentRoute\n  validateSearch?: SearchSchemaValidator<TSearchSchema>\n  shouldReload?:\n    | boolean\n    | ((\n        match: LoaderFnContext<\n          TAllParams,\n          TFullSearchSchema,\n          TAllContext,\n          TRouteContext\n        >,\n      ) => any)\n} & (keyof PickRequired<RouteContext> extends never\n    ? // This async function is called before a route is loaded.\n      // If an error is thrown here, the route's loader will not be called.\n      // If thrown during a navigation, the navigation will be cancelled and the error will be passed to the `onError` function.\n      // If thrown during a preload event, the error will be logged to the console.\n      {\n        beforeLoad?: BeforeLoadFn<\n          TFullSearchSchema,\n          TParentRoute,\n          TAllParams,\n          TRouteContext\n        >\n      }\n    : {\n        beforeLoad: BeforeLoadFn<\n          TFullSearchSchema,\n          TParentRoute,\n          TAllParams,\n          TRouteContext\n        >\n      }) & {\n    loaderDeps?: (opts: { search: TFullSearchSchema }) => TLoaderDeps\n    loader?: RouteLoaderFn<\n      TAllParams,\n      NoInfer<TLoaderDeps>,\n      NoInfer<TAllContext>,\n      NoInfer<TRouteContext>,\n      TLoaderData\n    >\n  } & (\n    | {\n        // Both or none\n        parseParams?: (\n          rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>,\n        ) => TParams extends Record<ParsePathParams<TPath>, any>\n          ? TParams\n          : 'parseParams must return an object'\n        stringifyParams?: (\n          params: NoInfer<ParamsFallback<TPath, TParams>>,\n        ) => Record<ParsePathParams<TPath>, string>\n      }\n    | {\n        stringifyParams?: never\n        parseParams?: never\n      }\n  )\n\ntype BeforeLoadFn<\n  TFullSearchSchema extends Record<string, any>,\n  TParentRoute extends AnyRoute,\n  TAllParams,\n  TRouteContext,\n> = (opts: {\n  search: TFullSearchSchema\n  abortController: AbortController\n  preload: boolean\n  params: TAllParams\n  context: TParentRoute['types']['allContext']\n  location: ParsedLocation\n  navigate: NavigateFn<AnyRoute>\n  buildLocation: BuildLocationFn<TParentRoute>\n  cause: 'preload' | 'enter' | 'stay'\n}) => Promise<TRouteContext> | TRouteContext | void\n\nexport type UpdatableRouteOptions<\n  TFullSearchSchema extends Record<string, any>,\n> = MetaOptions & {\n  // test?: (args: TAllContext) => void\n  // If true, this route will be matched as case-sensitive\n  caseSensitive?: boolean\n  // If true, this route will be forcefully wrapped in a suspense boundary\n  wrapInSuspense?: boolean\n  // The content to be rendered when the route is matched. If no component is provided, defaults to `<Outlet />`\n  component?: RouteComponent\n  errorComponent?: false | null | ErrorRouteComponent\n  pendingComponent?: RouteComponent\n  pendingMs?: number\n  pendingMinMs?: number\n  staleTime?: number\n  gcTime?: number\n  preloadStaleTime?: number\n  preloadGcTime?: number\n  // Filter functions that can manipulate search params *before* they are passed to links and navigate\n  // calls that match this route.\n  preSearchFilters?: SearchFilter<TFullSearchSchema>[]\n  // Filter functions that can manipulate search params *after* they are passed to links and navigate\n  // calls that match this route.\n  postSearchFilters?: SearchFilter<TFullSearchSchema>[]\n  onError?: (err: any) => void\n  // These functions are called as route matches are loaded, stick around and leave the active\n  // matches\n  onEnter?: (match: AnyRouteMatch) => void\n  onStay?: (match: AnyRouteMatch) => void\n  onLeave?: (match: AnyRouteMatch) => void\n}\n\nexport type ParseParamsOption<TPath extends string, TParams> = ParseParamsFn<\n  TPath,\n  TParams\n>\n\nexport type ParseParamsFn<TPath extends string, TParams> = (\n  rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>,\n) => TParams extends Record<ParsePathParams<TPath>, any>\n  ? TParams\n  : 'parseParams must return an object'\n\nexport type ParseParamsObj<TPath extends string, TParams> = {\n  parse?: ParseParamsFn<TPath, TParams>\n}\n\n// The parse type here allows a zod schema to be passed directly to the validator\nexport type SearchSchemaValidator<TReturn> =\n  | SearchSchemaValidatorObj<TReturn>\n  | SearchSchemaValidatorFn<TReturn>\n\nexport type SearchSchemaValidatorObj<TReturn> = {\n  parse?: SearchSchemaValidatorFn<TReturn>\n}\n\nexport type SearchSchemaValidatorFn<TReturn> = (\n  searchObj: Record<string, unknown>,\n) => TReturn\n\nexport type DefinedPathParamWarning =\n  'Path params cannot be redefined by child routes!'\n\nexport type ParentParams<TParentParams> = AnyPathParams extends TParentParams\n  ? {}\n  : {\n      [Key in keyof TParentParams]?: DefinedPathParamWarning\n    }\n\nexport type RouteLoaderFn<\n  TAllParams = {},\n  TLoaderDeps extends Record<string, any> = {},\n  TAllContext extends Record<string, any> = AnyContext,\n  TRouteContext extends Record<string, any> = AnyContext,\n  TLoaderData extends any = unknown,\n> = (\n  match: LoaderFnContext<TAllParams, TLoaderDeps, TAllContext, TRouteContext>,\n) => Promise<TLoaderData> | TLoaderData\n\nexport interface LoaderFnContext<\n  TAllParams = {},\n  TLoaderDeps extends Record<string, any> = {},\n  TAllContext extends Record<string, any> = AnyContext,\n  TRouteContext extends Record<string, any> = AnyContext,\n> {\n  abortController: AbortController\n  preload: boolean\n  params: TAllParams\n  deps: TLoaderDeps\n  context: Expand<Assign<TAllContext, TRouteContext>>\n  location: ParsedLocation // Do not supply search schema here so as to demotivate people from trying to shortcut loaderDeps\n  navigate: (opts: NavigateOptions<AnyRoute>) => Promise<void>\n  parentMatchPromise?: Promise<void>\n  cause: 'preload' | 'enter' | 'stay'\n}\n\nexport type SearchFilter<T, U = T> = (prev: T) => U\n\nexport type ResolveId<\n  TParentRoute,\n  TCustomId extends string,\n  TPath extends string,\n> = TParentRoute extends { id: infer TParentId extends string }\n  ? RoutePrefix<TParentId, string extends TCustomId ? TPath : TCustomId>\n  : RootRouteId\n\nexport type InferFullSearchSchema<TRoute> = TRoute extends {\n  types: {\n    fullSearchSchema: infer TFullSearchSchema\n  }\n}\n  ? TFullSearchSchema\n  : {}\n\nexport type ResolveFullSearchSchema<TParentRoute, TSearchSchema> = Expand<\n  Assign<InferFullSearchSchema<TParentRoute>, TSearchSchema>\n>\n\nexport interface AnyRoute\n  extends Route<\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  > {}\n\nexport type MergeFromFromParent<T, U> = IsAny<T, U, T & U>\n\nexport type ResolveAllParams<\n  TParentRoute extends AnyRoute,\n  TParams extends AnyPathParams,\n> = Record<never, string> extends TParentRoute['types']['allParams']\n  ? TParams\n  : Expand<\n      UnionToIntersection<TParentRoute['types']['allParams'] & TParams> & {}\n    >\n\nexport type RouteConstraints = {\n  TParentRoute: AnyRoute\n  TPath: string\n  TFullPath: string\n  TCustomId: string\n  TId: string\n  TSearchSchema: AnySearchSchema\n  TFullSearchSchema: AnySearchSchema\n  TParams: Record<string, any>\n  TAllParams: Record<string, any>\n  TParentContext: AnyContext\n  TRouteContext: RouteContext\n  TAllContext: AnyContext\n  TRouterContext: AnyContext\n  TChildren: unknown\n  TRouteTree: AnyRoute\n}\n\nexport class RouteApi<\n  TId extends RouteIds<RegisteredRouter['routeTree']>,\n  TRoute extends AnyRoute = RouteById<RegisteredRouter['routeTree'], TId>,\n  TFullSearchSchema extends Record<\n    string,\n    any\n  > = TRoute['types']['fullSearchSchema'],\n  TAllParams extends AnyPathParams = TRoute['types']['allParams'],\n  TAllContext extends Record<string, any> = TRoute['types']['allContext'],\n  TLoaderDeps extends Record<string, any> = TRoute['types']['loaderDeps'],\n  TLoaderData extends any = TRoute['types']['loaderData'],\n> {\n  id: TId\n\n  constructor({ id }: { id: TId }) {\n    this.id = id as any\n  }\n\n  useMatch = <TSelected = TAllContext>(opts?: {\n    select?: (s: TAllContext) => TSelected\n  }): TSelected => {\n    return useMatch({ ...opts, from: this.id }) as any\n  }\n\n  useRouteContext = <TSelected = TAllContext>(opts?: {\n    select?: (s: TAllContext) => TSelected\n  }): TSelected => {\n    return useMatch({\n      ...opts,\n      from: this.id,\n      select: (d: any) => (opts?.select ? opts.select(d.context) : d.context),\n    } as any)\n  }\n\n  useSearch = <TSelected = TFullSearchSchema>(opts?: {\n    select?: (s: TFullSearchSchema) => TSelected\n  }): TSelected => {\n    return useSearch({ ...opts, from: this.id } as any)\n  }\n\n  useParams = <TSelected = TAllParams>(opts?: {\n    select?: (s: TAllParams) => TSelected\n  }): TSelected => {\n    return useParams({ ...opts, from: this.id } as any)\n  }\n\n  useLoaderDeps = <TSelected = TLoaderDeps>(opts?: {\n    select?: (s: TLoaderDeps) => TSelected\n  }): TSelected => {\n    return useLoaderDeps({ ...opts, from: this.id } as any) as any\n  }\n\n  useLoaderData = <TSelected = TLoaderData>(opts?: {\n    select?: (s: TLoaderData) => TSelected\n  }): TSelected => {\n    return useLoaderData({ ...opts, from: this.id } as any) as any\n  }\n}\n\nexport class Route<\n  TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute,\n  TPath extends RouteConstraints['TPath'] = '/',\n  TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\n    TParentRoute,\n    TPath\n  >,\n  TCustomId extends RouteConstraints['TCustomId'] = string,\n  TId extends RouteConstraints['TId'] = ResolveId<\n    TParentRoute,\n    TCustomId,\n    TPath\n  >,\n  TSearchSchema extends RouteConstraints['TSearchSchema'] = {},\n  TFullSearchSchema extends\n    RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchema<\n    TParentRoute,\n    TSearchSchema\n  >,\n  TParams extends RouteConstraints['TParams'] = Expand<\n    Record<ParsePathParams<TPath>, string>\n  >,\n  TAllParams extends RouteConstraints['TAllParams'] = ResolveAllParams<\n    TParentRoute,\n    TParams\n  >,\n  TRouteContext extends RouteConstraints['TRouteContext'] = RouteContext,\n  TAllContext extends Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  > = Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  >,\n  TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderData extends any = unknown,\n  TChildren extends RouteConstraints['TChildren'] = unknown,\n  TRouteTree extends RouteConstraints['TRouteTree'] = AnyRoute,\n> {\n  isRoot: TParentRoute extends Route<any> ? true : false\n  options: RouteOptions<\n    TParentRoute,\n    TCustomId,\n    TPath,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContext,\n    TAllContext,\n    TLoaderDeps,\n    TLoaderData\n  >\n\n  test!: Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  >\n\n  // Set up in this.init()\n  parentRoute!: TParentRoute\n  id!: TId\n  // customId!: TCustomId\n  path!: TPath\n  fullPath!: TFullPath\n  to!: TrimPathRight<TFullPath>\n\n  // Optional\n  children?: TChildren\n  originalIndex?: number\n  router?: AnyRouter\n  rank!: number\n\n  constructor(\n    options: RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParams,\n      TAllParams,\n      TRouteContext,\n      TAllContext,\n      TLoaderDeps,\n      TLoaderData\n    >,\n  ) {\n    this.options = (options as any) || {}\n    this.isRoot = !options?.getParentRoute as any\n    invariant(\n      !((options as any)?.id && (options as any)?.path),\n      `Route cannot have both an 'id' and a 'path' option.`,\n    )\n    ;(this as any).$$typeof = Symbol.for('react.memo')\n  }\n\n  types!: {\n    parentRoute: TParentRoute\n    path: TPath\n    to: TrimPathRight<TFullPath>\n    fullPath: TFullPath\n    customId: TCustomId\n    id: TId\n    searchSchema: TSearchSchema\n    fullSearchSchema: TFullSearchSchema\n    params: TParams\n    allParams: TAllParams\n    routeContext: TRouteContext\n    allContext: TAllContext\n    children: TChildren\n    routeTree: TRouteTree\n    routerContext: TRouterContext\n    loaderData: TLoaderData\n    loaderDeps: TLoaderDeps\n  }\n\n  init = (opts: { originalIndex: number }) => {\n    this.originalIndex = opts.originalIndex\n\n    const options = this.options as RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParams,\n      TAllParams,\n      TRouteContext,\n      TAllContext,\n      TLoaderDeps,\n      TLoaderData\n    > &\n      RoutePathOptionsIntersection<TCustomId, TPath>\n\n    const isRoot = !options?.path && !options?.id\n\n    this.parentRoute = this.options?.getParentRoute?.()\n\n    if (isRoot) {\n      this.path = rootRouteId as TPath\n    } else {\n      invariant(\n        this.parentRoute,\n        `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`,\n      )\n    }\n\n    let path: undefined | string = isRoot ? rootRouteId : options.path\n\n    // If the path is anything other than an index path, trim it up\n    if (path && path !== '/') {\n      path = trimPath(path)\n    }\n\n    const customId = options?.id || path\n\n    // Strip the parentId prefix from the first level of children\n    let id = isRoot\n      ? rootRouteId\n      : joinPaths([\n          (this.parentRoute.id as any) === rootRouteId\n            ? ''\n            : this.parentRoute.id,\n          customId,\n        ])\n\n    if (path === rootRouteId) {\n      path = '/'\n    }\n\n    if (id !== rootRouteId) {\n      id = joinPaths(['/', id])\n    }\n\n    const fullPath =\n      id === rootRouteId ? '/' : joinPaths([this.parentRoute.fullPath, path])\n\n    this.path = path as TPath\n    this.id = id as TId\n    // this.customId = customId as TCustomId\n    this.fullPath = fullPath as TFullPath\n    this.to = fullPath as TrimPathRight<TFullPath>\n  }\n\n  addChildren = <TNewChildren extends AnyRoute[]>(\n    children: TNewChildren,\n  ): Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContext,\n    TAllContext,\n    TRouterContext,\n    TLoaderDeps,\n    TLoaderData,\n    TNewChildren,\n    TRouteTree\n  > => {\n    this.children = children as any\n    return this as any\n  }\n\n  update = (options: UpdatableRouteOptions<TFullSearchSchema>) => {\n    Object.assign(this.options, options)\n    return this\n  }\n\n  useMatch = <TSelected = TAllContext>(opts?: {\n    select?: (search: TAllContext) => TSelected\n  }): TSelected => {\n    return useMatch({ ...opts, from: this.id }) as any\n  }\n\n  useRouteContext = <TSelected = TAllContext>(opts?: {\n    select?: (search: TAllContext) => TSelected\n  }): TSelected => {\n    return useMatch({\n      ...opts,\n      from: this.id,\n      select: (d: any) => (opts?.select ? opts.select(d.context) : d.context),\n    } as any)\n  }\n\n  useSearch = <TSelected = TFullSearchSchema>(opts?: {\n    select?: (search: TFullSearchSchema) => TSelected\n  }): TSelected => {\n    return useSearch({ ...opts, from: this.id } as any)\n  }\n\n  useParams = <TSelected = TAllParams>(opts?: {\n    select?: (search: TAllParams) => TSelected\n  }): TSelected => {\n    return useParams({ ...opts, from: this.id } as any)\n  }\n\n  useLoaderDeps = <TSelected = TLoaderDeps>(opts?: {\n    select?: (s: TLoaderDeps) => TSelected\n  }): TSelected => {\n    return useLoaderDeps({ ...opts, from: this.id } as any) as any\n  }\n\n  useLoaderData = <TSelected = TLoaderData>(opts?: {\n    select?: (search: TLoaderData) => TSelected\n  }): TSelected => {\n    return useLoaderData({ ...opts, from: this.id } as any) as any\n  }\n}\n\nexport type AnyRootRoute = RootRoute<any, any, any, any>\n\nexport function rootRouteWithContext<TRouterContext extends {}>() {\n  return <\n    TSearchSchema extends Record<string, any> = {},\n    TRouteContext extends RouteContext = RouteContext,\n    TLoaderDeps extends Record<string, any> = {},\n    TLoaderData extends any = unknown,\n  >(\n    options?: Omit<\n      RouteOptions<\n        AnyRoute, // TParentRoute\n        RootRouteId, // TCustomId\n        '', // TPath\n        TSearchSchema, // TSearchSchema\n        TSearchSchema, // TFullSearchSchema\n        {}, // TParams\n        {}, // TAllParams\n        TRouteContext, // TRouteContext\n        Assign<TRouterContext, TRouteContext>, // TAllContext\n        TLoaderDeps,\n        TLoaderData // TLoaderData,\n      >,\n      | 'path'\n      | 'id'\n      | 'getParentRoute'\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n    >,\n  ): RootRoute<TSearchSchema, TRouteContext, TRouterContext> => {\n    return new RootRoute(options) as any\n  }\n}\n\nexport class RootRoute<\n  TSearchSchema extends Record<string, any> = {},\n  TRouteContext extends RouteContext = RouteContext,\n  TRouterContext extends {} = {},\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderData extends any = unknown,\n> extends Route<\n  any, // TParentRoute\n  '/', // TPath\n  '/', // TFullPath\n  string, // TCustomId\n  RootRouteId, // TId\n  TSearchSchema, // TSearchSchema\n  TSearchSchema, // TFullSearchSchema\n  {}, // TParams\n  {}, // TAllParams\n  TRouteContext, // TRouteContext\n  Expand<Assign<TRouterContext, TRouteContext>>, // TAllContext\n  TRouterContext, // TRouterContext\n  TLoaderDeps,\n  TLoaderData,\n  any, // TChildren\n  any // TRouteTree\n> {\n  constructor(\n    options?: Omit<\n      RouteOptions<\n        AnyRoute, // TParentRoute\n        RootRouteId, // TCustomId\n        '', // TPath\n        TSearchSchema, // TSearchSchema\n        TSearchSchema, // TFullSearchSchema\n        {}, // TParams\n        {}, // TAllParams\n        TRouteContext, // TRouteContext\n        Assign<TRouterContext, TRouteContext>, // TAllContext\n        TLoaderDeps,\n        TLoaderData\n      >,\n      | 'path'\n      | 'id'\n      | 'getParentRoute'\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n    >,\n  ) {\n    super(options as any)\n  }\n}\n\nexport type ResolveFullPath<\n  TParentRoute extends AnyRoute,\n  TPath extends string,\n  TPrefixed = RoutePrefix<TParentRoute['fullPath'], TPath>,\n> = TPrefixed extends RootRouteId ? '/' : TPrefixed\n\ntype RoutePrefix<\n  TPrefix extends string,\n  TPath extends string,\n> = string extends TPath\n  ? RootRouteId\n  : TPath extends string\n    ? TPrefix extends RootRouteId\n      ? TPath extends '/'\n        ? '/'\n        : `/${TrimPath<TPath>}`\n      : `${TPrefix}/${TPath}` extends '/'\n        ? '/'\n        : `/${TrimPathLeft<`${TrimPathRight<TPrefix>}/${TrimPath<TPath>}`>}`\n    : never\n\nexport type TrimPath<T extends string> = '' extends T\n  ? ''\n  : TrimPathRight<TrimPathLeft<T>>\n\nexport type TrimPathLeft<T extends string> =\n  T extends `${RootRouteId}/${infer U}`\n    ? TrimPathLeft<U>\n    : T extends `/${infer U}`\n      ? TrimPathLeft<U>\n      : T\nexport type TrimPathRight<T extends string> = T extends '/'\n  ? '/'\n  : T extends `${infer U}/`\n    ? TrimPathRight<U>\n    : T\n\nexport type RouteMask<TRouteTree extends AnyRoute> = {\n  routeTree: TRouteTree\n  from: RoutePaths<TRouteTree>\n  to?: any\n  params?: any\n  search?: any\n  hash?: any\n  state?: any\n  unmaskOnReload?: boolean\n}\n\nexport function createRouteMask<\n  TRouteTree extends AnyRoute,\n  TFrom extends RoutePaths<TRouteTree>,\n  TTo extends string,\n>(\n  opts: {\n    routeTree: TRouteTree\n  } & ToSubOptions<TRouteTree, TFrom, TTo>,\n): RouteMask<TRouteTree> {\n  return opts as any\n}\n\nexport type ErrorRouteProps = {\n  error: unknown\n  info: { componentStack: string }\n}\n//\n\nexport type ReactNode = any\n\nexport type SyncRouteComponent<TProps> =\n  | ((props: TProps) => ReactNode)\n  | React.LazyExoticComponent<(props: TProps) => ReactNode>\n\nexport type AsyncRouteComponent<TProps> = SyncRouteComponent<TProps> & {\n  preload?: () => Promise<void>\n}\n\nexport type RouteComponent<TProps = any> = SyncRouteComponent<TProps> &\n  AsyncRouteComponent<TProps>\n\nexport type ErrorRouteComponent = RouteComponent<ErrorRouteProps>\n\nexport class NotFoundRoute<\n  TParentRoute extends AnyRootRoute,\n  TSearchSchema extends RouteConstraints['TSearchSchema'] = {},\n  TFullSearchSchema extends\n    RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchema<\n    TParentRoute,\n    TSearchSchema\n  >,\n  TRouteContext extends RouteConstraints['TRouteContext'] = RouteContext,\n  TAllContext extends Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  > = Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  >,\n  TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  TLoaderDeps extends Record<string, any> = {},\n  TLoaderData extends any = unknown,\n  TChildren extends RouteConstraints['TChildren'] = unknown,\n  TRouteTree extends RouteConstraints['TRouteTree'] = AnyRoute,\n> extends Route<\n  TParentRoute,\n  '/404',\n  '/404',\n  '404',\n  '404',\n  TSearchSchema,\n  TFullSearchSchema,\n  {},\n  {},\n  TRouteContext,\n  TAllContext,\n  TRouterContext,\n  TLoaderDeps,\n  TLoaderData,\n  TChildren,\n  TRouteTree\n> {\n  constructor(\n    options: Omit<\n      RouteOptions<\n        TParentRoute,\n        string,\n        string,\n        TSearchSchema,\n        TFullSearchSchema,\n        {},\n        {},\n        TRouteContext,\n        TAllContext,\n        TLoaderDeps,\n        TLoaderData\n      >,\n      'caseSensitive' | 'parseParams' | 'stringifyParams' | 'path' | 'id'\n    >,\n  ) {\n    super({\n      ...(options as any),\n      id: '404',\n    })\n  }\n}\n", "import { ParsePathParams } from './link'\nimport {\n  AnyRoute,\n  ResolveFullPath,\n  ResolveFullSearchSchema,\n  MergeFromFromParent,\n  RouteContext,\n  AnyContext,\n  RouteOptions,\n  UpdatableRouteOptions,\n  Route,\n  AnyPathParams,\n  RootRouteId,\n  TrimPathLeft,\n  RouteConstraints,\n} from './route'\nimport { Assign, Expand, IsAny } from './utils'\n\nexport interface FileRoutesByPath {\n  // '/': {\n  //   parentRoute: typeof rootRoute\n  // }\n}\n\ntype Replace<\n  S extends string,\n  From extends string,\n  To extends string,\n> = S extends `${infer Start}${From}${infer Rest}`\n  ? `${Start}${To}${Replace<Rest, From, To>}`\n  : S\n\nexport type TrimLeft<\n  T extends string,\n  S extends string,\n> = T extends `${S}${infer U}` ? U : T\n\nexport type TrimRight<\n  T extends string,\n  S extends string,\n> = T extends `${infer U}${S}` ? U : T\n\nexport type Trim<T extends string, S extends string> = TrimLeft<\n  TrimRight<T, S>,\n  S\n>\n\nexport type RemoveUnderScores<T extends string> = Replace<\n  Replace<TrimRight<TrimLeft<T, '/_'>, '_'>, '_/', '/'>,\n  '/_',\n  '/'\n>\n\nexport type ResolveFilePath<\n  TParentRoute extends AnyRoute,\n  TFilePath extends string,\n> = TParentRoute['id'] extends RootRouteId\n  ? TrimPathLeft<TFilePath>\n  : Replace<\n      TrimPathLeft<TFilePath>,\n      TrimPathLeft<TParentRoute['types']['customId']>,\n      ''\n    >\n\nexport type FileRoutePath<\n  TParentRoute extends AnyRoute,\n  TFilePath extends string,\n> = ResolveFilePath<TParentRoute, TFilePath> extends `_${infer _}`\n  ? string\n  : ResolveFilePath<TParentRoute, TFilePath>\n\nexport class FileRoute<\n  TFilePath extends keyof FileRoutesByPath,\n  TParentRoute extends AnyRoute = FileRoutesByPath[TFilePath]['parentRoute'],\n  TId extends RouteConstraints['TId'] = TFilePath,\n  TPath extends RouteConstraints['TPath'] = FileRoutePath<\n    TParentRoute,\n    TFilePath\n  >,\n  TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\n    TParentRoute,\n    RemoveUnderScores<TPath>\n  >,\n> {\n  constructor(public path: TFilePath) {}\n\n  createRoute = <\n    TSearchSchema extends RouteConstraints['TSearchSchema'] = {},\n    TFullSearchSchema extends\n      RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchema<\n      TParentRoute,\n      TSearchSchema\n    >,\n    TParams extends RouteConstraints['TParams'] = Expand<\n      Record<ParsePathParams<TPath>, string>\n    >,\n    TAllParams extends RouteConstraints['TAllParams'] = MergeFromFromParent<\n      TParentRoute['types']['allParams'],\n      TParams\n    >,\n    TRouteContext extends RouteConstraints['TRouteContext'] = RouteContext,\n    TContext extends Expand<\n      Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n    > = Expand<\n      Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n    >,\n    TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n    TLoaderDeps extends Record<string, any> = {},\n    TLoaderData extends any = unknown,\n    TChildren extends RouteConstraints['TChildren'] = unknown,\n    TRouteTree extends RouteConstraints['TRouteTree'] = AnyRoute,\n  >(\n    options?: Omit<\n      RouteOptions<\n        TParentRoute,\n        string,\n        TPath,\n        TSearchSchema,\n        TFullSearchSchema,\n        TParams,\n        TAllParams,\n        TRouteContext,\n        TContext,\n        TLoaderDeps,\n        TLoaderData\n      >,\n      'getParentRoute' | 'path' | 'id'\n    > &\n      UpdatableRouteOptions<TFullSearchSchema>,\n  ): Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TFilePath,\n    TId,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContext,\n    TContext,\n    TRouterContext,\n    TLoaderDeps,\n    TLoaderData,\n    TChildren,\n    TRouteTree\n  > => {\n    const route = new Route(options as any)\n    ;(route as any).isRoot = false\n    return route as any\n  }\n}\n", "import * as React from 'react'\nimport { AsyncRouteComponent } from './route'\n\nexport function lazyRouteComponent<\n  T extends Record<string, any>,\n  TKey extends keyof T = 'default',\n>(\n  importer: () => Promise<T>,\n  exportName?: TKey,\n): T[TKey] extends (props: infer TProps) => any\n  ? AsyncRouteComponent<TProps>\n  : never {\n  let loadPromise: Promise<any>\n\n  const load = () => {\n    if (!loadPromise) {\n      loadPromise = importer()\n    }\n\n    return loadPromise\n  }\n\n  const lazyComp = React.lazy(async () => {\n    const moduleExports = await load()\n    const comp = moduleExports[exportName ?? 'default']\n    return {\n      default: comp,\n    }\n  })\n  ;(lazyComp as any).preload = load\n\n  return lazyComp as any\n}\n", "import * as React from 'react'\nimport { useMatch } from './Matches'\nimport { useRouter, useRouterState } from './RouterProvider'\nimport { Trim } from './fileRoute'\nimport { AnyRoute, ReactNode } from './route'\nimport {\n  AllParams,\n  FullSearchSchema,\n  RouteByPath,\n  RouteIds,\n  RoutePaths,\n} from './routeInfo'\nimport { RegisteredRouter } from './router'\nimport { LinkProps, UseLinkPropsOptions } from './useNavigate'\nimport {\n  Expand,\n  NoInfer,\n  NonNullableUpdater,\n  PickRequired,\n  UnionToIntersection,\n  Updater,\n  deepEqual,\n  functionalUpdate,\n} from './utils'\nimport { HistoryState } from '@tanstack/history'\n\nexport type CleanPath<T extends string> = T extends `${infer L}//${infer R}`\n  ? CleanPath<`${CleanPath<L>}/${CleanPath<R>}`>\n  : T extends `${infer L}//`\n    ? `${CleanPath<L>}/`\n    : T extends `//${infer L}`\n      ? `/${CleanPath<L>}`\n      : T\n\nexport type Split<S, TIncludeTrailingSlash = true> = S extends unknown\n  ? string extends S\n    ? string[]\n    : S extends string\n      ? CleanPath<S> extends ''\n        ? []\n        : TIncludeTrailingSlash extends true\n          ? CleanPath<S> extends `${infer T}/`\n            ? [...Split<T>, '/']\n            : CleanPath<S> extends `/${infer U}`\n              ? Split<U>\n              : CleanPath<S> extends `${infer T}/${infer U}`\n                ? [...Split<T>, ...Split<U>]\n                : [S]\n          : CleanPath<S> extends `${infer T}/${infer U}`\n            ? [...Split<T>, ...Split<U>]\n            : S extends string\n              ? [S]\n              : never\n      : never\n  : never\n\nexport type ParsePathParams<T extends string> = keyof {\n  [K in Trim<Split<T>[number], '_'> as K extends `$${infer L}` ? L : never]: K\n}\n\nexport type Join<T, Delimiter extends string = '/'> = T extends []\n  ? ''\n  : T extends [infer L extends string]\n    ? L\n    : T extends [infer L extends string, ...infer Tail extends [...string[]]]\n      ? CleanPath<`${L}${Delimiter}${Join<Tail>}`>\n      : never\n\nexport type Last<T extends any[]> = T extends [...infer _, infer L] ? L : never\n\nexport type RelativeToPathAutoComplete<\n  AllPaths extends string,\n  TFrom extends string,\n  TTo extends string,\n  SplitPaths extends string[] = Split<AllPaths, false>,\n> = TTo extends `..${infer _}`\n  ? SplitPaths extends [\n      ...Split<ResolveRelativePath<TFrom, TTo>, false>,\n      ...infer TToRest,\n    ]\n    ? `${CleanPath<\n        Join<\n          [\n            ...Split<TTo, false>,\n            ...(\n              | TToRest\n              | (Split<\n                  ResolveRelativePath<TFrom, TTo>,\n                  false\n                >['length'] extends 1\n                  ? never\n                  : ['../'])\n            ),\n          ]\n        >\n      >}`\n    : never\n  : TTo extends `./${infer RestTTo}`\n    ? SplitPaths extends [\n        ...Split<TFrom, false>,\n        ...Split<RestTTo, false>,\n        ...infer RestPath,\n      ]\n      ? `${TTo}${Join<RestPath>}`\n      : never\n    :\n        | (TFrom extends `/`\n            ? never\n            : SplitPaths extends [...Split<TFrom, false>, ...infer RestPath]\n              ? Join<RestPath> extends { length: 0 }\n                ? never\n                : './'\n              : never)\n        | (TFrom extends `/` ? never : '../')\n        | AllPaths\n\nexport type NavigateOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n> = ToOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // `replace` is a boolean that determines whether the navigation should replace the current history entry or push a new one.\n  replace?: boolean\n  resetScroll?: boolean\n  // If set to `true`, the link's underlying navigate() call will be wrapped in a `React.startTransition` call. Defaults to `true`.\n  startTransition?: boolean\n}\n\nexport type ToOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ToSubOptions<TRouteTree, TFrom, TTo> & {\n  mask?: ToMaskOptions<TRouteTree, TMaskFrom, TMaskTo>\n}\n\nexport type ToMaskOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ToSubOptions<TRouteTree, TMaskFrom, TMaskTo> & {\n  unmaskOnReload?: boolean\n}\n\nexport type ToSubOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n> = {\n  to?: ToPathOption<TRouteTree, TFrom, TTo>\n  // The new has string or a function to update it\n  hash?: true | Updater<string>\n  // State to pass to the history stack\n  state?: true | NonNullableUpdater<HistoryState>\n  // The source route path. This is automatically set when using route-level APIs, but for type-safe relative routing on the router itself, this is required\n  from?: TFrom\n  // // When using relative route paths, this option forces resolution from the current path, instead of the route API's path or `from` path\n} & CheckPath<TRouteTree, NoInfer<TResolved>, {}> &\n  SearchParamOptions<TRouteTree, TFrom, TTo, TResolved> &\n  PathParamOptions<TRouteTree, TFrom, TResolved>\n\nexport type SearchParamOptions<\n  TRouteTree extends AnyRoute,\n  TFrom,\n  TTo,\n  TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n  TFromSearchEnsured = '/' extends TFrom\n    ? FullSearchSchema<TRouteTree>\n    : Expand<\n          PickRequired<\n            RouteByPath<TRouteTree, TFrom>['types']['fullSearchSchema']\n          >\n      >,\n  TFromSearchOptional = Omit<\n    FullSearchSchema<TRouteTree>,\n    keyof TFromSearchEnsured\n  >,\n  TFromSearch = Expand<TFromSearchEnsured & TFromSearchOptional>,\n  TToSearch = '' extends TTo\n    ? FullSearchSchema<TRouteTree>\n    : Expand<RouteByPath<TRouteTree, TResolved>['types']['fullSearchSchema']>,\n> = keyof PickRequired<TToSearch> extends never\n  ? {\n      search?: true | SearchReducer<TFromSearch, TToSearch>\n    }\n  : {\n      search: TFromSearchEnsured extends PickRequired<TToSearch>\n        ? true | SearchReducer<TFromSearch, TToSearch>\n        : SearchReducer<TFromSearch, TToSearch>\n    }\n\ntype SearchReducer<TFrom, TTo> = TTo | ((current: TFrom) => TTo)\n\nexport type PathParamOptions<\n  TRouteTree extends AnyRoute,\n  TFrom,\n  TTo,\n  TFromParamsEnsured = Expand<\n    UnionToIntersection<\n      PickRequired<RouteByPath<TRouteTree, TFrom>['types']['allParams']>\n    >\n  >,\n  TFromParamsOptional = Omit<AllParams<TRouteTree>, keyof TFromParamsEnsured>,\n  TFromParams = Expand<TFromParamsOptional & TFromParamsEnsured>,\n  TToParams = Expand<RouteByPath<TRouteTree, TTo>['types']['allParams']>,\n> = never extends TToParams\n  ? {\n      params?: true | ParamsReducer<Partial<TFromParams>, Partial<TFromParams>>\n    }\n  : keyof PickRequired<TToParams> extends never\n    ? {\n        params?: true | ParamsReducer<TFromParams, TToParams>\n      }\n    : {\n        params: TFromParamsEnsured extends PickRequired<TToParams>\n          ? true | ParamsReducer<TFromParams, TToParams>\n          : ParamsReducer<TFromParams, TToParams>\n      }\n\ntype ParamsReducer<TFrom, TTo> = TTo | ((current: TFrom) => TTo)\n\nexport type ToPathOption<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n> =\n  | TTo\n  | RelativeToPathAutoComplete<\n      RoutePaths<TRouteTree>,\n      NoInfer<TFrom> extends string ? NoInfer<TFrom> : '',\n      NoInfer<TTo> & string\n    >\n\nexport type ToIdOption<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n> =\n  | TTo\n  | RelativeToPathAutoComplete<\n      RouteIds<TRouteTree>,\n      NoInfer<TFrom> extends string ? NoInfer<TFrom> : '',\n      NoInfer<TTo> & string\n    >\n\nexport interface ActiveOptions {\n  exact?: boolean\n  includeHash?: boolean\n  includeSearch?: boolean\n}\n\nexport type LinkOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n> = NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // The standard anchor tag target attribute\n  target?: HTMLAnchorElement['target']\n  // Defaults to `{ exact: false, includeHash: false }`\n  activeOptions?: ActiveOptions\n  // If set, will preload the linked route on hover and cache it for this many milliseconds in hopes that the user will eventually navigate there.\n  preload?: false | 'intent'\n  // Delay intent preloading by this many milliseconds. If the intent exits before this delay, the preload will be cancelled.\n  preloadDelay?: number\n  // If true, will render the link without the href attribute\n  disabled?: boolean\n}\n\nexport type CheckRelativePath<\n  TRouteTree extends AnyRoute,\n  TFrom,\n  TTo,\n> = TTo extends string\n  ? TFrom extends string\n    ? ResolveRelativePath<TFrom, TTo> extends RoutePaths<TRouteTree>\n      ? {}\n      : {\n          Error: `${TFrom} + ${TTo} resolves to ${ResolveRelativePath<\n            TFrom,\n            TTo\n          >}, which is not a valid route path.`\n          'Valid Route Paths': RoutePaths<TRouteTree>\n        }\n    : {}\n  : {}\n\nexport type CheckPath<TRouteTree extends AnyRoute, TPath, TPass> = Exclude<\n  TPath,\n  RoutePaths<TRouteTree>\n> extends never\n  ? TPass\n  : CheckPathError<TRouteTree, Exclude<TPath, RoutePaths<TRouteTree>>>\n\nexport type CheckPathError<TRouteTree extends AnyRoute, TInvalids> = {\n  to: RoutePaths<TRouteTree>\n}\n\nexport type CheckId<TRouteTree extends AnyRoute, TPath, TPass> = Exclude<\n  TPath,\n  RouteIds<TRouteTree>\n> extends never\n  ? TPass\n  : CheckIdError<TRouteTree, Exclude<TPath, RouteIds<TRouteTree>>>\n\nexport type CheckIdError<TRouteTree extends AnyRoute, TInvalids> = {\n  Error: `${TInvalids extends string\n    ? TInvalids\n    : never} is not a valid route ID.`\n  'Valid Route IDs': RouteIds<TRouteTree>\n}\n\nexport type ResolveRelativePath<TFrom, TTo = '.'> = TFrom extends string\n  ? TTo extends string\n    ? TTo extends '.'\n      ? TFrom\n      : TTo extends `./`\n        ? Join<[TFrom, '/']>\n        : TTo extends `./${infer TRest}`\n          ? ResolveRelativePath<TFrom, TRest>\n          : TTo extends `/${infer TRest}`\n            ? TTo\n            : Split<TTo> extends ['..', ...infer ToRest]\n              ? Split<TFrom> extends [...infer FromRest, infer FromTail]\n                ? ToRest extends ['/']\n                  ? Join<[...FromRest, '/']>\n                  : ResolveRelativePath<Join<FromRest>, Join<ToRest>>\n                : never\n              : Split<TTo> extends ['.', ...infer ToRest]\n                ? ToRest extends ['/']\n                  ? Join<[TFrom, '/']>\n                  : ResolveRelativePath<TFrom, Join<ToRest>>\n                : CleanPath<Join<['/', ...Split<TFrom>, ...Split<TTo>]>>\n    : never\n  : never\n\ntype LinkCurrentTargetElement = {\n  preloadTimeout?: null | ReturnType<typeof setTimeout>\n}\n\nconst preloadWarning = 'Error preloading route! â˜ï¸'\n\nexport function useLinkProps<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n>(\n  options: UseLinkPropsOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n): React.AnchorHTMLAttributes<HTMLAnchorElement> {\n  const router = useRouter()\n  const matchPathname = useMatch({\n    strict: false,\n    select: (s) => s.pathname,\n  })\n\n  const {\n    // custom props\n    children,\n    target,\n    activeProps = () => ({ className: 'active' }),\n    inactiveProps = () => ({}),\n    activeOptions,\n    disabled,\n    hash,\n    search,\n    params,\n    to,\n    state,\n    mask,\n    preload: userPreload,\n    preloadDelay: userPreloadDelay,\n    replace,\n    startTransition,\n    resetScroll,\n    // element props\n    style,\n    className,\n    onClick,\n    onFocus,\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart,\n    ...rest\n  } = options\n\n  // If this link simply reloads the current route,\n  // make sure it has a new key so it will trigger a data refresh\n\n  // If this `to` is a valid external URL, return\n  // null for LinkUtils\n\n  const dest = {\n    from: options.to ? matchPathname : undefined,\n    ...options,\n  }\n\n  let type: 'internal' | 'external' = 'internal'\n\n  try {\n    new URL(`${to}`)\n    type = 'external'\n  } catch {}\n\n  if (type === 'external') {\n    return {\n      href: to,\n    }\n  }\n\n  const next = router.buildLocation(dest as any)\n\n  const preload = userPreload ?? router.options.defaultPreload\n  const preloadDelay =\n    userPreloadDelay ?? router.options.defaultPreloadDelay ?? 0\n\n  const isActive = useRouterState({\n    select: (s) => {\n      // Compare path/hash for matches\n      const currentPathSplit = s.location.pathname.split('/')\n      const nextPathSplit = next.pathname.split('/')\n      const pathIsFuzzyEqual = nextPathSplit.every(\n        (d, i) => d === currentPathSplit[i],\n      )\n      // Combine the matches based on user router.options\n      const pathTest = activeOptions?.exact\n        ? s.location.pathname === next.pathname\n        : pathIsFuzzyEqual\n      const hashTest = activeOptions?.includeHash\n        ? s.location.hash === next.hash\n        : true\n      const searchTest =\n        activeOptions?.includeSearch ?? true\n          ? deepEqual(s.location.search, next.search, !activeOptions?.exact)\n          : true\n\n      // The final \"active\" test\n      return pathTest && hashTest && searchTest\n    },\n  })\n\n  // The click handler\n  const handleClick = (e: MouseEvent) => {\n    if (\n      !disabled &&\n      !isCtrlEvent(e) &&\n      !e.defaultPrevented &&\n      (!target || target === '_self') &&\n      e.button === 0\n    ) {\n      e.preventDefault()\n\n      // All is well? Navigate!\n      router.commitLocation({ ...next, replace, resetScroll, startTransition })\n    }\n  }\n\n  // The click handler\n  const handleFocus = (e: MouseEvent) => {\n    if (preload) {\n      router.preloadRoute(dest as any).catch((err) => {\n        console.warn(err)\n        console.warn(preloadWarning)\n      })\n    }\n  }\n\n  const handleTouchStart = (e: TouchEvent) => {\n    if (preload) {\n      router.preloadRoute(dest as any).catch((err) => {\n        console.warn(err)\n        console.warn(preloadWarning)\n      })\n    }\n  }\n\n  const handleEnter = (e: MouseEvent) => {\n    const target = (e.target || {}) as LinkCurrentTargetElement\n\n    if (preload) {\n      if (target.preloadTimeout) {\n        return\n      }\n\n      target.preloadTimeout = setTimeout(() => {\n        target.preloadTimeout = null\n        router.preloadRoute(dest as any).catch((err) => {\n          console.warn(err)\n          console.warn(preloadWarning)\n        })\n      }, preloadDelay)\n    }\n  }\n\n  const handleLeave = (e: MouseEvent) => {\n    const target = (e.target || {}) as LinkCurrentTargetElement\n\n    if (target.preloadTimeout) {\n      clearTimeout(target.preloadTimeout)\n      target.preloadTimeout = null\n    }\n  }\n\n  const composeHandlers =\n    (handlers: (undefined | ((e: any) => void))[]) =>\n    (e: React.SyntheticEvent) => {\n      if (e.persist) e.persist()\n      handlers.filter(Boolean).forEach((handler) => {\n        if (e.defaultPrevented) return\n        handler!(e)\n      })\n    }\n\n  // Get the active props\n  const resolvedActiveProps: React.HTMLAttributes<HTMLAnchorElement> = isActive\n    ? functionalUpdate(activeProps as any, {}) ?? {}\n    : {}\n\n  // Get the inactive props\n  const resolvedInactiveProps: React.HTMLAttributes<HTMLAnchorElement> =\n    isActive ? {} : functionalUpdate(inactiveProps, {}) ?? {}\n\n  return {\n    ...resolvedActiveProps,\n    ...resolvedInactiveProps,\n    ...rest,\n    href: disabled\n      ? undefined\n      : next.maskedLocation\n        ? next.maskedLocation.href\n        : next.href,\n    onClick: composeHandlers([onClick, handleClick]),\n    onFocus: composeHandlers([onFocus, handleFocus]),\n    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),\n    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),\n    onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),\n    target,\n    style: {\n      ...style,\n      ...resolvedActiveProps.style,\n      ...resolvedInactiveProps.style,\n    },\n    className:\n      [\n        className,\n        resolvedActiveProps.className,\n        resolvedInactiveProps.className,\n      ]\n        .filter(Boolean)\n        .join(' ') || undefined,\n    ...(disabled\n      ? {\n          role: 'link',\n          'aria-disabled': true,\n        }\n      : undefined),\n    ['data-status']: isActive ? 'active' : undefined,\n  }\n}\n\nexport interface LinkComponent<TProps extends Record<string, any> = {}> {\n  <\n    TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n    TFrom extends RoutePaths<TRouteTree> = '/',\n    TTo extends string = '',\n    TMaskFrom extends RoutePaths<TRouteTree> = '/',\n    TMaskTo extends string = '',\n  >(\n    props: LinkProps<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> &\n      TProps &\n      React.RefAttributes<HTMLAnchorElement>,\n  ): ReactNode\n}\n\nexport const Link: LinkComponent = React.forwardRef((props: any, ref) => {\n  const linkProps = useLinkProps(props)\n\n  return (\n    <a\n      {...{\n        ref: ref as any,\n        ...linkProps,\n        children:\n          typeof props.children === 'function'\n            ? props.children({\n                isActive: (linkProps as any)['data-status'] === 'active',\n              })\n            : props.children,\n      }}\n    />\n  )\n}) as any\n\nfunction isCtrlEvent(e: MouseEvent) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n}\n", "// @ts-nocheck\n\n// qss has been slightly modified and inlined here for our use cases (and compression's sake). We've included it as a hard dependency for MIT license attribution.\n\nexport function encode(obj, pfx?: string) {\n  var k,\n    i,\n    tmp,\n    str = ''\n\n  for (k in obj) {\n    if ((tmp = obj[k]) !== void 0) {\n      if (Array.isArray(tmp)) {\n        for (i = 0; i < tmp.length; i++) {\n          str && (str += '&')\n          str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp[i])\n        }\n      } else {\n        str && (str += '&')\n        str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp)\n      }\n    }\n  }\n\n  return (pfx || '') + str\n}\n\nfunction toValue(mix) {\n  if (!mix) return ''\n  var str = decodeURIComponent(mix)\n  if (str === 'false') return false\n  if (str === 'true') return true\n  return +str * 0 === 0 && +str + '' === str ? +str : str\n}\n\nexport function decode(str) {\n  var tmp,\n    k,\n    out = {},\n    arr = str.split('&')\n\n  while ((tmp = arr.shift())) {\n    tmp = tmp.split('=')\n    k = tmp.shift()\n    if (out[k] !== void 0) {\n      out[k] = [].concat(out[k], toValue(tmp.shift()))\n    } else {\n      out[k] = toValue(tmp.shift())\n    }\n  }\n\n  return out\n}\n", "import { NavigateOptions } from './link'\nimport { AnyRoute } from './route'\nimport { RoutePaths } from './routeInfo'\nimport { RegisteredRouter } from './router'\n\n// Detect if we're in the DOM\n\nexport type AnyRedirect = Redirect<any, any, any, any, any>\n\nexport type Redirect<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n> = {\n  code?: number\n  throw?: any\n} & NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>\n\nexport function redirect<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n>(\n  opts: Redirect<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n): Redirect<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> {\n  ;(opts as any).isRedirect = true\n  if (opts.throw) {\n    throw opts\n  }\n  return opts\n}\n\nexport function isRedirect(obj: any): obj is AnyRedirect {\n  return !!obj?.isRedirect\n}\n", "import { decode, encode } from './qss'\nimport { AnySearchSchema } from './route'\n\nexport const defaultParseSearch = parseSearchWith(JSON.parse)\nexport const defaultStringifySearch = stringifySearchWith(\n  JSON.stringify,\n  JSON.parse,\n)\n\nexport function parseSearchWith(parser: (str: string) => any) {\n  return (searchStr: string): AnySearchSchema => {\n    if (searchStr.substring(0, 1) === '?') {\n      searchStr = searchStr.substring(1)\n    }\n\n    let query: Record<string, unknown> = decode(searchStr)\n\n    // Try to parse any query params that might be json\n    for (let key in query) {\n      const value = query[key]\n      if (typeof value === 'string') {\n        try {\n          query[key] = parser(value)\n        } catch (err) {\n          //\n        }\n      }\n    }\n\n    return query\n  }\n}\n\nexport function stringifySearchWith(\n  stringify: (search: any) => string,\n  parser?: (str: string) => any,\n) {\n  function stringifyValue(val: any) {\n    if (typeof val === 'object' && val !== null) {\n      try {\n        return stringify(val)\n      } catch (err) {\n        // silent\n      }\n    } else if (typeof val === 'string' && typeof parser === 'function') {\n      try {\n        // Check if it's a valid parseable string.\n        // If it is, then stringify it again.\n        parser(val)\n        return stringify(val)\n      } catch (err) {\n        // silent\n      }\n    }\n    return val\n  }\n\n  return (search: Record<string, any>) => {\n    search = { ...search }\n\n    if (search) {\n      Object.keys(search).forEach((key) => {\n        const val = search[key]\n        if (typeof val === 'undefined' || val === undefined) {\n          delete search[key]\n        } else {\n          search[key] = stringifyValue(val)\n        }\n      })\n    }\n\n    const searchStr = encode(search as Record<string, string>).toString()\n\n    return searchStr ? `?${searchStr}` : ''\n  }\n}\n\nexport type SearchSerializer = (searchObj: Record<string, any>) => string\nexport type SearchParser = (searchStr: string) => Record<string, any>\n", "import {\n  HistoryLocation,\n  HistoryState,\n  RouterHistory,\n  createBrowserHistory,\n  createMemoryHistory,\n} from '@tanstack/history'\nimport { Store } from '@tanstack/store'\n\n//\n\nimport {\n  AnySearchSchema,\n  AnyRoute,\n  AnyContext,\n  AnyPathParams,\n  RouteMask,\n  Route,\n  LoaderFnContext,\n} from './route'\nimport { FullSearchSchema, RoutesById, RoutesByPath } from './routeInfo'\nimport { defaultParseSearch, defaultStringifySearch } from './searchParams'\nimport {\n  PickAsRequired,\n  Updater,\n  NonNullableUpdater,\n  replaceEqualDeep,\n  deepEqual,\n  escapeJSON,\n  functionalUpdate,\n  last,\n  pick,\n  Timeout,\n} from './utils'\nimport { RouteComponent } from './route'\nimport { AnyRouteMatch, RouteMatch } from './Matches'\nimport { ParsedLocation } from './location'\nimport { SearchSerializer, SearchParser } from './searchParams'\nimport {\n  BuildLocationFn,\n  CommitLocationOptions,\n  InjectedHtmlEntry,\n  MatchRouteFn,\n  NavigateFn,\n  getRouteMatch,\n} from './RouterProvider'\n\nimport {\n  cleanPath,\n  interpolatePath,\n  joinPaths,\n  matchPathname,\n  parsePathname,\n  removeBasepath,\n  resolvePath,\n  trimPath,\n  trimPathLeft,\n  trimPathRight,\n} from './path'\nimport invariant from 'tiny-invariant'\nimport { isRedirect } from './redirects'\nimport { ToOptions } from './link'\n// import warning from 'tiny-warning'\n\n//\n\ndeclare global {\n  interface Window {\n    __TSR_DEHYDRATED__?: HydrationCtx\n    __TSR_ROUTER_CONTEXT__?: React.Context<Router<any>>\n  }\n}\n\nexport interface Register {\n  // router: Router\n}\n\nexport type AnyRouter = Router<AnyRoute, any>\n\nexport type RegisteredRouter = Register extends {\n  router: infer TRouter extends AnyRouter\n}\n  ? TRouter\n  : AnyRouter\n\nexport type HydrationCtx = {\n  router: DehydratedRouter\n  payload: Record<string, any>\n}\n\nexport type RouterContextOptions<TRouteTree extends AnyRoute> =\n  AnyContext extends TRouteTree['types']['routerContext']\n    ? {\n        context?: TRouteTree['types']['routerContext']\n      }\n    : {\n        context: TRouteTree['types']['routerContext']\n      }\n\nexport interface RouterOptions<\n  TRouteTree extends AnyRoute,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> {\n  history?: RouterHistory\n  stringifySearch?: SearchSerializer\n  parseSearch?: SearchParser\n  defaultPreload?: false | 'intent'\n  defaultPreloadDelay?: number\n  defaultComponent?: RouteComponent\n  defaultErrorComponent?: RouteComponent\n  defaultPendingComponent?: RouteComponent\n  defaultPendingMs?: number\n  defaultPendingMinMs?: number\n  defaultStaleTime?: number\n  defaultPreloadStaleTime?: number\n  defaultPreloadGcTime?: number\n  defaultGcTime?: number\n  caseSensitive?: boolean\n  routeTree?: TRouteTree\n  basepath?: string\n  context?: TRouteTree['types']['routerContext']\n  dehydrate?: () => TDehydrated\n  hydrate?: (dehydrated: TDehydrated) => void\n  routeMasks?: RouteMask<TRouteTree>[]\n  unmaskOnReload?: boolean\n  Wrap?: (props: { children: any }) => JSX.Element\n  InnerWrap?: (props: { children: any }) => JSX.Element\n  notFoundRoute?: AnyRoute\n}\n\nexport interface RouterState<TRouteTree extends AnyRoute = AnyRoute> {\n  status: 'pending' | 'idle'\n  isLoading: boolean\n  isTransitioning: boolean\n  matches: RouteMatch<TRouteTree>[]\n  pendingMatches?: RouteMatch<TRouteTree>[]\n  cachedMatches: RouteMatch<TRouteTree>[]\n  location: ParsedLocation<FullSearchSchema<TRouteTree>>\n  resolvedLocation: ParsedLocation<FullSearchSchema<TRouteTree>>\n  lastUpdated: number\n}\n\nexport type ListenerFn<TEvent extends RouterEvent> = (event: TEvent) => void\n\nexport interface BuildNextOptions {\n  to?: string | number | null\n  params?: true | Updater<unknown>\n  search?: true | Updater<unknown>\n  hash?: true | Updater<string>\n  state?: true | NonNullableUpdater<HistoryState>\n  mask?: {\n    to?: string | number | null\n    params?: true | Updater<unknown>\n    search?: true | Updater<unknown>\n    hash?: true | Updater<string>\n    state?: true | NonNullableUpdater<HistoryState>\n    unmaskOnReload?: boolean\n  }\n  from?: string\n}\n\nexport interface DehydratedRouterState {\n  dehydratedMatches: DehydratedRouteMatch[]\n}\n\nexport type DehydratedRouteMatch = Pick<\n  RouteMatch,\n  'id' | 'status' | 'updatedAt'\n>\n\nexport interface DehydratedRouter {\n  state: DehydratedRouterState\n}\n\nexport type RouterConstructorOptions<\n  TRouteTree extends AnyRoute,\n  TDehydrated extends Record<string, any>,\n> = Omit<RouterOptions<TRouteTree, TDehydrated>, 'context'> &\n  RouterContextOptions<TRouteTree>\n\nexport const componentTypes = [\n  'component',\n  'errorComponent',\n  'pendingComponent',\n] as const\n\nexport type RouterEvents = {\n  onBeforeLoad: {\n    type: 'onBeforeLoad'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n  onLoad: {\n    type: 'onLoad'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n  onResolved: {\n    type: 'onResolved'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n}\n\nexport type RouterEvent = RouterEvents[keyof RouterEvents]\n\nexport type RouterListener<TRouterEvent extends RouterEvent> = {\n  eventType: TRouterEvent['type']\n  fn: ListenerFn<TRouterEvent>\n}\n\nexport class Router<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> {\n  // Option-independent properties\n  tempLocationKey: string | undefined = `${Math.round(\n    Math.random() * 10000000,\n  )}`\n  resetNextScroll: boolean = true\n  navigateTimeout: Timeout | null = null\n  latestLoadPromise: Promise<void> = Promise.resolve()\n  subscribers = new Set<RouterListener<RouterEvent>>()\n  injectedHtml: InjectedHtmlEntry[] = []\n  dehydratedData?: TDehydrated\n\n  // Must build in constructor\n  __store!: Store<RouterState<TRouteTree>>\n  options!: PickAsRequired<\n    RouterOptions<TRouteTree, TDehydrated>,\n    'stringifySearch' | 'parseSearch' | 'context'\n  >\n  history!: RouterHistory\n  latestLocation!: ParsedLocation\n  basepath!: string\n  routeTree!: TRouteTree\n  routesById!: RoutesById<TRouteTree>\n  routesByPath!: RoutesByPath<TRouteTree>\n  flatRoutes!: AnyRoute[]\n\n  constructor(options: RouterConstructorOptions<TRouteTree, TDehydrated>) {\n    this.update({\n      defaultPreloadDelay: 50,\n      defaultPendingMs: 1000,\n      defaultPendingMinMs: 500,\n      context: undefined!,\n      ...options,\n      stringifySearch: options?.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options?.parseSearch ?? defaultParseSearch,\n    })\n  }\n\n  // These are default implementations that can optionally be overridden\n  // by the router provider once rendered. We provide these so that the\n  // router can be used in a non-react environment if necessary\n  startReactTransition: (fn: () => void) => void = (fn) => fn()\n\n  update = (newOptions: RouterConstructorOptions<TRouteTree, TDehydrated>) => {\n    this.options = {\n      ...this.options,\n      ...newOptions,\n    }\n\n    this.basepath = `/${trimPath(newOptions.basepath ?? '') ?? ''}`\n\n    if (\n      !this.history ||\n      (this.options.history && this.options.history !== this.history)\n    ) {\n      this.history =\n        this.options.history ??\n        (typeof document !== 'undefined'\n          ? createBrowserHistory()\n          : createMemoryHistory())\n      this.latestLocation = this.parseLocation()\n    }\n\n    if (this.options.routeTree !== this.routeTree) {\n      this.routeTree = this.options.routeTree as TRouteTree\n      this.buildRouteTree()\n    }\n\n    if (!this.__store) {\n      this.__store = new Store(getInitialRouterState(this.latestLocation), {\n        onUpdate: () => {\n          this.__store.state = {\n            ...this.state,\n            status:\n              this.state.isTransitioning || this.state.isLoading\n                ? 'pending'\n                : 'idle',\n          }\n        },\n      })\n    }\n  }\n\n  get state() {\n    return this.__store.state\n  }\n\n  buildRouteTree = () => {\n    this.routesById = {} as RoutesById<TRouteTree>\n    this.routesByPath = {} as RoutesByPath<TRouteTree>\n\n    const notFoundRoute = this.options.notFoundRoute\n    if (notFoundRoute) {\n      notFoundRoute.init({ originalIndex: 99999999999 })\n      ;(this.routesById as any)[notFoundRoute.id] = notFoundRoute\n    }\n\n    const recurseRoutes = (childRoutes: AnyRoute[]) => {\n      childRoutes.forEach((childRoute, i) => {\n        childRoute.init({ originalIndex: i })\n\n        const existingRoute = (this.routesById as any)[childRoute.id]\n\n        invariant(\n          !existingRoute,\n          `Duplicate routes found with id: ${String(childRoute.id)}`,\n        )\n        ;(this.routesById as any)[childRoute.id] = childRoute\n\n        if (!childRoute.isRoot && childRoute.path) {\n          const trimmedFullPath = trimPathRight(childRoute.fullPath)\n          if (\n            !(this.routesByPath as any)[trimmedFullPath] ||\n            childRoute.fullPath.endsWith('/')\n          ) {\n            ;(this.routesByPath as any)[trimmedFullPath] = childRoute\n          }\n        }\n\n        const children = childRoute.children as Route[]\n\n        if (children?.length) {\n          recurseRoutes(children)\n        }\n      })\n    }\n\n    recurseRoutes([this.routeTree])\n\n    const scoredRoutes: {\n      child: AnyRoute\n      trimmed: string\n      parsed: ReturnType<typeof parsePathname>\n      index: number\n      scores: number[]\n    }[] = []\n\n    ;(Object.values(this.routesById) as AnyRoute[]).forEach((d, i) => {\n      if (d.isRoot || !d.path) {\n        return\n      }\n\n      const trimmed = trimPathLeft(d.fullPath)\n      const parsed = parsePathname(trimmed)\n\n      while (parsed.length > 1 && parsed[0]?.value === '/') {\n        parsed.shift()\n      }\n\n      const scores = parsed.map((d) => {\n        if (d.value === '/') {\n          return 0.75\n        }\n\n        if (d.type === 'param') {\n          return 0.5\n        }\n\n        if (d.type === 'wildcard') {\n          return 0.25\n        }\n\n        return 1\n      })\n\n      scoredRoutes.push({ child: d, trimmed, parsed, index: i, scores })\n    })\n\n    this.flatRoutes = scoredRoutes\n      .sort((a, b) => {\n        const minLength = Math.min(a.scores.length, b.scores.length)\n\n        // Sort by min available score\n        for (let i = 0; i < minLength; i++) {\n          if (a.scores[i] !== b.scores[i]) {\n            return b.scores[i]! - a.scores[i]!\n          }\n        }\n\n        // Sort by length of score\n        if (a.scores.length !== b.scores.length) {\n          return b.scores.length - a.scores.length\n        }\n\n        // Sort by min available parsed value\n        for (let i = 0; i < minLength; i++) {\n          if (a.parsed[i]!.value !== b.parsed[i]!.value) {\n            return a.parsed[i]!.value! > b.parsed[i]!.value! ? 1 : -1\n          }\n        }\n\n        // Sort by original index\n        return a.index - b.index\n      })\n      .map((d, i) => {\n        d.child.rank = i\n        return d.child\n      })\n  }\n\n  subscribe = <TType extends keyof RouterEvents>(\n    eventType: TType,\n    fn: ListenerFn<RouterEvents[TType]>,\n  ) => {\n    const listener: RouterListener<any> = {\n      eventType,\n      fn,\n    }\n\n    this.subscribers.add(listener)\n\n    return () => {\n      this.subscribers.delete(listener)\n    }\n  }\n\n  emit = (routerEvent: RouterEvent) => {\n    this.subscribers.forEach((listener) => {\n      if (listener.eventType === routerEvent.type) {\n        listener.fn(routerEvent)\n      }\n    })\n  }\n\n  checkLatest = (promise: Promise<void>): undefined | Promise<void> => {\n    return this.latestLoadPromise !== promise\n      ? this.latestLoadPromise\n      : undefined\n  }\n\n  parseLocation = (\n    previousLocation?: ParsedLocation,\n  ): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n    const parse = ({\n      pathname,\n      search,\n      hash,\n      state,\n    }: HistoryLocation): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n      const parsedSearch = this.options.parseSearch(search)\n\n      return {\n        pathname: pathname,\n        searchStr: search,\n        search: replaceEqualDeep(previousLocation?.search, parsedSearch) as any,\n        hash: hash.split('#').reverse()[0] ?? '',\n        href: `${pathname}${search}${hash}`,\n        state: replaceEqualDeep(previousLocation?.state, state) as HistoryState,\n      }\n    }\n\n    const location = parse(this.history.location)\n\n    let { __tempLocation, __tempKey } = location.state\n\n    if (__tempLocation && (!__tempKey || __tempKey === this.tempLocationKey)) {\n      // Sync up the location keys\n      const parsedTempLocation = parse(__tempLocation) as any\n      parsedTempLocation.state.key = location.state.key\n\n      delete parsedTempLocation.state.__tempLocation\n\n      return {\n        ...parsedTempLocation,\n        maskedLocation: location,\n      }\n    }\n\n    return location\n  }\n\n  resolvePathWithBase = (from: string, path: string) => {\n    return resolvePath(this.basepath!, from, cleanPath(path))\n  }\n\n  get looseRoutesById() {\n    return this.routesById as Record<string, AnyRoute>\n  }\n\n  matchRoutes = <TRouteTree extends AnyRoute>(\n    pathname: string,\n    locationSearch: AnySearchSchema,\n    opts?: { throwOnError?: boolean; debug?: boolean },\n  ): RouteMatch<TRouteTree>[] => {\n    let routeParams: Record<string, string> = {}\n\n    let foundRoute = this.flatRoutes.find((route) => {\n      const matchedParams = matchPathname(\n        this.basepath,\n        trimPathRight(pathname),\n        {\n          to: route.fullPath,\n          caseSensitive:\n            route.options.caseSensitive ?? this.options.caseSensitive,\n          fuzzy: true,\n        },\n      )\n\n      if (matchedParams) {\n        routeParams = matchedParams\n        return true\n      }\n\n      return false\n    })\n\n    let routeCursor: AnyRoute =\n      foundRoute || (this.routesById as any)['__root__']\n\n    let matchedRoutes: AnyRoute[] = [routeCursor]\n\n    // Check to see if the route needs a 404 entry\n    if (\n      // If we found a route, and it's not an index route and we have left over path\n      (foundRoute\n        ? foundRoute.path !== '/' && routeParams['**']\n        : // Or if we didn't find a route and we have left over path\n          trimPathRight(pathname)) &&\n      // And we have a 404 route configured\n      this.options.notFoundRoute\n    ) {\n      matchedRoutes.push(this.options.notFoundRoute)\n    }\n\n    while (routeCursor?.parentRoute) {\n      routeCursor = routeCursor.parentRoute\n      if (routeCursor) matchedRoutes.unshift(routeCursor)\n    }\n\n    // Existing matches are matches that are already loaded along with\n    // pending matches that are still loading\n\n    const parseErrors = matchedRoutes.map((route) => {\n      let parsedParamsError\n\n      if (route.options.parseParams) {\n        try {\n          const parsedParams = route.options.parseParams(routeParams)\n          // Add the parsed params to the accumulated params bag\n          Object.assign(routeParams, parsedParams)\n        } catch (err: any) {\n          parsedParamsError = new PathParamError(err.message, {\n            cause: err,\n          })\n\n          if (opts?.throwOnError) {\n            throw parsedParamsError\n          }\n\n          return parsedParamsError\n        }\n      }\n\n      return\n    })\n\n    const matches: AnyRouteMatch[] = []\n\n    matchedRoutes.forEach((route, index) => {\n      // Take each matched route and resolve + validate its search params\n      // This has to happen serially because each route's search params\n      // can depend on the parent route's search params\n      // It must also happen before we create the match so that we can\n      // pass the search params to the route's potential key function\n      // which is used to uniquely identify the route match in state\n\n      const parentMatch = matches[index - 1]\n\n      const [preMatchSearch, searchError]: [Record<string, any>, any] = (() => {\n        // Validate the search params and stabilize them\n        const parentSearch = parentMatch?.search ?? locationSearch\n\n        try {\n          const validator =\n            typeof route.options.validateSearch === 'object'\n              ? route.options.validateSearch.parse\n              : route.options.validateSearch\n\n          let search = validator?.(parentSearch) ?? {}\n\n          return [\n            {\n              ...parentSearch,\n              ...search,\n            },\n            undefined,\n          ]\n        } catch (err: any) {\n          const searchError = new SearchParamError(err.message, {\n            cause: err,\n          })\n\n          if (opts?.throwOnError) {\n            throw searchError\n          }\n\n          return [parentSearch, searchError]\n        }\n      })()\n\n      // This is where we need to call route.options.loaderDeps() to get any additional\n      // deps that the route's loader function might need to run. We need to do this\n      // before we create the match so that we can pass the deps to the route's\n      // potential key function which is used to uniquely identify the route match in state\n\n      const loaderDeps =\n        route.options.loaderDeps?.({\n          search: preMatchSearch,\n        }) ?? ''\n\n      const loaderDepsHash = loaderDeps ? JSON.stringify(loaderDeps) : ''\n\n      const interpolatedPath = interpolatePath(route.fullPath, routeParams)\n      const matchId =\n        interpolatePath(route.id, routeParams, true) + loaderDepsHash\n\n      // Waste not, want not. If we already have a match for this route,\n      // reuse it. This is important for layout routes, which might stick\n      // around between navigation actions that only change leaf routes.\n      const existingMatch = getRouteMatch(this.state, matchId)\n\n      const cause = this.state.matches.find((d) => d.id === matchId)\n        ? 'stay'\n        : 'enter'\n\n      // Create a fresh route match\n      const hasLoaders = !!(\n        route.options.loader ||\n        componentTypes.some((d) => (route.options[d] as any)?.preload)\n      )\n\n      const match: AnyRouteMatch = existingMatch\n        ? { ...existingMatch, cause }\n        : {\n            id: matchId,\n            routeId: route.id,\n            params: routeParams,\n            pathname: joinPaths([this.basepath, interpolatedPath]),\n            updatedAt: Date.now(),\n            search: {} as any,\n            searchError: undefined,\n            status: hasLoaders ? 'pending' : 'success',\n            showPending: false,\n            isFetching: false,\n            error: undefined,\n            paramsError: parseErrors[index],\n            loadPromise: Promise.resolve(),\n            routeContext: undefined!,\n            context: undefined!,\n            abortController: new AbortController(),\n            fetchCount: 0,\n            cause,\n            loaderDeps,\n            invalid: false,\n            preload: false,\n          }\n\n      // Regardless of whether we're reusing an existing match or creating\n      // a new one, we need to update the match's search params\n      match.search = replaceEqualDeep(match.search, preMatchSearch)\n      // And also update the searchError if there is one\n      match.searchError = searchError\n\n      matches.push(match)\n    })\n\n    return matches as any\n  }\n\n  cancelMatch = (id: string) => {\n    getRouteMatch(this.state, id)?.abortController?.abort()\n  }\n\n  cancelMatches = () => {\n    this.state.pendingMatches?.forEach((match) => {\n      this.cancelMatch(match.id)\n    })\n  }\n\n  buildLocation: BuildLocationFn<TRouteTree> = (opts) => {\n    const build = (\n      dest: BuildNextOptions & {\n        unmaskOnReload?: boolean\n      } = {},\n      matches?: AnyRouteMatch[],\n    ): ParsedLocation => {\n      const from = this.latestLocation\n      const fromSearch =\n        (this.state.pendingMatches || this.state.matches).at(-1)?.search ||\n        from.search\n      const fromPathname = dest.from ?? from.pathname\n\n      let pathname = this.resolvePathWithBase(fromPathname, `${dest.to ?? ''}`)\n\n      const fromMatches = this.matchRoutes(fromPathname, fromSearch)\n      const stayingMatches = matches?.filter(\n        (d) => fromMatches?.find((e) => e.routeId === d.routeId),\n      )\n\n      const prevParams = { ...last(fromMatches)?.params }\n\n      let nextParams =\n        (dest.params ?? true) === true\n          ? prevParams\n          : functionalUpdate(dest.params!, prevParams)\n\n      if (nextParams) {\n        matches\n          ?.map((d) => this.looseRoutesById[d.routeId]!.options.stringifyParams)\n          .filter(Boolean)\n          .forEach((fn) => {\n            nextParams = { ...nextParams!, ...fn!(nextParams!) }\n          })\n      }\n\n      pathname = interpolatePath(pathname, nextParams ?? {})\n\n      const preSearchFilters =\n        stayingMatches\n          ?.map(\n            (match) =>\n              this.looseRoutesById[match.routeId]!.options.preSearchFilters ??\n              [],\n          )\n          .flat()\n          .filter(Boolean) ?? []\n\n      const postSearchFilters =\n        stayingMatches\n          ?.map(\n            (match) =>\n              this.looseRoutesById[match.routeId]!.options.postSearchFilters ??\n              [],\n          )\n          .flat()\n          .filter(Boolean) ?? []\n\n      // Pre filters first\n      const preFilteredSearch = preSearchFilters?.length\n        ? preSearchFilters?.reduce(\n            (prev, next) => next(prev) as any,\n            fromSearch,\n          )\n        : fromSearch\n\n      // Then the link/navigate function\n      const destSearch =\n        dest.search === true\n          ? preFilteredSearch // Preserve resolvedFrom true\n          : dest.search\n            ? functionalUpdate(dest.search, preFilteredSearch) ?? {} // Updater\n            : preSearchFilters?.length\n              ? preFilteredSearch // Preserve resolvedFrom filters\n              : {}\n\n      // Then post filters\n      const postFilteredSearch = postSearchFilters?.length\n        ? postSearchFilters.reduce((prev, next) => next(prev), destSearch)\n        : destSearch\n\n      const search = replaceEqualDeep(fromSearch, postFilteredSearch)\n\n      const searchStr = this.options.stringifySearch(search)\n\n      const hash =\n        dest.hash === true\n          ? from.hash\n          : dest.hash\n            ? functionalUpdate(dest.hash!, from.hash)\n            : from.hash\n\n      const hashStr = hash ? `#${hash}` : ''\n\n      let nextState =\n        dest.state === true\n          ? from.state\n          : dest.state\n            ? functionalUpdate(dest.state, from.state)\n            : from.state\n\n      nextState = replaceEqualDeep(from.state, nextState)\n\n      return {\n        pathname,\n        search,\n        searchStr,\n        state: nextState as any,\n        hash,\n        href: `${pathname}${searchStr}${hashStr}`,\n        unmaskOnReload: dest.unmaskOnReload,\n      }\n    }\n\n    const buildWithMatches = (\n      dest: BuildNextOptions = {},\n      maskedDest?: BuildNextOptions,\n    ) => {\n      let next = build(dest)\n      let maskedNext = maskedDest ? build(maskedDest) : undefined\n\n      if (!maskedNext) {\n        let params = {}\n\n        let foundMask = this.options.routeMasks?.find((d) => {\n          const match = matchPathname(this.basepath, next.pathname, {\n            to: d.from,\n            caseSensitive: false,\n            fuzzy: false,\n          })\n\n          if (match) {\n            params = match\n            return true\n          }\n\n          return false\n        })\n\n        if (foundMask) {\n          foundMask = {\n            ...foundMask,\n            from: interpolatePath(foundMask.from, params) as any,\n          }\n          maskedDest = foundMask\n          maskedNext = build(maskedDest)\n        }\n      }\n\n      const nextMatches = this.matchRoutes(next.pathname, next.search)\n      const maskedMatches = maskedNext\n        ? this.matchRoutes(maskedNext.pathname, maskedNext.search)\n        : undefined\n      const maskedFinal = maskedNext\n        ? build(maskedDest, maskedMatches)\n        : undefined\n\n      const final = build(dest, nextMatches)\n\n      if (maskedFinal) {\n        final.maskedLocation = maskedFinal\n      }\n\n      return final\n    }\n\n    if (opts.mask) {\n      return buildWithMatches(opts, {\n        ...pick(opts, ['from']),\n        ...opts.mask,\n      })\n    }\n\n    return buildWithMatches(opts)\n  }\n\n  commitLocation = async ({\n    startTransition,\n    ...next\n  }: ParsedLocation & CommitLocationOptions) => {\n    if (this.navigateTimeout) clearTimeout(this.navigateTimeout)\n\n    const isSameUrl = this.latestLocation.href === next.href\n\n    // If the next urls are the same and we're not replacing,\n    // do nothing\n    if (!isSameUrl || !next.replace) {\n      let { maskedLocation, ...nextHistory } = next\n\n      if (maskedLocation) {\n        nextHistory = {\n          ...maskedLocation,\n          state: {\n            ...maskedLocation.state,\n            __tempKey: undefined,\n            __tempLocation: {\n              ...nextHistory,\n              search: nextHistory.searchStr,\n              state: {\n                ...nextHistory.state,\n                __tempKey: undefined!,\n                __tempLocation: undefined!,\n                key: undefined!,\n              },\n            },\n          },\n        }\n\n        if (\n          nextHistory.unmaskOnReload ??\n          this.options.unmaskOnReload ??\n          false\n        ) {\n          nextHistory.state.__tempKey = this.tempLocationKey\n        }\n      }\n\n      const apply = () => {\n        this.history[next.replace ? 'replace' : 'push'](\n          nextHistory.href,\n          nextHistory.state,\n        )\n      }\n\n      if (startTransition ?? true) {\n        this.startReactTransition(apply)\n      } else {\n        apply()\n      }\n    }\n\n    this.resetNextScroll = next.resetScroll ?? true\n\n    return this.latestLoadPromise\n  }\n\n  buildAndCommitLocation = ({\n    replace,\n    resetScroll,\n    startTransition,\n    ...rest\n  }: BuildNextOptions & CommitLocationOptions = {}) => {\n    const location = this.buildLocation(rest as any)\n    return this.commitLocation({\n      ...location,\n      startTransition,\n      replace,\n      resetScroll,\n    })\n  }\n\n  navigate: NavigateFn<TRouteTree> = ({ from, to = '', ...rest }) => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n    const toString = String(to)\n    const fromString = typeof from === 'undefined' ? from : String(from)\n    let isExternal\n\n    try {\n      new URL(`${toString}`)\n      isExternal = true\n    } catch (e) {}\n\n    invariant(\n      !isExternal,\n      'Attempting to navigate to external url with this.navigate!',\n    )\n\n    return this.buildAndCommitLocation({\n      ...rest,\n      from: fromString,\n      to: toString,\n    })\n  }\n\n  loadMatches = async ({\n    checkLatest,\n    matches,\n    preload,\n  }: {\n    checkLatest: () => Promise<void> | undefined\n    matches: AnyRouteMatch[]\n    preload?: boolean\n  }): Promise<RouteMatch[]> => {\n    let latestPromise\n    let firstBadMatchIndex: number | undefined\n\n    const updateMatch = (match: AnyRouteMatch) => {\n      // const isPreload = this.state.cachedMatches.find((d) => d.id === match.id)\n      const isPending = this.state.pendingMatches?.find(\n        (d) => d.id === match.id,\n      )\n\n      const isMatched = this.state.matches.find((d) => d.id === match.id)\n\n      const matchesKey = isPending\n        ? 'pendingMatches'\n        : isMatched\n          ? 'matches'\n          : 'cachedMatches'\n\n      this.__store.setState((s) => ({\n        ...s,\n        [matchesKey]: s[matchesKey]?.map((d) =>\n          d.id === match.id ? match : d,\n        ),\n      }))\n    }\n\n    // Check each match middleware to see if the route can be accessed\n    try {\n      for (let [index, match] of matches.entries()) {\n        const parentMatch = matches[index - 1]\n        const route = this.looseRoutesById[match.routeId]!\n        const abortController = new AbortController()\n\n        const handleErrorAndRedirect = (err: any, code: string) => {\n          err.routerCode = code\n          firstBadMatchIndex = firstBadMatchIndex ?? index\n\n          if (isRedirect(err)) {\n            throw err\n          }\n\n          try {\n            route.options.onError?.(err)\n          } catch (errorHandlerErr) {\n            err = errorHandlerErr\n\n            if (isRedirect(errorHandlerErr)) {\n              throw errorHandlerErr\n            }\n          }\n\n          matches[index] = match = {\n            ...match,\n            error: err,\n            status: 'error',\n            updatedAt: Date.now(),\n            abortController: new AbortController(),\n          }\n        }\n\n        try {\n          if (match.paramsError) {\n            handleErrorAndRedirect(match.paramsError, 'PARSE_PARAMS')\n          }\n\n          if (match.searchError) {\n            handleErrorAndRedirect(match.searchError, 'VALIDATE_SEARCH')\n          }\n\n          const parentContext =\n            parentMatch?.context ?? this.options.context ?? {}\n\n          const beforeLoadContext =\n            (await route.options.beforeLoad?.({\n              search: match.search,\n              abortController,\n              params: match.params,\n              preload: !!preload,\n              context: parentContext,\n              location: this.state.location,\n              // TOOD: just expose state and router, etc\n              navigate: (opts) =>\n                this.navigate({ ...opts, from: match.pathname } as any),\n              buildLocation: this.buildLocation,\n              cause: preload ? 'preload' : match.cause,\n            })) ?? ({} as any)\n\n          if (isRedirect(beforeLoadContext)) {\n            throw beforeLoadContext\n          }\n\n          const context = {\n            ...parentContext,\n            ...beforeLoadContext,\n          }\n\n          matches[index] = match = {\n            ...match,\n            routeContext: replaceEqualDeep(\n              match.routeContext,\n              beforeLoadContext,\n            ),\n            context: replaceEqualDeep(match.context, context),\n            abortController,\n          }\n        } catch (err) {\n          handleErrorAndRedirect(err, 'BEFORE_LOAD')\n          break\n        }\n      }\n    } catch (err) {\n      if (isRedirect(err)) {\n        if (!preload) this.navigate(err as any)\n        return matches\n      }\n\n      throw err\n    }\n\n    const validResolvedMatches = matches.slice(0, firstBadMatchIndex)\n    const matchPromises: Promise<any>[] = []\n\n    validResolvedMatches.forEach((match, index) => {\n      matchPromises.push(\n        new Promise<void>(async (resolve) => {\n          const parentMatchPromise = matchPromises[index - 1]\n          const route = this.looseRoutesById[match.routeId]!\n\n          const handleErrorAndRedirect = (err: any) => {\n            if (isRedirect(err)) {\n              if (!preload) {\n                this.navigate(err as any)\n              }\n              return true\n            }\n            return false\n          }\n\n          let loadPromise: Promise<void> | undefined\n\n          matches[index] = match = {\n            ...match,\n            showPending: false,\n          }\n\n          let didShowPending = false\n          const pendingMs =\n            route.options.pendingMs ?? this.options.defaultPendingMs\n          const pendingMinMs =\n            route.options.pendingMinMs ?? this.options.defaultPendingMinMs\n          const shouldPending =\n            !preload &&\n            pendingMs &&\n            (route.options.pendingComponent ??\n              this.options.defaultPendingComponent)\n\n          const loaderContext: LoaderFnContext = {\n            params: match.params,\n            deps: match.loaderDeps,\n            preload: !!preload,\n            parentMatchPromise,\n            abortController: match.abortController,\n            context: match.context,\n            location: this.state.location,\n            navigate: (opts) =>\n              this.navigate({ ...opts, from: match.pathname } as any),\n            cause: preload ? 'preload' : match.cause,\n          }\n\n          const fetch = async () => {\n            if (match.isFetching) {\n              loadPromise = getRouteMatch(this.state, match.id)?.loadPromise\n            } else {\n              // If the user doesn't want the route to reload, just\n              // resolve with the existing loader data\n\n              if (match.fetchCount && match.status === 'success') {\n                resolve()\n              }\n\n              // Otherwise, load the route\n              matches[index] = match = {\n                ...match,\n                isFetching: true,\n                fetchCount: match.fetchCount + 1,\n              }\n\n              const componentsPromise = Promise.all(\n                componentTypes.map(async (type) => {\n                  const component = route.options[type]\n\n                  if ((component as any)?.preload) {\n                    await (component as any).preload()\n                  }\n                }),\n              )\n\n              const loaderPromise = route.options.loader?.(loaderContext)\n\n              loadPromise = Promise.all([\n                componentsPromise,\n                loaderPromise,\n              ]).then((d) => d[1])\n            }\n\n            matches[index] = match = {\n              ...match,\n              loadPromise,\n            }\n\n            updateMatch(match)\n\n            try {\n              const loaderData = await loadPromise\n              if ((latestPromise = checkLatest())) return await latestPromise\n\n              if (isRedirect(loaderData)) {\n                if (handleErrorAndRedirect(loaderData)) return\n              }\n\n              if (didShowPending && pendingMinMs) {\n                await new Promise((r) => setTimeout(r, pendingMinMs))\n              }\n\n              if ((latestPromise = checkLatest())) return await latestPromise\n\n              matches[index] = match = {\n                ...match,\n                error: undefined,\n                status: 'success',\n                isFetching: false,\n                updatedAt: Date.now(),\n                loaderData,\n                loadPromise: undefined,\n              }\n            } catch (error) {\n              if ((latestPromise = checkLatest())) return await latestPromise\n              if (handleErrorAndRedirect(error)) return\n\n              try {\n                route.options.onError?.(error)\n              } catch (onErrorError) {\n                error = onErrorError\n                if (handleErrorAndRedirect(onErrorError)) return\n              }\n\n              matches[index] = match = {\n                ...match,\n                error,\n                status: 'error',\n                isFetching: false,\n              }\n            }\n\n            updateMatch(match)\n          }\n\n          // This is where all of the stale-while-revalidate magic happens\n          const age = Date.now() - match.updatedAt\n\n          let staleAge = preload\n            ? route.options.preloadStaleTime ??\n              this.options.defaultPreloadStaleTime ??\n              30_000 // 30 seconds for preloads by default\n            : route.options.staleTime ?? this.options.defaultStaleTime ?? 0\n\n          // Default to reloading the route all the time\n          let shouldReload\n\n          const shouldReloadOption = route.options.shouldReload\n\n          // Allow shouldReload to get the last say,\n          // if provided.\n          shouldReload =\n            typeof shouldReloadOption === 'function'\n              ? shouldReloadOption(loaderContext)\n              : shouldReloadOption\n\n          matches[index] = match = {\n            ...match,\n            preload:\n              !!preload && !this.state.matches.find((d) => d.id === match.id),\n          }\n\n          if (match.status !== 'success') {\n            // If we need to potentially show the pending component,\n            // start a timer to show it after the pendingMs\n            if (shouldPending) {\n              new Promise((r) => setTimeout(r, pendingMs)).then(async () => {\n                if ((latestPromise = checkLatest())) return latestPromise\n\n                didShowPending = true\n                matches[index] = match = {\n                  ...match,\n                  showPending: true,\n                }\n\n                updateMatch(match)\n                resolve()\n              })\n            }\n\n            // Critical Fetching, we need to await\n            await fetch()\n          } else if (match.invalid || (shouldReload ?? age > staleAge)) {\n            // Background Fetching, no need to wait\n            fetch()\n          }\n\n          resolve()\n        }),\n      )\n    })\n\n    await Promise.all(matchPromises)\n    return matches\n  }\n\n  invalidate = () => {\n    const invalidate = (d: any) => ({\n      ...d,\n      invalid: true,\n    })\n\n    this.__store.setState((s) => ({\n      ...s,\n      matches: s.matches.map(invalidate),\n      cachedMatches: s.cachedMatches.map(invalidate),\n      pendingMatches: s.pendingMatches?.map(invalidate),\n    }))\n\n    this.load()\n  }\n\n  load = async (): Promise<void> => {\n    const promise = new Promise<void>(async (resolve, reject) => {\n      const next = this.latestLocation\n      const prevLocation = this.state.resolvedLocation\n      const pathDidChange = prevLocation!.href !== next.href\n      let latestPromise: Promise<void> | undefined | null\n\n      // Cancel any pending matches\n      this.cancelMatches()\n\n      this.emit({\n        type: 'onBeforeLoad',\n        fromLocation: prevLocation,\n        toLocation: next,\n        pathChanged: pathDidChange,\n      })\n\n      let pendingMatches!: RouteMatch<any, any>[]\n      const previousMatches = this.state.matches\n\n      this.__store.batch(() => {\n        this.cleanCache()\n\n        // Match the routes\n        pendingMatches = this.matchRoutes(next.pathname, next.search, {\n          debug: true,\n        })\n\n        // Ingest the new matches\n        // If a cached moved to pendingMatches, remove it from cachedMatches\n        this.__store.setState((s) => ({\n          ...s,\n          isLoading: true,\n          location: next,\n          pendingMatches,\n          cachedMatches: s.cachedMatches.filter((d) => {\n            return !pendingMatches.find((e) => e.id === d.id)\n          }),\n        }))\n      })\n\n      try {\n        try {\n          // Load the matches\n          await this.loadMatches({\n            matches: pendingMatches,\n            checkLatest: () => this.checkLatest(promise),\n          })\n        } catch (err) {\n          // swallow this error, since we'll display the\n          // errors on the route components\n        }\n\n        // Only apply the latest transition\n        if ((latestPromise = this.checkLatest(promise))) {\n          return latestPromise\n        }\n\n        const exitingMatches = previousMatches.filter(\n          (match) => !pendingMatches.find((d) => d.id === match.id),\n        )\n        const enteringMatches = pendingMatches.filter(\n          (match) => !previousMatches.find((d) => d.id === match.id),\n        )\n        const stayingMatches = previousMatches.filter((match) =>\n          pendingMatches.find((d) => d.id === match.id),\n        )\n\n        // Commit the pending matches. If a previous match was\n        // removed, place it in the cachedMatches\n        this.__store.batch(() => {\n          this.__store.setState((s) => ({\n            ...s,\n            isLoading: false,\n            matches: s.pendingMatches!,\n            pendingMatches: undefined,\n            cachedMatches: [\n              ...s.cachedMatches,\n              ...exitingMatches.filter((d) => d.status !== 'error'),\n            ],\n          }))\n          this.cleanCache()\n        })\n\n        //\n        ;(\n          [\n            [exitingMatches, 'onLeave'],\n            [enteringMatches, 'onEnter'],\n            [stayingMatches, 'onStay'],\n          ] as const\n        ).forEach(([matches, hook]) => {\n          matches.forEach((match) => {\n            this.looseRoutesById[match.routeId]!.options[hook]?.(match)\n          })\n        })\n\n        this.emit({\n          type: 'onLoad',\n          fromLocation: prevLocation,\n          toLocation: next,\n          pathChanged: pathDidChange,\n        })\n\n        resolve()\n      } catch (err) {\n        // Only apply the latest transition\n        if ((latestPromise = this.checkLatest(promise))) {\n          return latestPromise\n        }\n\n        reject(err)\n      }\n    })\n\n    this.latestLoadPromise = promise\n\n    return this.latestLoadPromise\n  }\n\n  cleanCache = () => {\n    // This is where all of the garbage collection magic happens\n    this.__store.setState((s) => {\n      return {\n        ...s,\n        cachedMatches: s.cachedMatches.filter((d) => {\n          const route = this.looseRoutesById[d.routeId]!\n\n          if (!route.options.loader) {\n            return false\n          }\n\n          // If the route was preloaded, use the preloadGcTime\n          // otherwise, use the gcTime\n          const gcTime =\n            (d.preload\n              ? route.options.preloadGcTime ?? this.options.defaultPreloadGcTime\n              : route.options.gcTime ?? this.options.defaultGcTime) ??\n            5 * 60 * 1000\n\n          return d.status !== 'error' && Date.now() - d.updatedAt < gcTime\n        }),\n      }\n    })\n  }\n\n  preloadRoute = async (\n    navigateOpts: ToOptions<TRouteTree> = this.state.location as any,\n  ) => {\n    let next = this.buildLocation(navigateOpts as any)\n\n    let matches = this.matchRoutes(next.pathname, next.search, {\n      throwOnError: true,\n    })\n\n    const loadedMatchIds = Object.fromEntries(\n      [\n        ...this.state.matches,\n        ...(this.state.pendingMatches ?? []),\n        ...this.state.cachedMatches,\n      ]?.map((d) => [d.id, true]),\n    )\n\n    this.__store.batch(() => {\n      matches.forEach((match) => {\n        if (!loadedMatchIds[match.id]) {\n          this.__store.setState((s) => ({\n            ...s,\n            cachedMatches: [...(s.cachedMatches as any), match],\n          }))\n        }\n      })\n    })\n\n    matches = await this.loadMatches({\n      matches,\n      preload: true,\n      checkLatest: () => undefined,\n    })\n\n    return matches\n  }\n\n  matchRoute: MatchRouteFn<TRouteTree> = (location, opts) => {\n    location = {\n      ...location,\n      to: location.to\n        ? this.resolvePathWithBase((location.from || '') as string, location.to)\n        : undefined,\n    } as any\n\n    const next = this.buildLocation(location as any)\n\n    if (opts?.pending && this.state.status !== 'pending') {\n      return false\n    }\n\n    const baseLocation = opts?.pending\n      ? this.latestLocation\n      : this.state.resolvedLocation\n\n    if (!baseLocation) {\n      return false\n    }\n\n    const match = matchPathname(this.basepath, baseLocation.pathname, {\n      ...opts,\n      to: next.pathname,\n    }) as any\n\n    if (!match) {\n      return false\n    }\n\n    if (match && (opts?.includeSearch ?? true)) {\n      return deepEqual(baseLocation.search, next.search, true) ? match : false\n    }\n\n    return match\n  }\n\n  injectHtml = async (html: string | (() => Promise<string> | string)) => {\n    this.injectedHtml.push(html)\n  }\n\n  dehydrateData = <T>(key: any, getData: T | (() => Promise<T> | T)) => {\n    if (typeof document === 'undefined') {\n      const strKey = typeof key === 'string' ? key : JSON.stringify(key)\n\n      this.injectHtml(async () => {\n        const id = `__TSR_DEHYDRATED__${strKey}`\n        const data =\n          typeof getData === 'function' ? await (getData as any)() : getData\n        return `<script id='${id}' suppressHydrationWarning>window[\"__TSR_DEHYDRATED__${escapeJSON(\n          strKey,\n        )}\"] = ${JSON.stringify(data)}\n          ;(() => {\n            var el = document.getElementById('${id}')\n            el.parentElement.removeChild(el)\n          })()\n          </script>`\n      })\n\n      return () => this.hydrateData<T>(key)\n    }\n\n    return () => undefined\n  }\n\n  hydrateData = <T extends any = unknown>(key: any) => {\n    if (typeof document !== 'undefined') {\n      const strKey = typeof key === 'string' ? key : JSON.stringify(key)\n\n      return window[`__TSR_DEHYDRATED__${strKey}` as any] as T\n    }\n\n    return undefined\n  }\n\n  dehydrate = (): DehydratedRouter => {\n    return {\n      state: {\n        dehydratedMatches: this.state.matches.map((d) =>\n          pick(d, ['id', 'status', 'updatedAt', 'loaderData']),\n        ),\n      },\n    }\n  }\n\n  hydrate = async (__do_not_use_server_ctx?: HydrationCtx) => {\n    let _ctx = __do_not_use_server_ctx\n    // Client hydrates from window\n    if (typeof document !== 'undefined') {\n      _ctx = window.__TSR_DEHYDRATED__\n    }\n\n    invariant(\n      _ctx,\n      'Expected to find a __TSR_DEHYDRATED__ property on window... but we did not. Did you forget to render <DehydrateRouter /> in your app?',\n    )\n\n    const ctx = _ctx\n    this.dehydratedData = ctx.payload as any\n    this.options.hydrate?.(ctx.payload as any)\n    const dehydratedState = ctx.router.state\n\n    let matches = this.matchRoutes(\n      this.state.location.pathname,\n      this.state.location.search,\n    ).map((match) => {\n      const dehydratedMatch = dehydratedState.dehydratedMatches.find(\n        (d) => d.id === match.id,\n      )\n\n      invariant(\n        dehydratedMatch,\n        `Could not find a client-side match for dehydrated match with id: ${match.id}!`,\n      )\n\n      if (dehydratedMatch) {\n        return {\n          ...match,\n          ...dehydratedMatch,\n        }\n      }\n      return match\n    })\n\n    this.__store.setState((s) => {\n      return {\n        ...s,\n        matches: matches as any,\n      }\n    })\n  }\n\n  // resolveMatchPromise = (matchId: string, key: string, value: any) => {\n  //   state.matches\n  //     .find((d) => d.id === matchId)\n  //     ?.__promisesByKey[key]?.resolve(value)\n  // }\n}\n\n// A function that takes an import() argument which is a function and returns a new function that will\n// proxy arguments from the caller to the imported function, retaining all type\n// information along the way\nexport function lazyFn<\n  T extends Record<string, (...args: any[]) => any>,\n  TKey extends keyof T = 'default',\n>(fn: () => Promise<T>, key?: TKey) {\n  return async (...args: Parameters<T[TKey]>): Promise<ReturnType<T[TKey]>> => {\n    const imported = await fn()\n    return imported[key || 'default'](...args)\n  }\n}\n\nexport class SearchParamError extends Error {}\n\nexport class PathParamError extends Error {}\n\nexport function getInitialRouterState(\n  location: ParsedLocation,\n): RouterState<any> {\n  return {\n    isLoading: false,\n    isTransitioning: false,\n    status: 'idle',\n    resolvedLocation: { ...location },\n    location,\n    matches: [],\n    pendingMatches: [],\n    cachedMatches: [],\n    lastUpdated: Date.now(),\n  }\n}\n", "import * as React from 'react'\n\nconst useLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\nimport { ParsedLocation } from './location'\nimport { useRouter } from './RouterProvider'\nimport { NonNullableUpdater, functionalUpdate } from './utils'\n\nconst windowKey = 'window'\nconst delimiter = '___'\n\nlet weakScrolledElements = new WeakSet<any>()\n\ntype CacheValue = Record<string, { scrollX: number; scrollY: number }>\ntype CacheState = {\n  cached: CacheValue\n  next: CacheValue\n}\n\ntype Cache = {\n  state: CacheState\n  set: (updater: NonNullableUpdater<CacheState>) => void\n}\n\nconst sessionsStorage = typeof window !== 'undefined' && window.sessionStorage\n\nlet cache: Cache = sessionsStorage\n  ? (() => {\n      const storageKey = 'tsr-scroll-restoration-v2'\n\n      const state: CacheState = JSON.parse(\n        window.sessionStorage.getItem(storageKey) || 'null',\n      ) || { cached: {}, next: {} }\n\n      return {\n        state,\n        set: (updater) => {\n          cache.state = functionalUpdate(updater, cache.state)\n          window.sessionStorage.setItem(storageKey, JSON.stringify(cache.state))\n        },\n      }\n    })()\n  : (undefined as any)\n\nexport type ScrollRestorationOptions = {\n  getKey?: (location: ParsedLocation) => string\n}\n\nconst defaultGetKey = (location: ParsedLocation) => location.state.key!\n\nexport function useScrollRestoration(options?: ScrollRestorationOptions) {\n  const router = useRouter()\n\n  useLayoutEffect(() => {\n    const getKey = options?.getKey || defaultGetKey\n\n    const { history } = window\n    if (history.scrollRestoration) {\n      history.scrollRestoration = 'manual'\n    }\n\n    const onScroll = (event: Event) => {\n      if (weakScrolledElements.has(event.target)) return\n      weakScrolledElements.add(event.target)\n\n      let elementSelector = ''\n\n      if (event.target === document || event.target === window) {\n        elementSelector = windowKey\n      } else {\n        const attrId = (event.target as Element).getAttribute(\n          'data-scroll-restoration-id',\n        )\n\n        if (attrId) {\n          elementSelector = `[data-scroll-restoration-id=\"${attrId}\"]`\n        } else {\n          elementSelector = getCssSelector(event.target)\n        }\n      }\n\n      if (!cache.state.next[elementSelector]) {\n        cache.set((c) => ({\n          ...c,\n          next: {\n            ...c.next,\n            [elementSelector]: {\n              scrollX: NaN,\n              scrollY: NaN,\n            },\n          },\n        }))\n      }\n    }\n\n    if (typeof document !== 'undefined') {\n      document.addEventListener('scroll', onScroll, true)\n    }\n\n    const unsubOnBeforeLoad = router.subscribe('onBeforeLoad', (event) => {\n      if (event.pathChanged) {\n        const restoreKey = getKey(event.fromLocation)\n        for (const elementSelector in cache.state.next) {\n          const entry = cache.state.next[elementSelector]!\n          if (elementSelector === windowKey) {\n            entry.scrollX = window.scrollX || 0\n            entry.scrollY = window.scrollY || 0\n          } else if (elementSelector) {\n            const element = document.querySelector(elementSelector)\n            entry.scrollX = element?.scrollLeft || 0\n            entry.scrollY = element?.scrollTop || 0\n          }\n\n          cache.set((c) => {\n            const next = { ...c.next }\n            delete next[elementSelector]\n\n            return {\n              ...c,\n              next,\n              cached: {\n                ...c.cached,\n                [[restoreKey, elementSelector].join(delimiter)]: entry,\n              },\n            }\n          })\n        }\n      }\n    })\n\n    const unsubOnResolved = router.subscribe('onResolved', (event) => {\n      if (event.pathChanged) {\n        if (!router.resetNextScroll) {\n          return\n        }\n\n        router.resetNextScroll = true\n\n        const getKey = options?.getKey || defaultGetKey\n\n        const restoreKey = getKey(event.toLocation)\n        let windowRestored = false\n\n        for (const cacheKey in cache.state.cached) {\n          const entry = cache.state.cached[cacheKey]!\n          const [key, elementSelector] = cacheKey.split(delimiter)\n          if (key === restoreKey) {\n            if (elementSelector === windowKey) {\n              windowRestored = true\n              window.scrollTo(entry.scrollX, entry.scrollY)\n            } else if (elementSelector) {\n              const element = document.querySelector(elementSelector)\n              if (element) {\n                element.scrollLeft = entry.scrollX\n                element.scrollTop = entry.scrollY\n              }\n            }\n          }\n        }\n\n        if (!windowRestored) {\n          window.scrollTo(0, 0)\n        }\n\n        cache.set((c) => ({ ...c, next: {} }))\n        weakScrolledElements = new WeakSet<any>()\n      }\n    })\n\n    return () => {\n      document.removeEventListener('scroll', onScroll)\n      unsubOnBeforeLoad()\n      unsubOnResolved()\n    }\n  }, [])\n}\n\nexport function ScrollRestoration(props: ScrollRestorationOptions) {\n  useScrollRestoration(props)\n  return null\n}\n\nexport function useElementScrollRestoration(\n  options: (\n    | {\n        id: string\n        getElement?: () => Element | undefined | null\n      }\n    | {\n        id?: string\n        getElement: () => Element | undefined | null\n      }\n  ) & {\n    getKey?: (location: ParsedLocation) => string\n  },\n) {\n  const router = useRouter()\n  const getKey = options?.getKey || defaultGetKey\n\n  let elementSelector = ''\n\n  if (options.id) {\n    elementSelector = `[data-scroll-restoration-id=\"${options.id}\"]`\n  } else {\n    const element = options.getElement?.()\n    if (!element) {\n      return\n    }\n    elementSelector = getCssSelector(element)\n  }\n\n  const restoreKey = getKey(router.latestLocation)\n  const cacheKey = [restoreKey, elementSelector].join(delimiter)\n  return cache.state.cached[cacheKey]\n}\n\nfunction getCssSelector(el: any): string {\n  let path = [],\n    parent\n  while ((parent = el.parentNode)) {\n    path.unshift(\n      `${el.tagName}:nth-child(${\n        ([].indexOf as any).call(parent.children, el) + 1\n      })`,\n    )\n    el = parent\n  }\n  return `${path.join(' > ')}`.toLowerCase()\n}\n", "import * as React from 'react'\nimport { ReactNode } from './route'\nimport { useRouter } from './RouterProvider'\nimport { BlockerFn } from '@tanstack/history'\n\nexport function useBlocker(\n  blockerFn: BlockerFn,\n  condition: boolean | any = true,\n): void {\n  const { history } = useRouter()\n\n  React.useEffect(() => {\n    if (!condition) return\n    return history.block(blockerFn)\n  })\n}\n\nexport function Block({ blocker, condition, children }: PromptProps) {\n  useBlocker(blocker, condition)\n  return (children ?? null) as ReactNode\n}\n\nexport type PromptProps = {\n  blocker: BlockerFn\n  condition?: boolean | any\n  children?: ReactNode\n}\n", "import * as React from 'react'\nimport { useMatch } from './Matches'\nimport { useRouter } from './RouterProvider'\nimport { LinkOptions, NavigateOptions } from './link'\nimport { AnyRoute } from './route'\nimport { RoutePaths } from './routeInfo'\nimport { RegisteredRouter } from './router'\nimport { useLayoutEffect } from './utils'\n\nexport function useNavigate<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TDefaultFrom extends RoutePaths<TRouteTree> = '/',\n>(defaultOpts?: { from?: TDefaultFrom }) {\n  const { navigate } = useRouter()\n  const matchPathname = useMatch({\n    strict: false,\n    select: (s) => s.pathname,\n  })\n  return React.useCallback(\n    <\n      TFrom extends RoutePaths<TRouteTree> = TDefaultFrom,\n      TTo extends string = '',\n      TMaskFrom extends RoutePaths<TRouteTree> = '/',\n      TMaskTo extends string = '',\n    >(\n      opts?: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n    ) => {\n      return navigate({\n        from: opts?.to ? matchPathname : undefined,\n        ...defaultOpts,\n        ...(opts as any),\n      })\n    },\n    [],\n  )\n}\n\n// NOTE: I don't know of anyone using this. It's undocumented, so let's wait until someone needs it\n// export function typedNavigate<\n//   TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n//   TDefaultFrom extends RoutePaths<TRouteTree> = '/',\n// >(navigate: (opts: NavigateOptions<any>) => Promise<void>) {\n//   return navigate as <\n//     TFrom extends RoutePaths<TRouteTree> = TDefaultFrom,\n//     TTo extends string = '',\n//     TMaskFrom extends RoutePaths<TRouteTree> = '/',\n//     TMaskTo extends string = '',\n//   >(\n//     opts?: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n//   ) => Promise<void>\n// } //\n\nexport function Navigate<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n>(props: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>): null {\n  const { navigate } = useRouter()\n  const match = useMatch({ strict: false })\n\n  React.useEffect(() => {\n    navigate({\n      from: props.to ? match.pathname : undefined,\n      ...props,\n    } as any)\n  }, [])\n\n  return null\n}\n\nexport type UseLinkPropsOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ActiveLinkOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> &\n  React.AnchorHTMLAttributes<HTMLAnchorElement>\n\nexport type LinkProps<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ActiveLinkOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> &\n  Omit<React.AnchorHTMLAttributes<HTMLAnchorElement>, 'children'> & {\n    // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n    children?:\n      | React.ReactNode\n      | ((state: { isActive: boolean }) => React.ReactNode)\n  }\n\nexport type ActiveLinkOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = LinkOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // A function that returns additional props for the `active` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n  activeProps?:\n    | React.AnchorHTMLAttributes<HTMLAnchorElement>\n    | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>)\n  // A function that returns additional props for the `inactive` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n  inactiveProps?:\n    | React.AnchorHTMLAttributes<HTMLAnchorElement>\n    | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>)\n}\n"],
  "mappings": ";;;;;;;;;;AAAA;AAAA;AAAA;AAYA,QAAI,MAAuC;AACzC,OAAC,WAAW;AAEJ;AAGV,YACE,OAAO,mCAAmC,eAC1C,OAAO,+BAA+B,gCACpC,YACF;AACA,yCAA+B,4BAA4B,IAAI,MAAM,CAAC;AAAA,QACxE;AACU,YAAIA,SAAQ;AAEtB,YAAI,uBAAuBA,OAAM;AAEjC,iBAAS,MAAM,QAAQ;AACrB;AACE;AACE,uBAAS,QAAQ,UAAU,QAAQ,OAAO,IAAI,MAAM,QAAQ,IAAI,QAAQ,IAAI,CAAC,GAAG,QAAQ,GAAG,QAAQ,OAAO,SAAS;AACjH,qBAAK,QAAQ,CAAC,IAAI,UAAU,KAAK;AAAA,cACnC;AAEA,2BAAa,SAAS,QAAQ,IAAI;AAAA,YACpC;AAAA,UACF;AAAA,QACF;AAEA,iBAAS,aAAa,OAAO,QAAQ,MAAM;AAGzC;AACE,gBAAI,yBAAyB,qBAAqB;AAClD,gBAAI,QAAQ,uBAAuB,iBAAiB;AAEpD,gBAAI,UAAU,IAAI;AAChB,wBAAU;AACV,qBAAO,KAAK,OAAO,CAAC,KAAK,CAAC;AAAA,YAC5B;AAGA,gBAAI,iBAAiB,KAAK,IAAI,SAAU,MAAM;AAC5C,qBAAO,OAAO,IAAI;AAAA,YACpB,CAAC;AAED,2BAAe,QAAQ,cAAc,MAAM;AAI3C,qBAAS,UAAU,MAAM,KAAK,QAAQ,KAAK,GAAG,SAAS,cAAc;AAAA,UACvE;AAAA,QACF;AAMA,iBAAS,GAAG,GAAG,GAAG;AAChB,iBAAO,MAAM,MAAM,MAAM,KAAK,IAAI,MAAM,IAAI,MAAM,MAAM,KAAK,MAAM;AAAA,QAErE;AAEA,YAAI,WAAW,OAAO,OAAO,OAAO,aAAa,OAAO,KAAK;AAI7D,YAAIC,YAAWD,OAAM,UACjBE,aAAYF,OAAM,WAClBG,mBAAkBH,OAAM,iBACxB,gBAAgBA,OAAM;AAC1B,YAAI,oBAAoB;AACxB,YAAI,6BAA6B;AAWjC,iBAAS,qBAAqB,WAAW,aAIzC,mBAAmB;AACjB;AACE,gBAAI,CAAC,mBAAmB;AACtB,kBAAIA,OAAM,oBAAoB,QAAW;AACvC,oCAAoB;AAEpB,sBAAM,gMAA+M;AAAA,cACvN;AAAA,YACF;AAAA,UACF;AAMA,cAAI,QAAQ,YAAY;AAExB;AACE,gBAAI,CAAC,4BAA4B;AAC/B,kBAAI,cAAc,YAAY;AAE9B,kBAAI,CAAC,SAAS,OAAO,WAAW,GAAG;AACjC,sBAAM,sEAAsE;AAE5E,6CAA6B;AAAA,cAC/B;AAAA,YACF;AAAA,UACF;AAgBA,cAAI,YAAYC,UAAS;AAAA,YACvB,MAAM;AAAA,cACJ;AAAA,cACA;AAAA,YACF;AAAA,UACF,CAAC,GACG,OAAO,UAAU,CAAC,EAAE,MACpB,cAAc,UAAU,CAAC;AAK7B,UAAAE,iBAAgB,WAAY;AAC1B,iBAAK,QAAQ;AACb,iBAAK,cAAc;AAKnB,gBAAI,uBAAuB,IAAI,GAAG;AAEhC,0BAAY;AAAA,gBACV;AAAA,cACF,CAAC;AAAA,YACH;AAAA,UACF,GAAG,CAAC,WAAW,OAAO,WAAW,CAAC;AAClC,UAAAD,WAAU,WAAY;AAGpB,gBAAI,uBAAuB,IAAI,GAAG;AAEhC,0BAAY;AAAA,gBACV;AAAA,cACF,CAAC;AAAA,YACH;AAEA,gBAAI,oBAAoB,WAAY;AAOlC,kBAAI,uBAAuB,IAAI,GAAG;AAEhC,4BAAY;AAAA,kBACV;AAAA,gBACF,CAAC;AAAA,cACH;AAAA,YACF;AAGA,mBAAO,UAAU,iBAAiB;AAAA,UACpC,GAAG,CAAC,SAAS,CAAC;AACd,wBAAc,KAAK;AACnB,iBAAO;AAAA,QACT;AAEA,iBAAS,uBAAuB,MAAM;AACpC,cAAI,oBAAoB,KAAK;AAC7B,cAAI,YAAY,KAAK;AAErB,cAAI;AACF,gBAAI,YAAY,kBAAkB;AAClC,mBAAO,CAAC,SAAS,WAAW,SAAS;AAAA,UACvC,SAASE,QAAO;AACd,mBAAO;AAAA,UACT;AAAA,QACF;AAEA,iBAAS,uBAAuB,WAAW,aAAa,mBAAmB;AAKzE,iBAAO,YAAY;AAAA,QACrB;AAEA,YAAI,YAAY,CAAC,EAAE,OAAO,WAAW,eAAe,OAAO,OAAO,aAAa,eAAe,OAAO,OAAO,SAAS,kBAAkB;AAEvI,YAAI,sBAAsB,CAAC;AAE3B,YAAI,OAAO,sBAAsB,yBAAyB;AAC1D,YAAI,yBAAyBJ,OAAM,yBAAyB,SAAYA,OAAM,uBAAuB;AAErG,gBAAQ,uBAAuB;AAE/B,YACE,OAAO,mCAAmC,eAC1C,OAAO,+BAA+B,+BACpC,YACF;AACA,yCAA+B,2BAA2B,IAAI,MAAM,CAAC;AAAA,QACvE;AAAA,MAEE,GAAG;AAAA,IACL;AAAA;AAAA;;;AC9OA;AAAA;AAAA;AAEA,QAAI,OAAuC;AACzC,aAAO,UAAU;AAAA,IACnB,OAAO;AACL,aAAO,UAAU;AAAA,IACnB;AAAA;AAAA;;;ACNA;AAAA;AAAA;AAYA,QAAI,MAAuC;AACzC,OAAC,WAAW;AAEJ;AAGV,YACE,OAAO,mCAAmC,eAC1C,OAAO,+BAA+B,gCACpC,YACF;AACA,yCAA+B,4BAA4B,IAAI,MAAM,CAAC;AAAA,QACxE;AACU,YAAIK,SAAQ;AACtB,YAAI,OAAO;AAMX,iBAAS,GAAG,GAAG,GAAG;AAChB,iBAAO,MAAM,MAAM,MAAM,KAAK,IAAI,MAAM,IAAI,MAAM,MAAM,KAAK,MAAM;AAAA,QAErE;AAEA,YAAI,WAAW,OAAO,OAAO,OAAO,aAAa,OAAO,KAAK;AAE7D,YAAI,uBAAuB,KAAK;AAIhC,YAAIC,UAASD,OAAM,QACfE,aAAYF,OAAM,WAClB,UAAUA,OAAM,SAChB,gBAAgBA,OAAM;AAE1B,iBAASG,kCAAiC,WAAW,aAAa,mBAAmB,UAAU,SAAS;AAEtG,cAAI,UAAUF,QAAO,IAAI;AACzB,cAAI;AAEJ,cAAI,QAAQ,YAAY,MAAM;AAC5B,mBAAO;AAAA,cACL,UAAU;AAAA,cACV,OAAO;AAAA,YACT;AACA,oBAAQ,UAAU;AAAA,UACpB,OAAO;AACL,mBAAO,QAAQ;AAAA,UACjB;AAEA,cAAI,WAAW,QAAQ,WAAY;AAKjC,gBAAI,UAAU;AACd,gBAAI;AACJ,gBAAI;AAEJ,gBAAI,mBAAmB,SAAU,cAAc;AAC7C,kBAAI,CAAC,SAAS;AAEZ,0BAAU;AACV,mCAAmB;AAEnB,oBAAI,iBAAiB,SAAS,YAAY;AAE1C,oBAAI,YAAY,QAAW;AAIzB,sBAAI,KAAK,UAAU;AACjB,wBAAI,mBAAmB,KAAK;AAE5B,wBAAI,QAAQ,kBAAkB,cAAc,GAAG;AAC7C,0CAAoB;AACpB,6BAAO;AAAA,oBACT;AAAA,kBACF;AAAA,gBACF;AAEA,oCAAoB;AACpB,uBAAO;AAAA,cACT;AAIA,kBAAI,eAAe;AACnB,kBAAI,gBAAgB;AAEpB,kBAAI,SAAS,cAAc,YAAY,GAAG;AAExC,uBAAO;AAAA,cACT;AAIA,kBAAI,gBAAgB,SAAS,YAAY;AASzC,kBAAI,YAAY,UAAa,QAAQ,eAAe,aAAa,GAAG;AAClE,uBAAO;AAAA,cACT;AAEA,iCAAmB;AACnB,kCAAoB;AACpB,qBAAO;AAAA,YACT;AAIA,gBAAI,yBAAyB,sBAAsB,SAAY,OAAO;AAEtE,gBAAI,0BAA0B,WAAY;AACxC,qBAAO,iBAAiB,YAAY,CAAC;AAAA,YACvC;AAEA,gBAAI,gCAAgC,2BAA2B,OAAO,SAAY,WAAY;AAC5F,qBAAO,iBAAiB,uBAAuB,CAAC;AAAA,YAClD;AACA,mBAAO,CAAC,yBAAyB,6BAA6B;AAAA,UAChE,GAAG,CAAC,aAAa,mBAAmB,UAAU,OAAO,CAAC,GAClD,eAAe,SAAS,CAAC,GACzB,qBAAqB,SAAS,CAAC;AAEnC,cAAI,QAAQ,qBAAqB,WAAW,cAAc,kBAAkB;AAC5E,UAAAC,WAAU,WAAY;AACpB,iBAAK,WAAW;AAChB,iBAAK,QAAQ;AAAA,UACf,GAAG,CAAC,KAAK,CAAC;AACV,wBAAc,KAAK;AACnB,iBAAO;AAAA,QACT;AAEA,gBAAQ,mCAAmCC;AAE3C,YACE,OAAO,mCAAmC,eAC1C,OAAO,+BAA+B,+BACpC,YACF;AACA,yCAA+B,2BAA2B,IAAI,MAAM,CAAC;AAAA,QACvE;AAAA,MAEE,GAAG;AAAA,IACL;AAAA;AAAA;;;ACpKA;AAAA;AAAA;AAEA,QAAI,OAAuC;AACzC,aAAO,UAAU;AAAA,IACnB,OAAO;AACL,aAAO,UAAU;AAAA,IACnB;AAAA;AAAA;;;ACkCA,IAAMC,iBAAiB;AACvB,IAAMC,gBAAgB;AACtB,IAAMC,oBAAoB;AAE1B,IAAMC,uBAAwBC,WAAiB;AAC7CA,QAAMC,eAAc;AAEpB,SAAQD,MAAME,cAAc;AAC9B;AAEA,IAAMC,eAAeA,MAAM;AACzBC,sBAAoBN,mBAAmBC,sBAAsB;IAC3DM,SAAS;EACX,CAAC;AACH;AAEO,SAASC,cAAcC,MAWZ;AAChB,MAAIC,WAAWD,KAAKE,YAAW;AAC/B,MAAIC,cAAc,oBAAIC,IAAG;AACzB,MAAIC,WAAwB,CAAA;AAE5B,QAAMC,WAAWA,MAAM;AACrBL,eAAWD,KAAKE,YAAW;AAC3BC,gBAAYI,QAASC,gBAAeA,WAAU,CAAE;;AAGlD,QAAMC,gBAAgB,OAAOC,SAAqB;;AAChD,QAAI,OAAOC,aAAa,eAAeN,SAASO,QAAQ;AACtD,eAASC,WAAWR,UAAU;AAC5B,cAAMS,UAAU,MAAMD,QAAO;AAC7B,YAAI,CAACC,SAAS;AACZd,qBAAKe,cAALf,8BAAiBM;AACjB;QACF;MACF;IACF;AAEAI,SAAI;;AAGN,SAAO;IACL,IAAIT,WAAW;AACb,aAAOA;;IAETe,WAAYC,QAAmB;AAC7Bd,kBAAYe,IAAID,EAAE;AAElB,aAAO,MAAM;AACXd,oBAAYgB,OAAOF,EAAE;;;IAGzBG,MAAMA,CAACC,MAAcC,UAAe;AAClCA,cAAQC,UAAUD,KAAK;AACvBb,oBAAc,MAAM;AAClBT,aAAKwB,UAAUH,MAAMC,OAAOhB,QAAQ;MACtC,CAAC;;IAEHmB,SAASA,CAACJ,MAAcC,UAAe;AACrCA,cAAQC,UAAUD,KAAK;AACvBb,oBAAc,MAAM;AAClBT,aAAK0B,aAAaL,MAAMC,OAAOhB,QAAQ;MACzC,CAAC;;IAEHqB,IAAKC,WAAU;AACbnB,oBAAc,MAAM;AAClBT,aAAK2B,GAAGC,KAAK;MACf,CAAC;;IAEHC,MAAMA,MAAM;AACVpB,oBAAc,MAAM;AAClBT,aAAK6B,KAAI;MACX,CAAC;;IAEHC,SAASA,MAAM;AACbrB,oBAAc,MAAM;AAClBT,aAAK8B,QAAO;MACd,CAAC;;IAEHC,YAAaC,SAAQhC,KAAK+B,WAAWC,GAAG;IACxCC,OAAQpB,aAAY;AAClBR,eAASe,KAAKP,OAAO;AAErB,UAAIR,SAASO,WAAW,GAAG;AACzBsB,yBAAiB3C,mBAAmBC,sBAAsB;UACxDM,SAAS;QACX,CAAC;MACH;AAEA,aAAO,MAAM;AACXO,mBAAWA,SAAS8B,OAAQC,OAAMA,MAAMvB,OAAO;AAE/C,YAAI,CAACR,SAASO,QAAQ;AACpBhB,uBAAY;QACd;;;IAGJyC,OAAOA,MAAAA;;AAAMrC,wBAAKqC,UAALrC;;IACbsC,SAASA,MAAAA;;AAAMtC,wBAAKsC,YAALtC;;IACfuC,QAAQjC;;AAEZ;AAEA,SAASiB,UAAUD,OAAqB;AACtC,MAAI,CAACA,OAAO;AACVA,YAAQ,CAAA;EACV;AACA,SAAO;IACL,GAAGA;IACHkB,KAAKC,gBAAe;;AAExB;AAkBO,SAASC,qBAAqB1C,MAInB;AAChB,QAAM2C,OACJ3C,6BAAM4C,YACL,OAAOjC,aAAa,cAAciC,SAAUC;AAE/C,QAAMd,cAAa/B,6BAAM+B,gBAAgBV,UAASA;AAClD,QAAMyB,iBACJ9C,6BAAM8C,mBACL,MACCC,UACG,GAAEJ,IAAI1C,SAAS+C,QAAS,GAAEL,IAAI1C,SAASgD,MAAO,GAAEN,IAAI1C,SAASiD,IAAK,IACnEP,IAAIQ,QAAQ7B,KACd;AAEJ,MAAI8B,kBAAkBN,cAAa;AACnC,MAAIO;AAEJ,QAAMnD,cAAcA,MAAMkD;AAE1B,MAAIE;AAeJ,MAAIC,WAAW;AAIf,MAAIC;AAIJ,QAAMC,UAAWC,QAAmB;AAClCH,eAAW;AACXG,OAAE;AACFH,eAAW;;AAIb,QAAMlB,QAAQA,MAAM;AAElBoB,YAAQ,MAAM;AACZ,UAAI,CAACH;AAAM;AACXX,UAAIQ,QAAQG,KAAKK,SAAS,cAAc,cAAc,EACpDL,KAAKhC,OACL,IACAgC,KAAKM,IACP;AAEAN,aAAOT;AACPW,kBAAYX;AACZQ,yBAAmBR;IACrB,CAAC;;AAIH,QAAMgB,qBAAqBA,CACzBC,MACAC,UACAzC,OACAhB,aACG;AACH,UAAMsD,OAAO7B,WAAWgC,QAAQ;AAEhC,QAAI,CAACP,WAAW;AACdH,yBAAmBD;IACrB;AAGAA,sBAAkBL,UAAUgB,UAAUzC,KAAK;AAG3CgC,WAAO;MACLM;MACAtC;MACAqC,SAAQL,6BAAMK,WAAUG,SAAS;;AAInCxD,aAAQ;AAER,QAAI,CAACkD,WAAW;AAEdA,kBAAYQ,QAAQC,QAAO,EAAGC,KAAK,MAAM7B,MAAK,CAAE;IAClD;;AAGF,QAAM8B,YAAYA,MAAM;AACtBf,sBAAkBN,cAAa;AAC/BK,YAAQZ,OAAM;;AAGhB,MAAI6B,oBAAoBzB,IAAIQ,QAAQ3B;AACpC,MAAI6C,uBAAuB1B,IAAIQ,QAAQzB;AAEvC,QAAMyB,UAAUpD,cAAc;IAC5BG;IACAsB,WAAWA,CAACoC,MAAMtC,OAAOhB,aACvBuD,mBAAmB,QAAQD,MAAMtC,OAAOhB,QAAQ;IAClDoB,cAAcA,CAACkC,MAAMtC,OAAOhB,aAC1BuD,mBAAmB,WAAWD,MAAMtC,OAAOhB,QAAQ;IACrDuB,MAAMA,MAAMc,IAAIQ,QAAQtB,KAAI;IAC5BC,SAASA,MAAMa,IAAIQ,QAAQrB,QAAO;IAClCH,IAAK2C,OAAM3B,IAAIQ,QAAQxB,GAAG2C,CAAC;IAC3BvC,YAAa6B,UAAS7B,WAAW6B,IAAI;IACrCvB;IACAC,SAASA,MAAM;AACbK,UAAIQ,QAAQ3B,YAAY4C;AACxBzB,UAAIQ,QAAQzB,eAAe2C;AAC3B1B,UAAI9C,oBAAoBR,gBAAgB8E,SAAS;AACjDxB,UAAI9C,oBAAoBP,eAAe6E,SAAS;;IAElDpD,WAAYT,cAAa;AAGvB,UAAI+C,oBAAoBD,oBAAoBC,kBAAkB;AAC5DD,0BAAkBC;AAElB/C,iBAAQ;MACV;IACF;EACF,CAAC;AAEDqC,MAAIT,iBAAiB7C,gBAAgB8E,SAAS;AAC9CxB,MAAIT,iBAAiB5C,eAAe6E,SAAS;AAE7CxB,MAAIQ,QAAQ3B,YAAY,WAAY;AAClC,QAAI+C,MAAMH,kBAAkBI,MAAM7B,IAAIQ,SAASsB,SAAgB;AAC/D,QAAIlB;AAAUJ,cAAQZ,OAAM;AAC5B,WAAOgC;;AAGT5B,MAAIQ,QAAQzB,eAAe,WAAY;AACrC,QAAI6C,MAAMF,qBAAqBG,MAAM7B,IAAIQ,SAASsB,SAAgB;AAClE,QAAIlB;AAAUJ,cAAQZ,OAAM;AAC5B,WAAOgC;;AAGT,SAAOpB;AACT;AAEO,SAASuB,kBAAkB1E,MAAwC;AACxE,QAAM2C,OACJ3C,6BAAM4C,YACL,OAAOjC,aAAa,cAAciC,SAAUC;AAC/C,SAAOH,qBAAqB;IAC1BE,QAAQD;IACRG,eAAeA,MAAM;AACnB,YAAM6B,WAAWhC,IAAI1C,SAASiD,KAAK0B,MAAM,GAAG,EAAEC,MAAM,CAAC,EAAEC,KAAK,GAAG,KAAK;AACpE,aAAO/B,UAAU4B,UAAUhC,IAAIQ,QAAQ7B,KAAK;;IAE9CS,YAAa6B,UACV,GAAEjB,IAAI1C,SAAS+C,QAAS,GAAEL,IAAI1C,SAASgD,MAAO,IAAGW,IAAK;EAC3D,CAAC;AACH;AAEO,SAASmB,oBACd/E,OAGI;EACFgF,gBAAgB,CAAC,GAAG;AACtB,GACe;AACf,QAAMC,UAAUjF,KAAKgF;AACrB,MAAIpD,QAAQ5B,KAAKkF,gBAAgBD,QAAQrE,SAAS;AAClD,MAAIuE,eAAe;IACjB3C,KAAKC,gBAAe;;AAGtB,QAAMvC,cAAcA,MAAM6C,UAAUkC,QAAQrD,KAAK,GAAIuD,YAAY;AAEjE,SAAOpF,cAAc;IACnBG;IACAsB,WAAWA,CAACH,MAAMC,UAAU;AAC1B6D,qBAAe7D;AACf2D,cAAQ7D,KAAKC,IAAI;AACjBO;;IAEFF,cAAcA,CAACL,MAAMC,UAAU;AAC7B6D,qBAAe7D;AACf2D,cAAQrD,KAAK,IAAIP;;IAEnBQ,MAAMA,MAAM;AACVD;;IAEFE,SAASA,MAAM;AACbF,cAAQwD,KAAKC,IAAIzD,QAAQ,GAAGqD,QAAQrE,SAAS,CAAC;;IAEhDe,IAAK2C,OAAM;AACT1C,cAAQwD,KAAKC,IAAID,KAAKE,IAAI1D,QAAQ0C,GAAG,CAAC,GAAGW,QAAQrE,SAAS,CAAC;;IAE7DmB,YAAaV,UAASA;EACxB,CAAC;AACH;AAEA,SAAS0B,UAAUa,MAActC,OAAsC;AACrE,MAAIiE,YAAY3B,KAAK4B,QAAQ,GAAG;AAChC,MAAIC,cAAc7B,KAAK4B,QAAQ,GAAG;AAElC,SAAO;IACL5B;IACAZ,UAAUY,KAAK8B,UACb,GACAH,YAAY,IACRE,cAAc,IACZL,KAAKC,IAAIE,WAAWE,WAAW,IAC/BF,YACFE,cAAc,IACZA,cACA7B,KAAKhD,MACb;IACAsC,MAAMqC,YAAY,KAAK3B,KAAK8B,UAAUH,SAAS,IAAI;IACnDtC,QACEwC,cAAc,KACV7B,KAAKiB,MAAMY,aAAaF,cAAc,KAAK1C,SAAY0C,SAAS,IAChE;IACNjE,OAAOA,SAAS,CAAA;;AAEpB;AAGA,SAASmB,kBAAkB;AACzB,UAAQ2C,KAAKO,OAAM,IAAK,GAAGC,SAAS,EAAE,EAAEF,UAAU,CAAC;AACrD;;;ACjaA,IAAI,eAAe;AACnB,IAAI,SAAS;AACb,SAAS,UAAU,WAAW,SAAS;AACnC,MAAI,WAAW;AACX;AAAA,EACJ;AACA,MAAI,cAAc;AACd,UAAM,IAAI,MAAM,MAAM;AAAA,EAC1B;AACA,MAAI,WAAW,OAAO,YAAY,aAAa,QAAQ,IAAI;AAC3D,MAAI,QAAQ,WAAW,GAAG,OAAO,QAAQ,IAAI,EAAE,OAAO,QAAQ,IAAI;AAClE,QAAM,IAAI,MAAM,KAAK;AACzB;;;ACZA,IAAIG,gBAAe;AACnB,SAAS,QAAQ,WAAW,SAAS;AACnC,MAAI,CAACA,eAAc;AACjB,QAAI,WAAW;AACb;AAAA,IACF;AAEA,QAAI,OAAO,cAAc;AAEzB,QAAI,OAAO,YAAY,aAAa;AAClC,cAAQ,KAAK,IAAI;AAAA,IACnB;AAEA,QAAI;AACF,YAAM,MAAM,IAAI;AAAA,IAClB,SAAS,GAAG;AAAA,IAAC;AAAA,EACf;AACF;AAEA,IAAO,2BAAQ;;;;;;AClBf,2BAAiD;;;ACkB1C,IAAM,QAAN,MAGL;EAQA,YAAY,cAAsB,SAA0C;AAP5E,SAAA,YAAY,oBAAI,IAAc;AAG9B,SAAA,YAAY;AACZ,SAAA,YAAY;AACZ,SAAA,gBAAiC;AAOjC,SAAA,YAAY,CAAC,aAAuB;;AAClC,WAAK,UAAU,IAAI,QAAQ;AAC3B,YAAM,SAAQ,gBAAK,YAAL,mBAAc,gBAAd,4BAA4B,UAAU;AACpD,aAAO,MAAM;AACX,aAAK,UAAU,OAAO,QAAQ;AAC9B;MACF;IACF;AAEA,SAAA,WAAW,CACT,SACA,SAGG;;AACH,YAAM,WAAW,KAAK;AACtB,WAAK,UAAQ,UAAK,YAAL,mBAAc,YACvB,KAAK,QAAQ,SAAS,QAAQ,EAAE,OAAO,IACtC,QAAgB,QAAQ;AAE7B,YAAM,YAAW,6BAAM,eAAY,UAAK,YAAL,mBAAc,oBAAmB;AACpE,UAAI,KAAK,kBAAkB,MAAM;AAC/B,aAAK,gBAAgB;MACvB,WAAW,KAAK,kBAAkB,QAAQ;AACxC,aAAK,gBAAgB;MACvB,OAAO;AACL,aAAK,kBAAgB,UAAK,YAAL,mBAAc,oBAAmB;MACxD;AAGA,uBAAK,YAAL,mBAAc,aAAd,4BAAyB;QACvB,UAAU,KAAK;MACjB;AAGA,WAAK,OAAO;IACd;AAEA,SAAA,SAAS,MAAM;AACb,UAAI,KAAK;AAAW;AACpB,YAAM,UAAU,EAAE,KAAK;AACvB,WAAK,UAAU,QAAQ,CAAC,aAAa;AACnC,YAAI,KAAK,cAAc;AAAS;AAChC,iBAAS;UACP,UAAU,KAAK,iBAAiB;QAClC,CAAC;MACH,CAAC;IACH;AAEA,SAAA,QAAQ,CAAC,OAAmB;AAC1B,UAAI,KAAK;AAAW,eAAO,GAAG;AAC9B,WAAK,YAAY;AACjB,SAAG;AACH,WAAK,YAAY;AACjB,WAAK,OAAO;IACd;AA3DE,SAAK,QAAQ;AACb,SAAK,UAAU;EACjB;AA0DF;;;ADpFO,SAAS,SAKd,OACA,WAAkD,CAAC,MAAM,GACzD;AACA,QAAM,YAAQ;IACZ,MAAM;IACN,MAAM,MAAM;IACZ,MAAM,MAAM;IACZ;IACA;EACF;AAEA,SAAO;AACT;AAEO,SAAS,QAAW,MAAS,MAAS;AAC3C,MAAI,OAAO,GAAG,MAAM,IAAI,GAAG;AACzB,WAAO;EACT;AAEA,MACE,OAAO,SAAS,YAChB,SAAS,QACT,OAAO,SAAS,YAChB,SAAS,MACT;AACA,WAAO;EACT;AAEA,QAAM,QAAQ,OAAO,KAAK,IAAI;AAC9B,MAAI,MAAM,WAAW,OAAO,KAAK,IAAI,EAAE,QAAQ;AAC7C,WAAO;EACT;AAEA,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,QACE,CAAC,OAAO,UAAU,eAAe,KAAK,MAAM,MAAM,CAAC,CAAW,KAC9D,CAAC,OAAO,GAAG,KAAK,MAAM,CAAC,CAAY,GAAG,KAAK,MAAM,CAAC,CAAY,CAAC,GAC/D;AACA,aAAO;IACT;EACF;AACA,SAAO;AACT;;;AEpDO,SAASC,cAAcC,OAK3B;AACD,QAAMC,iBAAiBD,MAAMC,kBAAkBC;AAE/C,SACEC,oBAACC,mBAAiB;IAChBC,aAAaL,MAAMK;IACnBC,SAASN,MAAMM;IACfC,UAAUA,CAAC;MAAEC;IAAM,MAAM;AACvB,UAAIA,OAAO;AACT,eAAaL,oBAAcF,gBAAgB;UACzCO;QACF,CAAC;MACH;AAEA,aAAOR,MAAMO;IACf;EAAE,CACH;AAEL;AAEO,IAAMH,oBAAN,cAAsCK,gBAI1C;EAJI;;AAKLC,iCAAQ;MAAEF,OAAO;;;EACjB,OAAOG,yBAAyBX,OAAY;AAC1C,WAAO;MAAEY,UAAUZ,MAAMK,YAAW;;EACtC;EACA,OAAOQ,yBAAyBL,OAAY;AAC1C,WAAO;MAAEA;;EACX;EACAM,mBACEC,WAKAC,WACM;AACN,QAAIA,UAAUR,SAASQ,UAAUJ,aAAa,KAAKF,MAAME,UAAU;AACjE,WAAKK,SAAS;QAAET,OAAO;MAAK,CAAC;IAC/B;EACF;EACAU,kBAAkBV,OAAY;;AAC5BW,YAAQX,MAAMA,KAAK;AACnB,qBAAKR,OAAMM,YAAX,4BAAqBE;EACvB;EACAY,SAAS;AACP,WAAO,KAAKpB,MAAMO,SAAS,KAAKG,KAAK;EACvC;AACF;AAEO,SAASR,eAAe;EAAEM;AAAsB,GAAG;AACxD,QAAM,CAACa,MAAMC,OAAO,IAAUC,eAASC,IAAqC;AAE5E,SACErB,oBAAA,OAAA;IAAKsB,OAAO;MAAEC,SAAS;MAASC,UAAU;IAAO;KAC/CxB,oBAAA,OAAA;IAAKsB,OAAO;MAAEG,SAAS;MAAQC,YAAY;MAAUC,KAAK;IAAQ;KAChE3B,oBAAA,UAAA;IAAQsB,OAAO;MAAEM,UAAU;IAAO;EAAE,GAAC,uBAA6B,GAClE5B,oBAAA,UAAA;IACEsB,OAAO;MACLO,YAAY;MACZD,UAAU;MACVE,QAAQ;MACRP,SAAS;MACTQ,YAAY;MACZC,cAAc;;IAEhBC,SAASA,MAAMd,QAASe,OAAM,CAACA,CAAC;KAE/BhB,OAAO,eAAe,YACjB,CACL,GACLlB,oBAAA,OAAA;IAAKsB,OAAO;MAAEa,QAAQ;IAAS;GAAI,GAClCjB,OACClB,oBAAA,OAAA,MACEA,oBAAA,OAAA;IACEsB,OAAO;MACLM,UAAU;MACVE,QAAQ;MACRE,cAAc;MACdT,SAAS;MACTa,OAAO;MACPC,UAAU;IACZ;EAAE,GAEDhC,MAAMiC,UAAUtC,oBAAOK,QAAAA,MAAAA,MAAMiC,OAAc,IAAI,IAC7C,CACF,IACH,IACD;AAET;IC+CaC,WAAW,OAAOC,aAAa;AAErC,SAASC,KAAQC,KAAU;AAChC,SAAOA,IAAIA,IAAIC,SAAS,CAAC;AAC3B;AAEA,SAASC,WAAWV,GAAuB;AACzC,SAAO,OAAOA,MAAM;AACtB;AAEO,SAASW,iBACdC,SACAC,UACS;AACT,MAAIH,WAAWE,OAAO,GAAG;AACvB,WAAOA,QAAQC,QAAmB;EACpC;AAEA,SAAOD;AACT;AAEO,SAASE,KAA2BC,QAAWC,MAAuB;AAC3E,SAAOA,KAAKC,OAAO,CAACC,KAAUC,QAAW;AACvCD,QAAIC,GAAG,IAAIJ,OAAOI,GAAG;AACrB,WAAOD;KACN,CAAA,CAAS;AACd;AAQO,SAASE,iBAAoBC,MAAWC,OAAa;AAC1D,MAAID,SAASC,OAAO;AAClB,WAAOD;EACT;AAEA,QAAME,OAAOD;AAEb,QAAME,QAAQC,MAAMC,QAAQL,IAAI,KAAKI,MAAMC,QAAQH,IAAI;AAEvD,MAAIC,SAAUG,cAAcN,IAAI,KAAKM,cAAcJ,IAAI,GAAI;AACzD,UAAMK,WAAWJ,QAAQH,KAAKZ,SAASoB,OAAOb,KAAKK,IAAI,EAAEZ;AACzD,UAAMqB,YAAYN,QAAQD,OAAOM,OAAOb,KAAKO,IAAI;AACjD,UAAMQ,WAAWD,UAAUrB;AAC3B,UAAMuB,OAAYR,QAAQ,CAAA,IAAK,CAAA;AAE/B,QAAIS,aAAa;AAEjB,aAASC,IAAI,GAAGA,IAAIH,UAAUG,KAAK;AACjC,YAAMf,MAAMK,QAAQU,IAAIJ,UAAUI,CAAC;AACnCF,WAAKb,GAAG,IAAIC,iBAAiBC,KAAKF,GAAG,GAAGI,KAAKJ,GAAG,CAAC;AACjD,UAAIa,KAAKb,GAAG,MAAME,KAAKF,GAAG,GAAG;AAC3Bc;MACF;IACF;AAEA,WAAOL,aAAaG,YAAYE,eAAeL,WAAWP,OAAOW;EACnE;AAEA,SAAOT;AACT;AAGO,SAASI,cAAcQ,GAAQ;AACpC,MAAI,CAACC,mBAAmBD,CAAC,GAAG;AAC1B,WAAO;EACT;AAGA,QAAME,OAAOF,EAAEG;AACf,MAAI,OAAOD,SAAS,aAAa;AAC/B,WAAO;EACT;AAGA,QAAME,OAAOF,KAAKG;AAClB,MAAI,CAACJ,mBAAmBG,IAAI,GAAG;AAC7B,WAAO;EACT;AAGA,MAAI,CAACA,KAAKE,eAAe,eAAe,GAAG;AACzC,WAAO;EACT;AAGA,SAAO;AACT;AAEA,SAASL,mBAAmBD,GAAQ;AAClC,SAAON,OAAOW,UAAUE,SAASC,KAAKR,CAAC,MAAM;AAC/C;AAEO,SAASS,UAAUC,GAAQC,GAAQC,UAAmB,OAAgB;AAC3E,MAAIF,MAAMC,GAAG;AACX,WAAO;EACT;AAEA,MAAI,OAAOD,MAAM,OAAOC,GAAG;AACzB,WAAO;EACT;AAEA,MAAInB,cAAckB,CAAC,KAAKlB,cAAcmB,CAAC,GAAG;AACxC,UAAME,QAAQnB,OAAOb,KAAK6B,CAAC;AAC3B,UAAMI,QAAQpB,OAAOb,KAAK8B,CAAC;AAE3B,QAAI,CAACC,WAAWC,MAAMvC,WAAWwC,MAAMxC,QAAQ;AAC7C,aAAO;IACT;AAEA,WAAO,CAACwC,MAAMC,KACX/B,SAAQ,EAAEA,OAAO0B,MAAM,CAACD,UAAUC,EAAE1B,GAAG,GAAG2B,EAAE3B,GAAG,GAAG4B,OAAO,CAC5D;EACF;AAEA,MAAItB,MAAMC,QAAQmB,CAAC,KAAKpB,MAAMC,QAAQoB,CAAC,GAAG;AACxC,WAAO,CAACD,EAAEK,KAAK,CAACC,MAAMC,UAAU,CAACR,UAAUO,MAAML,EAAEM,KAAK,GAAGL,OAAO,CAAC;EACrE;AAEA,SAAO;AACT;AAEO,SAASM,kBAAqDC,IAAU;AAC7E,QAAMC,QAAcC,aAAOF,EAAE;AAC7BC,QAAME,UAAUH;AAEhB,QAAMI,MAAYF,aAAO,IAAIG,SAAgBJ,MAAME,QAAQ,GAAGE,IAAI,CAAC;AACnE,SAAOD,IAAID;AACb;AAEO,SAASG,SAAWC,MAASC,MAAS;AAC3C,MAAIjC,OAAOkC,GAAGF,MAAMC,IAAI,GAAG;AACzB,WAAO;EACT;AAEA,MACE,OAAOD,SAAS,YAChBA,SAAS,QACT,OAAOC,SAAS,YAChBA,SAAS,MACT;AACA,WAAO;EACT;AAEA,QAAME,QAAQnC,OAAOb,KAAK6C,IAAI;AAC9B,MAAIG,MAAMvD,WAAWoB,OAAOb,KAAK8C,IAAI,EAAErD,QAAQ;AAC7C,WAAO;EACT;AAEA,WAASyB,IAAI,GAAGA,IAAI8B,MAAMvD,QAAQyB,KAAK;AACrC,QACE,CAACL,OAAOW,UAAUC,eAAeE,KAAKmB,MAAME,MAAM9B,CAAC,CAAW,KAC9D,CAACL,OAAOkC,GAAGF,KAAKG,MAAM9B,CAAC,CAAC,GAAc4B,KAAKE,MAAM9B,CAAC,CAAC,CAAY,GAC/D;AACA,aAAO;IACT;EACF;AACA,SAAO;AACT;AAuBO,SAAS+B,gBAOdC,MAG0D;AAC1D,SAAOC,SAAS;IACd,GAAID;IACJE,QAASC,YACPH,6BAAME,UACFF,KAAKE,OAAOC,MAAMC,OAAwB,IAC1CD,MAAMC;EACd,CAAC;AACH;AAEaC,IAAAA,oBACX,OAAOC,WAAW,cAAoBD,wBAAwBE;AAEzD,SAASC,WAAWC,YAAoB;AAC7C,SAAOA,WACJC,QAAQ,OAAO,MAAM,EACrBA,QAAQ,MAAM,KAAK,EACnBA,QAAQ,MAAM,KAAK;AACxB;ACrVO,IAAMC,eAAqBC,oBAAkCC,MAAS;AAiCtE,SAASC,UAAU;AACxB,QAAMC,SAASC,UAAS;AACxB,QAAMC,UAAUC,eAAe;IAC7BhB,QAASiB,OAAM;;AACb,cAAOC,wBAAmBD,CAAC,EAAE,CAAC,MAAvBC,mBAA0BC;IACnC;EACF,CAAC;AAED,SACEzH,oBAAC+G,aAAaW,UAAQ;IAACC,OAAON;EAAQ,GACpCrH,oBAACJ,eAAa;IACZM,aAAaA,MAAAA;;AAAMiH,0BAAO5G,MAAMqH,iBAAiBrH,UAA9B4G,mBAAqC9D;;IACxDvD,gBAAgBC;IAChBI,SAASA,MAAM;AACb0H,+BACE,OACC,6EACH;IACF;EAAE,GAEDR,UAAUrH,oBAAC8H,OAAK;IAACT;EAAiB,CAAE,IAAI,IAC5B,CACM;AAE3B;AAEA,SAASU,aAAalI,OAAY;AAChC,SAAOG,oBAAAgI,gBAAGnI,MAAAA,MAAMO,QAAW;AAC7B;AAEO,SAAS0H,MAAM;EAAET;AAA6B,GAAG;;AACtD,QAAMF,SAASC,UAAS;AACxB,QAAMa,UAAUX,eAAe;IAC7BhB,QAASiB,OAAC;;AACRC,cAAAA,MAAAA,mBAAmBD,CAAC,EAAEW,KAAMhG,OAAMA,EAAEuF,OAAOJ,OAAO,MAAlDG,gBAAAA,IAAqDS;;EACzD,CAAC;AAEDE,YACEF,SACC,uCAAsCZ,OAAQ,0BACjD;AAEA,QAAMe,QAAQjB,OAAOkB,WAAWJ,OAAO;AAEvC,QAAMK,mBAAoBF,MAAMG,QAAQC,oBACtCrB,OAAOoB,QAAQE;AAEjB,QAAMC,iBAAiBJ,mBAAmBtI,oBAACsI,kBAAgB,IAAE,IAAI;AAEjE,QAAMK,sBACJP,MAAMG,QAAQzI,kBACdqH,OAAOoB,QAAQK,yBACf7I;AAEF,QAAM8I,2BACJT,MAAMG,QAAQO,kBACdR,sBACAF,WAAMG,QAAQQ,cAAdX,mBAAyBY,cACzBZ,WAAMG,QAAQC,qBAAdJ,mBAAgCY,cAC/BZ,WAAMG,QAAQzI,mBAAdsI,mBAAsCY,WAC7BC,iBACNlB;AAEN,QAAMmB,wBAAwBP,sBAC1B/I,gBACAmI;AAEJ,SACE/H,oBAAC+G,aAAaW,UAAQ;IAACC,OAAON;EAAQ,GACpCrH,oBAAC6I,0BAAwB;IAACM,UAAUT;EAAe,GACjD1I,oBAACkJ,uBAAqB;IACpBhJ,aAAaA,MAAAA;;AAAMiH,cAAAA,MAAAA,OAAO5G,MAAMqH,iBAAiBrH,UAA9B4G,gBAAAA,IAAqC9D;;IACxDvD,gBAAgB6I;IAChBxI,SAASA,MAAM;AACb0H,+BAAQ,OAAQ,yBAAwBR,OAAQ,EAAC;IACnD;EAAE,GAEFrH,oBAACoJ,YAAU;IAAC/B;IAAmBqB;GAAiC,CAC3C,CACC,CACL;AAE3B;AAEA,SAASU,WAAW;EAClB/B;EACAqB;AAIF,GAAQ;AACN,QAAMvB,SAASC,UAAS;AACxB,QAAMa,UAAUX,eAAe;IAC7BhB,QAASiB,OAAC;;AACRC,sCAAmBD,CAAC,EAAEW,KAAMhG,OAAMA,EAAEuF,OAAOJ,OAAO,MAAlDG,mBAAqDS;;EACzD,CAAC;AAED,QAAMG,QAAQjB,OAAOkB,WAAWJ,OAAO;AAEvC,QAAM1B,QAAQe,eAAe;IAC3BhB,QAASiB,OACPvE,KAAKwE,mBAAmBD,CAAC,EAAEW,KAAMhG,OAAMA,EAAEuF,OAAOJ,OAAO,GAAI,CACzD,UACA,SACA,eACA,aAAa,CACd;EACL,CAAC;AAED,MAAId,MAAM8C,WAAW,SAAS;AAC5B,UAAM9C,MAAMlG;EACd;AAEA,MAAIkG,MAAM8C,WAAW,WAAW;AAC9B,QAAI9C,MAAM+C,aAAa;AACrB,aAAOZ;IACT;AACA,UAAMnC,MAAMgD;EACd;AAEA,MAAIhD,MAAM8C,WAAW,WAAW;AAC9B,QAAIG,OAAOpB,MAAMG,QAAQQ,aAAa5B,OAAOoB,QAAQkB;AAErD,QAAID,MAAM;AACR,aAAOxJ,oBAACwJ,MAAI,IAAE;IAChB;AAEA,WAAOxJ,oBAAC0J,QAAM,IAAE;EAClB;AAEAvB,YACE,OACA,gGACF;AACF;AAEO,IAAMuB,SAAeC,WAAK,SAASD,UAAS;AACjD,QAAMrC,UAAgBuC,iBAAW7C,YAAY;AAE7C,QAAM8C,eAAevC,eAAe;IAClChB,QAASiB,OAAM;;AACb,YAAMuC,UAAUtC,mBAAmBD,CAAC;AACpC,YAAMjC,QAAQwE,QAAQC,UAAW7H,OAAMA,EAAEuF,OAAOJ,OAAO;AACvD,cAAOyC,aAAQxE,QAAQ,CAAC,MAAjBwE,mBAAoBrC;IAC7B;EACF,CAAC;AAED,MAAI,CAACoC,cAAc;AACjB,WAAO;EACT;AAEA,SAAO7J,oBAAC8H,OAAK;IAACT,SAASwC;EAAa,CAAE;AACxC,CAAC;AAiBM,SAASG,gBAEZ;AACF1C,iBAAe;IAAEhB,QAASiB,OAAM,CAACA,EAAE0C,UAAU1C,EAAEK,gBAAgB;EAAE,CAAC;AAClE,QAAM;IAAEsC;MAAe9C,UAAS;AAEhC,SAAa+C,kBAQT/D,UACmE;AACnE,UAAM;MAAEgE;MAASC;MAAe,GAAGC;IAAK,IAAIlE;AAE5C,WAAO8D,WAAWI,MAAa;MAC7BF;MACAC;IACF,CAAC;KAEH,CAAA,CACF;AACF;AAqBO,SAASE,WAOd1K,OACK;AACL,QAAMqK,aAAaF,cAAa;AAChC,QAAMQ,SAASN,WAAWrK,KAAY;AAEtC,MAAI,OAAOA,MAAMO,aAAa,YAAY;AACxC,WAAQP,MAAMO,SAAiBoK,MAAM;EACvC;AAEA,SAAO,CAAC,CAACA,SAAS3K,MAAMO,WAAW;AACrC;AAEA,SAASoH,mBAAmBjH,OAAoB;;AAC9C,WAAOA,WAAMkK,mBAANlK,mBAAsB6E,KAAMlD,OAAMA,EAAEoH,gBACvC/I,MAAMkK,iBACNlK,MAAMuJ;AACZ;AAEO,SAASzD,SAOdD,MAG0D;;AAC1D,QAAMe,SAASC,UAAS;AACxB,QAAMsD,iBAAuBd,iBAAW7C,YAAY;AAEpD,QAAM4D,uBAAsBnD,wBAAmBL,OAAO5G,KAAK,EAAE2H,KAC1DhG,OAAMA,EAAEuF,OAAOiD,cAClB,MAF4BlD,mBAEzBS;AAEH,QAAM2C,gBAAgB,MAAM;AAC1B,UAAMd,UAAUtC,mBAAmBL,OAAO5G,KAAK;AAC/C,UAAMgG,SAAQH,6BAAMyE,QAChBf,QAAQ5B,KAAMhG,OAAMA,EAAE+F,aAAY7B,6BAAMyE,KAAI,IAC5Cf,QAAQ5B,KAAMhG,OAAMA,EAAEuF,OAAOiD,cAAc;AAC/C,WAAOnE,MAAO0B;EAChB,GAAC;AAED,OAAI7B,6BAAM0E,WAAU,MAAM;AACxB3C,cACEwC,uBAAuBC,cACtB,aACCA,YACD,kEAAiED,mBAAoB,uCACpFC,YACD,wCACCA,YACD,cACH;EACF;AAEA,QAAMG,iBAAiBzD,eAAe;IACpChB,QAAS/F,WAAU;AACjB,YAAMgG,QAAQiB,mBAAmBjH,KAAK,EAAE2H,KACrChG,OAAMA,EAAEuF,OAAOiD,cAClB;AAEAvC,gBACE5B,OACC,mBACCH,6BAAMyE,QACD,yBAAwBzE,KAAKyE,IAAK,MACnC,kBACL,EACH;AAEA,cAAOzE,6BAAME,UAASF,KAAKE,OAAOC,KAAY,IAAIA;IACpD;EACF,CAAC;AAED,SAAOwE;AACT;AAEO,SAASC,WAA6B5E,MAEvC;AACJ,SAAOkB,eAAe;IACpBhB,QAAS/F,WAAU;AACjB,UAAIuJ,UAAUtC,mBAAmBjH,KAAK;AACtC,cAAO6F,6BAAME,UAASF,KAAKE,OAAOwD,OAAO,IAAKA;IAChD;EACF,CAAC;AACH;AAEO,SAASmB,iBAAmC7E,MAE7C;AACJ,QAAM8E,iBAAuBtB,iBAAW7C,YAAY;AAEpD,SAAOiE,WAAW;IAChB1E,QAASwD,aAAY;AACnBA,gBAAUA,QAAQqB,MAAMrB,QAAQC,UAAW7H,OAAMA,EAAEuF,OAAOyD,cAAc,CAAC;AACzE,cAAO9E,6BAAME,UAASF,KAAKE,OAAOwD,OAAO,IAAKA;IAChD;EACF,CAAC;AACH;AAEO,SAASsB,cAUdhF,MAG0D;AAC1D,SAAOC,SAAS;IACd,GAAGD;IACHE,QAASiB,OAAM;AACb,aAAO,OAAOnB,KAAKE,WAAW,aAC1BF,KAAKE,OAAOiB,uBAAG8D,UAAU,IACzB9D,uBAAG8D;IACT;EACF,CAAC;AACH;AAEO,SAASC,cAUdlF,MAG0D;AAC1D,SAAOC,SAAS;IACd,GAAGD;IACHE,QAASiB,OAAM;AACb,aAAO,OAAOnB,KAAKE,WAAW,aAC1BF,KAAKE,OAAOiB,uBAAGgE,UAAU,IACzBhE,uBAAGgE;IACT;EACF,CAAC;AACH;AC9WO,IAAIC,gBAAsBxE,oBAA2B,IAAK;AAEjE,IAAI,OAAOxE,aAAa,aAAa;AACnC,MAAIkE,OAAO+E,wBAAwB;AACjCD,oBAAgB9E,OAAO+E;EACzB,OAAO;AACL/E,WAAO+E,yBAAyBD;EAClC;AACF;AAEO,SAASE,eAGd;EAAEvE;EAAQ,GAAGmD;AAA2C,GAAG;AAE3DnD,SAAOwE,OAAO;IACZ,GAAGxE,OAAOoB;IACV,GAAG+B;IACH9D,SAAS;MACP,GAAGW,OAAOoB,QAAQ/B;MAClB,GAAG8D,6BAAM9D;IACX;EACF,CAAQ;AAER,QAAMsD,UAAU3C,OAAOoB,QAAQqD,YAC7B5L,oBAACmH,OAAOoB,QAAQqD,WAAS,MACvB5L,oBAACkH,SAAS,IAAA,CACc,IAE1BlH,oBAACkH,SAAO,IAAE;AAGZ,QAAM2E,WACJ7L,oBAACwL,cAAc9D,UAAQ;IAACC,OAAOR;KAC5B2C,SACD9J,oBAAC8L,cAAc,IAAA,CACO;AAG1B,MAAI3E,OAAOoB,QAAQwD,MAAM;AACvB,WAAO/L,oBAACmH,OAAOoB,QAAQwD,MAAMF,MAAAA,QAA8B;EAC7D;AAEA,SAAOA;AACT;AAEA,SAASC,eAAe;AACtB,QAAM3E,SAASC,UAAS;AACxB,QAAM4E,cAAc1E,eAAe;IACjChB,QAASiB,OACPvE,KAAKuE,GAAG,CAAC,aAAa,YAAY,oBAAoB,iBAAiB,CAAC;EAC5E,CAAC;AAED,QAAM,CAAC0E,iBAAiBC,oBAAoB,IAAUC,oBAAa;AAEnEhF,SAAO+E,uBAAuBA;AAE9BE,EAAMzF,gBAAU,MAAM;AACpB,QAAIsF,iBAAiB;AACnB9E,aAAOkF,QAAQvL,SAAUyG,QAAO;QAC9B,GAAGA;QACH0E;MACF,EAAE;IACJ;EACF,GAAG,CAACA,eAAe,CAAC;AAEpB,QAAMK,UAAUA,MAAM;AACpB,UAAMC,QAASC,QAAmB;AAChC,UAAI,CAACR,YAAYC,iBAAiB;AAChCC,6BAAqB,MAAMM,GAAE,CAAE;MACjC,OAAO;AACLA,WAAE;MACJ;;AAGFD,UAAM,MAAM;AACV,UAAI;AACFpF,eAAOsF,KAAI;eACJC,KAAK;AACZ1L,gBAAQX,MAAMqM,GAAG;MACnB;IACF,CAAC;;AAGHjG,oBAAgB,MAAM;AACpB,UAAMkG,QAAQxF,OAAOyF,QAAQC,UAAU,MAAM;AAC3C1F,aAAO2F,iBAAiB3F,OAAO4F,cAAc5F,OAAO2F,cAAc;AAClE,UAAId,YAAY/B,aAAa9C,OAAO2F,gBAAgB;AAClDR,gBAAO;MACT;IACF,CAAC;AAED,UAAMU,eAAe7F,OAAO8F,cAAc;MACxCC,QAAQ;MACR1C,QAAQ;MACR2C,MAAM;MACN5M,OAAO;IACT,CAAC;AAED,QAAIyL,YAAY/B,SAASmD,SAASJ,aAAaI,MAAM;AACnDjG,aAAOkG,eAAe;QAAE,GAAGL;QAAclG,SAAS;MAAK,CAAC;IAC1D;AAEA,WAAO,MAAM;AACX6F,YAAK;;EAET,GAAG,CAACxF,OAAOyF,OAAO,CAAC;AAEnBnG,oBAAgB,MAAM;;AACpB,QACEuF,YAAYC,mBACZ,CAACA,mBACD,CAACD,YAAYsB,aACbtB,YAAYpE,qBAAqBoE,YAAY/B,UAC7C;AACA9C,aAAOoG,KAAK;QACVC,MAAM;QACNC,cAAczB,YAAYpE;QAC1B8F,YAAY1B,YAAY/B;QACxB0D,aACE3B,YAAY/B,SAAUmD,WAASpB,iBAAYpE,qBAAZoE,mBAA8BoB;MACjE,CAAC;AAED,UAAK5K,SAAiBoL,eAAe;AACnC,YAAI5B,YAAY/B,SAASkD,SAAS,IAAI;AACpC,gBAAMU,KAAKrL,SAASsL,eAClB9B,YAAY/B,SAASkD,IACvB;AACA,cAAIU,IAAI;AACNA,eAAGE,eAAc;UACnB;QACF;MACF;AAEA5G,aAAOkF,QAAQvL,SAAUyG,QAAO;QAC9B,GAAGA;QACH0E,iBAAiB;QACjBrE,kBAAkBL,EAAE0C;MACtB,EAAE;IACJ;KACC,CACD+B,YAAYC,iBACZA,iBACAD,YAAYsB,WACZtB,YAAYpE,kBACZoE,YAAY/B,QAAQ,CACrB;AAEDxD,oBAAgB,MAAM;AACpB,QAAI,CAACC,OAAOsH,oBAAoB;AAC9B1B,cAAO;IACT;KACC,CAAA,CAAE;AAEL,SAAO;AACT;AAEO,SAAS2B,cACd1N,OACAkH,IACoC;AACpC,SAAO,CACL,GAAGlH,MAAM2N,eACT,GAAI3N,MAAMkK,kBAAkB,CAAA,GAC5B,GAAGlK,MAAMuJ,OAAO,EAChB5B,KAAMhG,OAAMA,EAAEuF,OAAOA,EAAE;AAC3B;AAEO,SAASH,eAEdlB,MAEY;AACZ,QAAMe,SAASC,UAAS;AACxB,SAAO+G,SAAShH,OAAOkF,SAASjG,6BAAME,MAAa;AACrD;AAUO,SAASc,YAEQ;AACtB,QAAMgH,kBACJ,OAAO5L,aAAa,cAChBkE,OAAO+E,0BAA0BD,gBACjCA;AACN,QAAM7D,QAAciC,iBAAWwE,eAAe;AAC9CvG,2BAAQF,OAAO,6DAA6D;AAC5E,SAAOA;AACT;ACtOO,SAAS0G,MAASC,UAAsB;AAC7C,QAAMC,UAAUD;AAEhB,MAAI,CAACC,QAAQC,iBAAiB;AAC5BD,YAAQC,kBAAkB;MACxBC,KAAKC,KAAKC,OAAM,EAAG/J,SAAS,EAAE,EAAEuG,MAAM,CAAC;MACvC9B,QAAQ;;AAGV,UAAM9I,QAAQgO,QAAQC;AAEtBD,YACGK,KAAMC,UAAS;AACdtO,YAAM8I,SAAS;AACf9I,YAAMsO,OAAOA;IACf,CAAC,EACAC,MAAOzO,WAAU;AAChBE,YAAM8I,SAAS;AACf9I,YAAMF,QAAQA;IAChB,CAAC;EACL;AAEA,SAAOkO;AACT;AAEO,SAASQ,qBAAqB3L,KAAmB;AACtD,SACE,OAAOA,QAAQ,YACfA,QAAQ,QACR,EAAEA,eAAe4L,YACjB,CAAC5L,IAAIwL,QACL,qBAAqBxL;AAEzB;AC/CO,SAAS6L,WAAc;EAAEV;AAAyB,GAAQ;AAC/D,QAAMpH,SAASC,UAAS;AAExB,MAAI7G,QAAQgO,QAAQC;AACpB,QAAMnL,MAAO,oBAAmB9C,MAAMkO,GAAI;AAE1C,MAAIM,qBAAqBR,OAAO,GAAG;AACjChO,YAAQ4G,OAAO+H,YAAY7L,GAAG;AAC9BkL,cAAUS,QAAQG,QAAQ5O,MAAMsO,IAAI;AACpCN,YAAQC,kBAAkBjO;EAC5B;AAEA,MAAIA,MAAM8I,WAAW,WAAW;AAC9B,UAAM,IAAI2F,QAASI,OAAMC,WAAWD,GAAG,CAAC,CAAC,EAAER,KAAK,MAAML,OAAO;EAC/D;AAEA,MAAIhO,MAAM8I,WAAW,SAAS;AAC5B,UAAM9I,MAAMF;EACd;AAEA8G,SAAOmI,cAAcjM,KAAK9C,KAAK;AAE/B,SAAO,CAACA,MAAMsO,IAAI;AACpB;AAEO,SAASU,MACd1P,OAGA;AACA,QAAM2P,UAAUP,WAAWpP,KAAK;AAChC,SAAOA,MAAMO,SAAS,GAAGoP,OAAO;AAClC;AC9BO,SAASC,UAAUC,OAA+B;AACvD,SAAOC,UAAUD,MAAME,OAAOC,OAAO,EAAEC,KAAK,GAAG,CAAC;AAClD;AAEO,SAASH,UAAUI,MAAc;AAEtC,SAAOA,KAAKjJ,QAAQ,WAAW,GAAG;AACpC;AAEO,SAASkJ,aAAaD,MAAc;AACzC,SAAOA,SAAS,MAAMA,OAAOA,KAAKjJ,QAAQ,WAAW,EAAE;AACzD;AAEO,SAASmJ,cAAcF,MAAc;AAC1C,SAAOA,SAAS,MAAMA,OAAOA,KAAKjJ,QAAQ,WAAW,EAAE;AACzD;AAEO,SAASoJ,SAASH,MAAc;AACrC,SAAOE,cAAcD,aAAaD,IAAI,CAAC;AACzC;AAEO,SAASI,YAAYC,UAAkBC,MAAcC,IAAY;AACtED,SAAOA,KAAKvJ,QAAQ,IAAIyJ,OAAQ,IAAGH,QAAS,EAAC,GAAG,GAAG;AACnDE,OAAKA,GAAGxJ,QAAQ,IAAIyJ,OAAQ,IAAGH,QAAS,EAAC,GAAG,GAAG;AAE/C,MAAII,eAAeC,cAAcJ,IAAI;AACrC,QAAMK,aAAaD,cAAcH,EAAE;AAEnCI,aAAWC,QAAQ,CAACC,WAAWtL,UAAU;;AACvC,QAAIsL,UAAUjJ,UAAU,KAAK;AAC3B,UAAI,CAACrC,OAAO;AAEVkL,uBAAe,CAACI,SAAS;iBAChBtL,UAAUoL,WAAW/N,SAAS,GAAG;AAE1C6N,qBAAaK,KAAKD,SAAS;MAC7B;AAAO;IAGT,WAAWA,UAAUjJ,UAAU,MAAM;AAEnC,UAAI6I,aAAa7N,SAAS,OAAKF,UAAK+N,YAAY,MAAjB/N,mBAAoBkF,WAAU,KAAK;AAChE6I,qBAAaM,IAAG;MAClB;AACAN,mBAAaM,IAAG;IAClB,WAAWF,UAAUjJ,UAAU,KAAK;AAClC;IACF,OAAO;AACL6I,mBAAaK,KAAKD,SAAS;IAC7B;EACF,CAAC;AAED,QAAMG,SAAStB,UAAU,CAACW,UAAU,GAAGI,aAAaQ,IAAK9O,OAAMA,EAAEyF,KAAK,CAAC,CAAC;AAExE,SAAOgI,UAAUoB,MAAM;AACzB;AAEO,SAASN,cAAcQ,UAA8B;AAC1D,MAAI,CAACA,UAAU;AACb,WAAO,CAAA;EACT;AAEAA,aAAWtB,UAAUsB,QAAQ;AAE7B,QAAMC,WAAsB,CAAA;AAE5B,MAAID,SAAS9F,MAAM,GAAG,CAAC,MAAM,KAAK;AAChC8F,eAAWA,SAASE,UAAU,CAAC;AAC/BD,aAASL,KAAK;MACZrD,MAAM;MACN7F,OAAO;IACT,CAAC;EACH;AAEA,MAAI,CAACsJ,UAAU;AACb,WAAOC;EACT;AAGA,QAAME,QAAQH,SAASG,MAAM,GAAG,EAAExB,OAAOC,OAAO;AAEhDqB,WAASL,KACP,GAAGO,MAAMJ,IAAKK,UAAkB;AAC9B,QAAIA,SAAS,OAAOA,SAAS,KAAK;AAChC,aAAO;QACL7D,MAAM;QACN7F,OAAO0J;;IAEX;AAEA,QAAIA,KAAKC,OAAO,CAAC,MAAM,KAAK;AAC1B,aAAO;QACL9D,MAAM;QACN7F,OAAO0J;;IAEX;AAEA,WAAO;MACL7D,MAAM;MACN7F,OAAO0J;;EAEX,CAAC,CACH;AAEA,MAAIJ,SAAS9F,MAAM,EAAE,MAAM,KAAK;AAC9B8F,eAAWA,SAASE,UAAU,CAAC;AAC/BD,aAASL,KAAK;MACZrD,MAAM;MACN7F,OAAO;IACT,CAAC;EACH;AAEA,SAAOuJ;AACT;AAEO,SAASK,gBACdxB,MACAvF,QACAgH,iBAA0B,OAC1B;AACA,QAAMC,2BAA2BhB,cAAcV,IAAI;AAEnD,SAAON,UACLgC,yBAAyBT,IAAKU,aAAY;AACxC,QAAIA,QAAQlE,SAAS,YAAY;AAC/B,YAAM7F,QAAQ6C,OAAOkH,QAAQ/J,KAAK;AAClC,UAAI6J;AAAgB,eAAQ,GAAEE,QAAQ/J,KAAM,GAAEA,SAAS,EAAG;AAC1D,aAAOA;IACT;AAEA,QAAI+J,QAAQlE,SAAS,SAAS;AAC5B,aAAOhD,OAAQkH,QAAQ/J,MAAMwJ,UAAU,CAAC,CAAC,KAAK;IAChD;AAEA,WAAOO,QAAQ/J;EACjB,CAAC,CACH;AACF;AAEO,SAASgK,cACdvB,UACAwB,iBACAC,eAC2B;AAC3B,QAAMC,aAAaC,YAAY3B,UAAUwB,iBAAiBC,aAAa;AAGvE,MAAIA,cAAcvB,MAAM,CAACwB,YAAY;AACnC;EACF;AAEA,SAAOA,cAAc,CAAA;AACvB;AAEO,SAASE,eAAe5B,UAAkBa,UAAkB;AACjE,SAAOb,YAAY,MAAMa,SAASE,UAAUf,SAASzN,MAAM,IAAIsO;AACjE;AAEO,SAASc,YACd3B,UACAvF,MACAgH,eACoC;AAEpChH,SAAOmH,eAAe5B,UAAUvF,IAAI;AAEpC,QAAMyF,KAAM,GAAEuB,cAAcvB,MAAM,GAAI;AAEtC,QAAME,eAAeC,cAAc5F,IAAI;AACvC,QAAMoH,gBAAgBxB,cAAcH,EAAE;AAEtC,MAAI,CAACzF,KAAKqH,WAAW,GAAG,GAAG;AACzB1B,iBAAa2B,QAAQ;MACnB3E,MAAM;MACN7F,OAAO;IACT,CAAC;EACH;AAEA,MAAI,CAAC2I,GAAG4B,WAAW,GAAG,GAAG;AACvBD,kBAAcE,QAAQ;MACpB3E,MAAM;MACN7F,OAAO;IACT,CAAC;EACH;AAEA,QAAM6C,SAAiC,CAAA;AAEvC,MAAI4H,WAAW,MAAM;AACnB,aACMhO,IAAI,GACRA,IAAIsK,KAAK2D,IAAI7B,aAAa7N,QAAQsP,cAActP,MAAM,GACtDyB,KACA;AACA,YAAMkO,cAAc9B,aAAapM,CAAC;AAClC,YAAMmO,eAAeN,cAAc7N,CAAC;AAEpC,YAAMoO,oBAAoBpO,KAAKoM,aAAa7N,SAAS;AACrD,YAAM8P,qBAAqBrO,KAAK6N,cAActP,SAAS;AAEvD,UAAI4P,cAAc;AAChB,YAAIA,aAAa/E,SAAS,YAAY;AACpC,cAAI8E,2CAAa3K,OAAO;AACtB6C,mBAAO,GAAG,IAAIiF,UAAUe,aAAarF,MAAM/G,CAAC,EAAE4M,IAAK9O,OAAMA,EAAEyF,KAAK,CAAC;AACjE,mBAAO;UACT;AACA,iBAAO;QACT;AAEA,YAAI4K,aAAa/E,SAAS,YAAY;AACpC,cAAI+E,aAAa5K,UAAU,OAAO,EAAC2K,2CAAa3K,QAAO;AACrD,mBAAO;UACT;AAEA,cAAI2K,aAAa;AACf,gBAAIT,cAAcxH,eAAe;AAC/B,kBAAIkI,aAAa5K,UAAU2K,YAAY3K,OAAO;AAC5C,uBAAO;cACT;YACF,WACE4K,aAAa5K,MAAM+K,YAAW,MAC9BJ,YAAY3K,MAAM+K,YAAW,GAC7B;AACA,qBAAO;YACT;UACF;QACF;AAEA,YAAI,CAACJ,aAAa;AAChB,iBAAO;QACT;AAEA,YAAIC,aAAa/E,SAAS,SAAS;AACjC,eAAI8E,2CAAa3K,WAAU,KAAK;AAC9B,mBAAO;UACT;AACA,cAAI2K,YAAY3K,MAAM2J,OAAO,CAAC,MAAM,KAAK;AACvC9G,mBAAO+H,aAAa5K,MAAMwJ,UAAU,CAAC,CAAC,IAAImB,YAAY3K;UACxD;QACF;MACF;AAEA,UAAI,CAAC6K,qBAAqBC,oBAAoB;AAC5CjI,eAAO,IAAI,IAAIiF,UAAUe,aAAarF,MAAM/G,IAAI,CAAC,EAAE4M,IAAK9O,OAAMA,EAAEyF,KAAK,CAAC;AACtE,eAAO,CAAC,CAACkK,cAAcc,UAASJ,6CAAc5K,WAAU;MAC1D;IACF;AAEA,WAAO;EACT,GAAC;AAED,SAAOyK,UAAW5H,SAAoCvD;AACxD;AC7PO,SAAS2L,UAOdxM,MAGW;AACX,SAAOkB,eAAe;IACpBhB,QAAS/F,WAAe;;AACtB,YAAMiK,UAAU/H,UAAKlC,MAAMuJ,OAAO,MAAlBrH,mBAA6B+H;AAC7C,cAAOpE,6BAAME,UAASF,KAAKE,OAAOkE,MAAM,IAAIA;IAC9C;EACF,CAAC;AACH;ACjBO,SAASqI,UAOdzM,MAG0D;AAC1D,SAAOC,SAAS;IACd,GAAID;IACJE,QAASC,WAAsB;AAC7B,cAAOH,6BAAME,UAASF,KAAKE,OAAOC,MAAM2G,MAAiB,IAAI3G,MAAM2G;IACrE;EACF,CAAC;AACH;ACHO,IAAM4F,cAAc;AAiUpB,IAAMC,WAAN,MAWL;EAGAvO,YAAY;IAAEiD;EAAgB,GAAG;AAIjCpB,oCAAqCD,UAEpB;AACf,aAAOC,SAAS;QAAE,GAAGD;QAAMyE,MAAM,KAAKpD;MAAG,CAAC;;AAG5CtB,2CAA4CC,UAE3B;AACf,aAAOC,SAAS;QACd,GAAGD;QACHyE,MAAM,KAAKpD;QACXnB,QAASpE,QAAYkE,6BAAME,UAASF,KAAKE,OAAOpE,EAAEsE,OAAO,IAAItE,EAAEsE;MACjE,CAAQ;;AAGVqM,qCAA4CzM,UAE3B;AACf,aAAOyM,UAAU;QAAE,GAAGzM;QAAMyE,MAAM,KAAKpD;MAAG,CAAQ;;AAGpDmL,qCAAqCxM,UAEpB;AACf,aAAOwM,UAAU;QAAE,GAAGxM;QAAMyE,MAAM,KAAKpD;MAAG,CAAQ;;AAGpD2D,yCAA0ChF,UAEzB;AACf,aAAOgF,cAAc;QAAE,GAAGhF;QAAMyE,MAAM,KAAKpD;MAAG,CAAQ;;AAGxD6D,yCAA0ClF,UAEzB;AACf,aAAOkF,cAAc;QAAE,GAAGlF;QAAMyE,MAAM,KAAKpD;MAAG,CAAQ;;AAxCtD,SAAKA,KAAKA;EACZ;AAyCF;AAEO,IAAMuL,QAAN,MAqCL;;;;EAkCAxO,YACE+D,SAaA;AA8BF0K,gCAAQ7M,UAAoC;;AAC1C,WAAK8M,gBAAgB9M,KAAK8M;AAE1B,YAAM3K,UAAU,KAAKA;AAerB,YAAM4K,SAAS,EAAC5K,mCAASwH,SAAQ,EAACxH,mCAASd;AAE3C,WAAK2L,eAAc,gBAAK7K,YAAL,mBAAc8K,mBAAd;AAEnB,UAAIF,QAAQ;AACV,aAAKpD,OAAO+C;MACd,OAAO;AACL3K,kBACE,KAAKiL,aACJ,6GACH;MACF;AAEA,UAAIrD,OAA2BoD,SAASL,cAAcvK,QAAQwH;AAG9D,UAAIA,QAAQA,SAAS,KAAK;AACxBA,eAAOG,SAASH,IAAI;MACtB;AAEA,YAAMuD,YAAW/K,mCAASd,OAAMsI;AAGhC,UAAItI,KAAK0L,SACLL,cACArD,UAAU,CACP,KAAK2D,YAAY3L,OAAeqL,cAC7B,KACA,KAAKM,YAAY3L,IACrB6L,QAAQ,CACT;AAEL,UAAIvD,SAAS+C,aAAa;AACxB/C,eAAO;MACT;AAEA,UAAItI,OAAOqL,aAAa;AACtBrL,aAAKgI,UAAU,CAAC,KAAKhI,EAAE,CAAC;MAC1B;AAEA,YAAM8L,WACJ9L,OAAOqL,cAAc,MAAMrD,UAAU,CAAC,KAAK2D,YAAYG,UAAUxD,IAAI,CAAC;AAExE,WAAKA,OAAOA;AACZ,WAAKtI,KAAKA;AAEV,WAAK8L,WAAWA;AAChB,WAAKjD,KAAKiD;;AAGZC,uCACEpT,cAkBG;AACH,WAAKA,WAAWA;AAChB,aAAO;;AAGTuL,kCAAUpD,aAAsD;AAC9DxE,aAAO0P,OAAO,KAAKlL,SAASA,OAAO;AACnC,aAAO;;AAGTlC,oCAAqCD,UAEpB;AACf,aAAOC,SAAS;QAAE,GAAGD;QAAMyE,MAAM,KAAKpD;MAAG,CAAC;;AAG5CtB,2CAA4CC,UAE3B;AACf,aAAOC,SAAS;QACd,GAAGD;QACHyE,MAAM,KAAKpD;QACXnB,QAASpE,QAAYkE,6BAAME,UAASF,KAAKE,OAAOpE,EAAEsE,OAAO,IAAItE,EAAEsE;MACjE,CAAQ;;AAGVqM,qCAA4CzM,UAE3B;AACf,aAAOyM,UAAU;QAAE,GAAGzM;QAAMyE,MAAM,KAAKpD;MAAG,CAAQ;;AAGpDmL,qCAAqCxM,UAEpB;AACf,aAAOwM,UAAU;QAAE,GAAGxM;QAAMyE,MAAM,KAAKpD;MAAG,CAAQ;;AAGpD2D,yCAA0ChF,UAEzB;AACf,aAAOgF,cAAc;QAAE,GAAGhF;QAAMyE,MAAM,KAAKpD;MAAG,CAAQ;;AAGxD6D,yCAA0ClF,UAEzB;AACf,aAAOkF,cAAc;QAAE,GAAGlF;QAAMyE,MAAM,KAAKpD;MAAG,CAAQ;;AAnKtD,SAAKc,UAAWA,WAAmB,CAAA;AACnC,SAAK4K,SAAS,EAAC5K,mCAAS8K;AACxBlL,cACE,GAAGI,mCAAiBd,QAAOc,mCAAiBwH,QAC3C,qDACH;AACE,SAAa2D,WAAWC,OAAOC,IAAI,YAAY;EACnD;AA8JF;AAIO,SAASC,uBAAkD;AAChE,SAMEtL,aAqB4D;AAC5D,WAAO,IAAIuL,UAAUvL,OAAO;;AAEhC;AAEO,IAAMuL,YAAN,cAMGd,MAiBR;EACAxO,YACE+D,SAqBA;AACA,UAAMA,OAAc;EACtB;AACF;AAkDO,SAASwL,gBAKd3N,MAGuB;AACvB,SAAOA;AACT;AAuBO,IAAM4N,gBAAN,cAmBGhB,MAiBR;EACAxO,YACE+D,SAgBA;AACA,UAAM;MACJ,GAAIA;MACJd,IAAI;IACN,CAAC;EACH;AACF;AC1yBO,IAAMwM,YAAN,MAYL;EACAzP,YAAmBuL,MAAiB;AAEpCmE,uCA0BE3L,aAkCG;AACH,YAAMH,QAAQ,IAAI4K,MAAMzK,OAAc;AACpCH,YAAc+K,SAAS;AACzB,aAAO/K;;AAjE2B,SAAjB2H,OAAAA;EAAkB;AAmEvC;ACpJO,SAASoE,mBAIdC,UACAC,YAGQ;AACR,MAAI9K;AAEJ,QAAMkD,OAAOA,MAAM;AACjB,QAAI,CAAClD,aAAa;AAChBA,oBAAc6K,SAAQ;IACxB;AAEA,WAAO7K;;AAGT,QAAM+K,WAAiBC,WAAK,YAAY;AACtC,UAAMC,gBAAgB,MAAM/H,KAAI;AAChC,UAAMgI,OAAOD,cAAcH,cAAc,SAAS;AAClD,WAAO;MACLK,SAASD;;EAEb,CAAC;AACCH,WAAiBtL,UAAUyD;AAE7B,SAAO6H;AACT;;;;;;;;;;;;;;;AC0TA,IAAMK,iBAAiB;AAEhB,SAASC,aAOdrM,SAC+C;AAC/C,QAAMpB,SAASC,UAAS;AACxB,QAAMuK,iBAAgBtL,SAAS;IAC7ByE,QAAQ;IACRxE,QAASiB,OAAMA,EAAE0J;EACnB,CAAC;AAED,QAAM;;IAEJ7Q;IACAyU;IACAC,cAAcA,OAAO;MAAEC,WAAW;IAAS;IAC3CC,gBAAgBA,OAAO,CAAA;IACvBC;IACAC;IACA/H;IACAD;IACA1C;IACA8F;IACA/P;IACA4U;IACAnM,SAASoM;IACTC,cAAcC;IACdxO;IACAyO;IACAC;;IAEAlU;IACAyT;IACA9S;IACAwT;IACAC;IACAC;IACAC;IACA,GAAGtL;EACL,IAAI/B;AAQJ,QAAMsN,OAAO;IACXhL,MAAMtC,QAAQ+H,KAAKqB,iBAAgB1K;IACnC,GAAGsB;;AAGL,MAAIiF,OAAgC;AAEpC,MAAI;AACF,QAAIsI,IAAK,GAAExF,EAAG,EAAC;AACf9C,WAAO;UACD;EAAA;AAER,MAAIA,SAAS,YAAY;AACvB,WAAO;MACLJ,MAAMkD;;EAEV;AAEA,QAAM7M,OAAO0D,OAAO8F,cAAc4I,IAAW;AAE7C,QAAM7M,UAAUoM,eAAejO,OAAOoB,QAAQwN;AAC9C,QAAMV,eACJC,oBAAoBnO,OAAOoB,QAAQyN,uBAAuB;AAE5D,QAAMC,WAAW3O,eAAe;IAC9BhB,QAASiB,OAAM;AAEb,YAAM2O,mBAAmB3O,EAAE0C,SAASgH,SAASG,MAAM,GAAG;AACtD,YAAM+E,gBAAgB1S,KAAKwN,SAASG,MAAM,GAAG;AAC7C,YAAMgF,mBAAmBD,cAAcE,MACrC,CAACnU,GAAGkC,MAAMlC,MAAMgU,iBAAiB9R,CAAC,CACpC;AAEA,YAAMkS,YAAWrB,+CAAesB,SAC5BhP,EAAE0C,SAASgH,aAAaxN,KAAKwN,WAC7BmF;AACJ,YAAMI,YAAWvB,+CAAewB,eAC5BlP,EAAE0C,SAASkD,SAAS1J,KAAK0J,OACzB;AACJ,YAAMuJ,cACJzB,+CAAe0B,kBAAiB,OAC5B7R,UAAUyC,EAAE0C,SAASiD,QAAQzJ,KAAKyJ,QAAQ,EAAC+H,+CAAesB,MAAK,IAC/D;AAGN,aAAOD,YAAYE,YAAYE;IACjC;EACF,CAAC;AAGD,QAAME,cAAeC,OAAkB;AACrC,QACE,CAAC3B,YACD,CAAC4B,YAAYD,CAAC,KACd,CAACA,EAAEE,qBACF,CAAClC,UAAUA,WAAW,YACvBgC,EAAEG,WAAW,GACb;AACAH,QAAEI,eAAc;AAGhB9P,aAAOkG,eAAe;QAAE,GAAG5J;QAAMqD;QAAS0O;QAAaD;MAAgB,CAAC;IAC1E;;AAIF,QAAM2B,cAAeL,OAAkB;AACrC,QAAI7N,SAAS;AACX7B,aAAOgQ,aAAatB,IAAW,EAAE/G,MAAOpC,SAAQ;AAC9C1L,gBAAQoW,KAAK1K,GAAG;AAChB1L,gBAAQoW,KAAKzC,cAAc;MAC7B,CAAC;IACH;;AAGF,QAAM0C,mBAAoBR,OAAkB;AAC1C,QAAI7N,SAAS;AACX7B,aAAOgQ,aAAatB,IAAW,EAAE/G,MAAOpC,SAAQ;AAC9C1L,gBAAQoW,KAAK1K,GAAG;AAChB1L,gBAAQoW,KAAKzC,cAAc;MAC7B,CAAC;IACH;;AAGF,QAAM2C,cAAeT,OAAkB;AACrC,UAAMhC,UAAUgC,EAAEhC,UAAU,CAAA;AAE5B,QAAI7L,SAAS;AACX,UAAI6L,QAAO0C,gBAAgB;AACzB;MACF;AAEA1C,MAAAA,QAAO0C,iBAAiBlI,WAAW,MAAM;AACvCwF,QAAAA,QAAO0C,iBAAiB;AACxBpQ,eAAOgQ,aAAatB,IAAW,EAAE/G,MAAOpC,SAAQ;AAC9C1L,kBAAQoW,KAAK1K,GAAG;AAChB1L,kBAAQoW,KAAKzC,cAAc;QAC7B,CAAC;SACAU,YAAY;IACjB;;AAGF,QAAMmC,cAAeX,OAAkB;AACrC,UAAMhC,UAAUgC,EAAEhC,UAAU,CAAA;AAE5B,QAAIA,QAAO0C,gBAAgB;AACzBE,mBAAa5C,QAAO0C,cAAc;AAClC1C,MAAAA,QAAO0C,iBAAiB;IAC1B;;AAGF,QAAMG,kBACHC,cACAd,OAA4B;AAC3B,QAAIA,EAAEe;AAASf,QAAEe,QAAO;AACxBD,aAAS/H,OAAOC,OAAO,EAAEc,QAASkH,aAAY;AAC5C,UAAIhB,EAAEE;AAAkB;AACxBc,cAAShB,CAAC;IACZ,CAAC;;AAIL,QAAMiB,sBAA+D7B,WACjEpT,iBAAiBiS,aAAoB,CAAA,CAAE,KAAK,CAAA,IAC5C,CAAA;AAGJ,QAAMiD,wBACJ9B,WAAW,CAAA,IAAKpT,iBAAiBmS,eAAe,CAAA,CAAE,KAAK,CAAA;AAEzD,SAAO;IACL,GAAG8C;IACH,GAAGC;IACH,GAAGzN;IACH8C,MAAM8H,WACFjO,SACAxD,KAAKuU,iBACHvU,KAAKuU,eAAe5K,OACpB3J,KAAK2J;IACXnL,SAASyV,gBAAgB,CAACzV,SAAS2U,WAAW,CAAC;IAC/CnB,SAASiC,gBAAgB,CAACjC,SAASyB,WAAW,CAAC;IAC/CxB,cAAcgC,gBAAgB,CAAChC,cAAc4B,WAAW,CAAC;IACzD3B,cAAc+B,gBAAgB,CAAC/B,cAAc6B,WAAW,CAAC;IACzD5B,cAAc8B,gBAAgB,CAAC9B,cAAcyB,gBAAgB,CAAC;IAC9DxC;IACAvT,OAAO;MACL,GAAGA;MACH,GAAGwW,oBAAoBxW;MACvB,GAAGyW,sBAAsBzW;;IAE3ByT,WACE,CACEA,WACA+C,oBAAoB/C,WACpBgD,sBAAsBhD,SAAS,EAE9BnF,OAAOC,OAAO,EACdC,KAAK,GAAG,KAAK7I;IAClB,GAAIiO,WACA;MACE+C,MAAM;MACN,iBAAiB;QAEnBhR;IACJ,CAAC,aAAa,GAAGgP,WAAW,WAAWhP;;AAE3C;AAgBO,IAAMiR,OAA4BC,iBAAW,CAACtY,OAAY+F,QAAQ;AACvE,QAAMwS,YAAYxD,aAAa/U,KAAK;AAEpC,SACEG,oBAAA,KAAAqY,SAAA;IAEIzS;EAAe,GACZwS,WAAS;IACZhY,UACE,OAAOP,MAAMO,aAAa,aACtBP,MAAMO,SAAS;MACb6V,UAAWmC,UAAkB,aAAa,MAAM;KACjD,IACDvY,MAAMO;EAAQ,CAAA,CAEvB;AAEL,CAAC;AAED,SAAS0W,YAAYD,GAAe;AAClC,SAAO,CAAC,EAAEA,EAAEyB,WAAWzB,EAAE0B,UAAU1B,EAAE2B,WAAW3B,EAAE4B;AACpD;ACtlBO,SAASC,OAAOtV,KAAKuV,KAAc;AACxC,MAAIC,GACFxU,GACAyU,KACAC,MAAM;AAER,OAAKF,KAAKxV,KAAK;AACb,SAAKyV,MAAMzV,IAAIwV,CAAC,OAAO,QAAQ;AAC7B,UAAIjV,MAAMC,QAAQiV,GAAG,GAAG;AACtB,aAAKzU,IAAI,GAAGA,IAAIyU,IAAIlW,QAAQyB,KAAK;AAC/B0U,kBAAQA,OAAO;AACfA,iBAAOC,mBAAmBH,CAAC,IAAI,MAAMG,mBAAmBF,IAAIzU,CAAC,CAAC;QAChE;MACF,OAAO;AACL0U,gBAAQA,OAAO;AACfA,eAAOC,mBAAmBH,CAAC,IAAI,MAAMG,mBAAmBF,GAAG;MAC7D;IACF;EACF;AAEA,UAAQF,OAAO,MAAMG;AACvB;AAEA,SAASE,QAAQC,KAAK;AACpB,MAAI,CAACA;AAAK,WAAO;AACjB,MAAIH,MAAMI,mBAAmBD,GAAG;AAChC,MAAIH,QAAQ;AAAS,WAAO;AAC5B,MAAIA,QAAQ;AAAQ,WAAO;AAC3B,SAAO,CAACA,MAAM,MAAM,KAAK,CAACA,MAAM,OAAOA,MAAM,CAACA,MAAMA;AACtD;AAEO,SAASK,OAAOL,KAAK;AAC1B,MAAID,KACFD,GACAQ,MAAM,CAAA,GACN1W,MAAMoW,IAAI1H,MAAM,GAAG;AAErB,SAAQyH,MAAMnW,IAAI2W,MAAK,GAAK;AAC1BR,UAAMA,IAAIzH,MAAM,GAAG;AACnBwH,QAAIC,IAAIQ,MAAK;AACb,QAAID,IAAIR,CAAC,MAAM,QAAQ;AACrBQ,UAAIR,CAAC,IAAI,CAAA,EAAGU,OAAOF,IAAIR,CAAC,GAAGI,QAAQH,IAAIQ,MAAK,CAAE,CAAC;IACjD,OAAO;AACLD,UAAIR,CAAC,IAAII,QAAQH,IAAIQ,MAAK,CAAE;IAC9B;EACF;AAEA,SAAOD;AACT;AChCO,SAASG,SAOdnT,MACsD;AACpDA,OAAaoT,aAAa;AAC5B,MAAIpT,KAAKqT,OAAO;AACd,UAAMrT;EACR;AACA,SAAOA;AACT;AAEO,SAASoT,WAAWpW,KAA8B;AACvD,SAAO,CAAC,EAACA,2BAAKoW;AAChB;ACnCO,IAAME,qBAAqBC,gBAAgBC,KAAKC,KAAK;AAC/CC,IAAAA,yBAAyBC,oBACpCH,KAAKI,WACLJ,KAAKC,KACP;AAEO,SAASF,gBAAgBM,QAA8B;AAC5D,SAAQC,eAAuC;AAC7C,QAAIA,UAAU/I,UAAU,GAAG,CAAC,MAAM,KAAK;AACrC+I,kBAAYA,UAAU/I,UAAU,CAAC;IACnC;AAEA,QAAIgJ,QAAiChB,OAAOe,SAAS;AAGrD,aAAS7W,OAAO8W,OAAO;AACrB,YAAMxS,QAAQwS,MAAM9W,GAAG;AACvB,UAAI,OAAOsE,UAAU,UAAU;AAC7B,YAAI;AACFwS,gBAAM9W,GAAG,IAAI4W,OAAOtS,KAAK;iBAClB+E,KAAK;QACZ;MAEJ;IACF;AAEA,WAAOyN;;AAEX;AAEO,SAASJ,oBACdC,WACAC,QACA;AACA,WAASG,eAAeC,KAAU;AAChC,QAAI,OAAOA,QAAQ,YAAYA,QAAQ,MAAM;AAC3C,UAAI;AACF,eAAOL,UAAUK,GAAG;eACb3N,KAAK;MACZ;eAEO,OAAO2N,QAAQ,YAAY,OAAOJ,WAAW,YAAY;AAClE,UAAI;AAGFA,eAAOI,GAAG;AACV,eAAOL,UAAUK,GAAG;eACb3N,KAAK;MACZ;IAEJ;AACA,WAAO2N;EACT;AAEA,SAAQnN,YAAgC;AACtCA,aAAS;MAAE,GAAGA;;AAEd,QAAIA,QAAQ;AACVnJ,aAAOb,KAAKgK,MAAM,EAAEyD,QAAStN,SAAQ;AACnC,cAAMgX,MAAMnN,OAAO7J,GAAG;AACtB,YAAI,OAAOgX,QAAQ,eAAeA,QAAQpT,QAAW;AACnD,iBAAOiG,OAAO7J,GAAG;QACnB,OAAO;AACL6J,iBAAO7J,GAAG,IAAI+W,eAAeC,GAAG;QAClC;MACF,CAAC;IACH;AAEA,UAAMH,YAAYxB,OAAOxL,MAAgC,EAAEtI,SAAQ;AAEnE,WAAOsV,YAAa,IAAGA,SAAU,KAAI;;AAEzC;ACyGO,IAAMI,iBAAiB,CAC5B,aACA,kBACA,kBAAkB;AA+Bb,IAAMC,SAAN,MAGL;;EA0BA/V,YAAY+D,SAA4D;AAxBxEiS;2CAAuC,GAAE9L,KAAK+L,MAC5C/L,KAAKC,OAAM,IAAK,GAClB,CAAE;AACF+L,2CAA2B;AAC3BC,2CAAkC;AAClCC,6CAAmC5L,QAAQG,QAAO;AAClD0L,uCAAc,oBAAIC,IAAG;AACrBC,wCAAoC,CAAA;AAgCpC7O;;;gDAAkD1G,QAAOA,GAAE;AAE3DmG,kCAAUqP,gBAAkE;AAC1E,WAAKzS,UAAU;QACb,GAAG,KAAKA;QACR,GAAGyS;;AAGL,WAAK5K,WAAY,IAAGF,SAAS8K,WAAW5K,YAAY,EAAE,KAAK,EAAG;AAE9D,UACE,CAAC,KAAKxD,WACL,KAAKrE,QAAQqE,WAAW,KAAKrE,QAAQqE,YAAY,KAAKA,SACvD;AACA,aAAKA,UACH,KAAKrE,QAAQqE,YACZ,OAAOpK,aAAa,cACjByY,qBAAoB,IACpBC,oBAAmB;AACzB,aAAKpO,iBAAiB,KAAKC,cAAa;MAC1C;AAEA,UAAI,KAAKxE,QAAQ4S,cAAc,KAAKA,WAAW;AAC7C,aAAKA,YAAY,KAAK5S,QAAQ4S;AAC9B,aAAKC,eAAc;MACrB;AAEA,UAAI,CAAC,KAAK/O,SAAS;AACjB,aAAKA,UAAU,IAAIgP,MAAMC,sBAAsB,KAAKxO,cAAc,GAAG;UACnEyO,UAAUA,MAAM;AACd,iBAAKlP,QAAQ9L,QAAQ;cACnB,GAAG,KAAKA;cACR8I,QACE,KAAK9I,MAAM0L,mBAAmB,KAAK1L,MAAM+M,YACrC,YACA;;UAEV;QACF,CAAC;MACH;;AAOF8N,0CAAiBA,MAAM;AACrB,WAAK/S,aAAa,CAAA;AAClB,WAAKmT,eAAe,CAAA;AAEpB,YAAMC,gBAAgB,KAAKlT,QAAQkT;AACnC,UAAIA,eAAe;AACjBA,sBAAcxI,KAAK;UAAEC,eAAe;QAAY,CAAC;AAC/C,aAAK7K,WAAmBoT,cAAchU,EAAE,IAAIgU;MAChD;AAEA,YAAMC,gBAAiBC,iBAA4B;AACjDA,oBAAYhL,QAAQ,CAACiL,YAAYxX,MAAM;AACrCwX,qBAAW3I,KAAK;YAAEC,eAAe9O;UAAE,CAAC;AAEpC,gBAAMyX,gBAAiB,KAAKxT,WAAmBuT,WAAWnU,EAAE;AAE5DU,oBACE,CAAC0T,eACA,mCAAkCC,OAAOF,WAAWnU,EAAE,CAAE,EAC3D;AACE,eAAKY,WAAmBuT,WAAWnU,EAAE,IAAImU;AAE3C,cAAI,CAACA,WAAWzI,UAAUyI,WAAW7L,MAAM;AACzC,kBAAMgM,kBAAkB9L,cAAc2L,WAAWrI,QAAQ;AACzD,gBACE,CAAE,KAAKiI,aAAqBO,eAAe,KAC3CH,WAAWrI,SAASyI,SAAS,GAAG,GAChC;AACE,mBAAKR,aAAqBO,eAAe,IAAIH;YACjD;UACF;AAEA,gBAAMxb,WAAWwb,WAAWxb;AAE5B,cAAIA,qCAAUuC,QAAQ;AACpB+Y,0BAActb,QAAQ;UACxB;QACF,CAAC;;AAGHsb,oBAAc,CAAC,KAAKP,SAAS,CAAC;AAE9B,YAAMc,eAMA,CAAA;AAEJlY,aAAOmY,OAAO,KAAK7T,UAAU,EAAiBsI,QAAQ,CAACzO,GAAGkC,MAAM;;AAChE,YAAIlC,EAAEiR,UAAU,CAACjR,EAAE6N,MAAM;AACvB;QACF;AAEA,cAAMoM,UAAUnM,aAAa9N,EAAEqR,QAAQ;AACvC,cAAM6I,SAAS3L,cAAc0L,OAAO;AAEpC,eAAOC,OAAOzZ,SAAS,OAAKyZ,YAAO,CAAC,MAARA,mBAAWzU,WAAU,KAAK;AACpDyU,iBAAO/C,MAAK;QACd;AAEA,cAAMgD,SAASD,OAAOpL,IAAK9O,CAAAA,OAAM;AAC/B,cAAIA,GAAEyF,UAAU,KAAK;AACnB,mBAAO;UACT;AAEA,cAAIzF,GAAEsL,SAAS,SAAS;AACtB,mBAAO;UACT;AAEA,cAAItL,GAAEsL,SAAS,YAAY;AACzB,mBAAO;UACT;AAEA,iBAAO;QACT,CAAC;AAEDyO,qBAAapL,KAAK;UAAEyL,OAAOpa;UAAGia;UAASC;UAAQ9W,OAAOlB;UAAGiY;QAAO,CAAC;MACnE,CAAC;AAED,WAAKE,aAAaN,aACfO,KAAK,CAACzX,GAAGC,MAAM;AACd,cAAMyX,YAAY/N,KAAKgO,IAAI3X,EAAEsX,OAAO1Z,QAAQqC,EAAEqX,OAAO1Z,MAAM;AAG3D,iBAASyB,IAAI,GAAGA,IAAIqY,WAAWrY,KAAK;AAClC,cAAIW,EAAEsX,OAAOjY,CAAC,MAAMY,EAAEqX,OAAOjY,CAAC,GAAG;AAC/B,mBAAOY,EAAEqX,OAAOjY,CAAC,IAAKW,EAAEsX,OAAOjY,CAAC;UAClC;QACF;AAGA,YAAIW,EAAEsX,OAAO1Z,WAAWqC,EAAEqX,OAAO1Z,QAAQ;AACvC,iBAAOqC,EAAEqX,OAAO1Z,SAASoC,EAAEsX,OAAO1Z;QACpC;AAGA,iBAASyB,IAAI,GAAGA,IAAIqY,WAAWrY,KAAK;AAClC,cAAIW,EAAEqX,OAAOhY,CAAC,EAAGuD,UAAU3C,EAAEoX,OAAOhY,CAAC,EAAGuD,OAAO;AAC7C,mBAAO5C,EAAEqX,OAAOhY,CAAC,EAAGuD,QAAS3C,EAAEoX,OAAOhY,CAAC,EAAGuD,QAAS,IAAI;UACzD;QACF;AAGA,eAAO5C,EAAEO,QAAQN,EAAEM;OACpB,EACA0L,IAAI,CAAC9O,GAAGkC,MAAM;AACblC,UAAEoa,MAAMK,OAAOvY;AACf,eAAOlC,EAAEoa;MACX,CAAC;;AAGLzP,qCAAYA,CACV+P,WACApX,OACG;AACH,YAAMqX,WAAgC;QACpCD;QACApX;;AAGF,WAAKqV,YAAYiC,IAAID,QAAQ;AAE7B,aAAO,MAAM;AACX,aAAKhC,YAAYkC,OAAOF,QAAQ;;;AAIpCtP,gCAAQyP,iBAA6B;AACnC,WAAKnC,YAAYlK,QAASkM,cAAa;AACrC,YAAIA,SAASD,cAAcI,YAAYxP,MAAM;AAC3CqP,mBAASrX,GAAGwX,WAAW;QACzB;MACF,CAAC;;AAGHC,uCAAe1O,aAAsD;AACnE,aAAO,KAAKqM,sBAAsBrM,UAC9B,KAAKqM,oBACL3T;;AAGN8F,yCACEmQ,sBACiD;AACjD,YAAMrD,QAAQA,CAAC;QACb5I;QACA/D;QACAC;QACA5M;MACe,MAAoD;AACnE,cAAM4c,eAAe,KAAK5U,QAAQ6U,YAAYlQ,MAAM;AAEpD,eAAO;UACL+D;UACAiJ,WAAWhN;UACXA,QAAQ5J,iBAAiB4Z,qDAAkBhQ,QAAQiQ,YAAY;UAC/DhQ,MAAMA,KAAKiE,MAAM,GAAG,EAAEiM,QAAO,EAAG,CAAC,KAAK;UACtCjQ,MAAO,GAAE6D,QAAS,GAAE/D,MAAO,GAAEC,IAAK;UAClC5M,OAAO+C,iBAAiB4Z,qDAAkB3c,OAAOA,KAAK;;;AAI1D,YAAM0J,WAAW4P,MAAM,KAAKjN,QAAQ3C,QAAQ;AAE5C,UAAI;QAAEqT;QAAgBC;UAActT,SAAS1J;AAE7C,UAAI+c,mBAAmB,CAACC,aAAaA,cAAc,KAAK/C,kBAAkB;AAExE,cAAMgD,qBAAqB3D,MAAMyD,cAAc;AAC/CE,2BAAmBjd,MAAM8C,MAAM4G,SAAS1J,MAAM8C;AAE9C,eAAOma,mBAAmBjd,MAAM+c;AAEhC,eAAO;UACL,GAAGE;UACHxF,gBAAgB/N;;MAEpB;AAEA,aAAOA;;AAGTwT,+CAAsBA,CAAC5S,MAAckF,SAAiB;AACpD,aAAOI,YAAY,KAAKC,UAAWvF,MAAM8E,UAAUI,IAAI,CAAC;;AAO1D2N,uCAAcA,CACZzM,UACA0M,gBACAvX,SAC6B;AAC7B,UAAIwX,cAAsC,CAAA;AAE1C,UAAIC,aAAa,KAAKtB,WAAWrU,KAAME,WAAU;AAC/C,cAAM0V,gBAAgBnM,cACpB,KAAKvB,UACLH,cAAcgB,QAAQ,GACtB;UACEX,IAAIlI,MAAMmL;UACVlJ,eACEjC,MAAMG,QAAQ8B,iBAAiB,KAAK9B,QAAQ8B;UAC9CsI,OAAO;QACT,CACF;AAEA,YAAImL,eAAe;AACjBF,wBAAcE;AACd,iBAAO;QACT;AAEA,eAAO;MACT,CAAC;AAED,UAAIC,cACFF,cAAe,KAAKxV,WAAmB,UAAU;AAEnD,UAAI2V,gBAA4B,CAACD,WAAW;AAG5C;;SAEGF,aACGA,WAAW9N,SAAS,OAAO6N,YAAY,IAAI;;UAE3C3N,cAAcgB,QAAQ;;QAE1B,KAAK1I,QAAQkT;QACb;AACAuC,sBAAcnN,KAAK,KAAKtI,QAAQkT,aAAa;MAC/C;AAEA,aAAOsC,2CAAa3K,aAAa;AAC/B2K,sBAAcA,YAAY3K;AAC1B,YAAI2K;AAAaC,wBAAc7L,QAAQ4L,WAAW;MACpD;AAKA,YAAME,cAAcD,cAAchN,IAAK5I,WAAU;AAC/C,YAAI8V;AAEJ,YAAI9V,MAAMG,QAAQ4V,aAAa;AAC7B,cAAI;AACF,kBAAMC,eAAehW,MAAMG,QAAQ4V,YAAYP,WAAW;AAE1D7Z,mBAAO0P,OAAOmK,aAAaQ,YAAY;mBAChC1R,KAAU;AACjBwR,gCAAoB,IAAIG,eAAe3R,IAAIpK,SAAS;cAClDgc,OAAO5R;YACT,CAAC;AAED,gBAAItG,6BAAMmY,cAAc;AACtB,oBAAML;YACR;AAEA,mBAAOA;UACT;QACF;AAEA;MACF,CAAC;AAED,YAAMpU,UAA2B,CAAA;AAEjCkU,oBAAcrN,QAAQ,CAACvI,OAAO9C,UAAU;;AAQtC,cAAMkZ,cAAc1U,QAAQxE,QAAQ,CAAC;AAErC,cAAM,CAACmZ,gBAAgBC,WAAW,KAAiC,MAAM;AAEvE,gBAAMC,gBAAeH,2CAAatR,WAAUyQ;AAE5C,cAAI;AACF,kBAAMiB,YACJ,OAAOxW,MAAMG,QAAQsW,mBAAmB,WACpCzW,MAAMG,QAAQsW,eAAehF,QAC7BzR,MAAMG,QAAQsW;AAEpB,gBAAI3R,UAAS0R,uCAAYD,kBAAiB,CAAA;AAE1C,mBAAO,CACL;cACE,GAAGA;cACH,GAAGzR;eAELjG,MAAS;mBAEJyF,KAAU;AACjB,kBAAMgS,eAAc,IAAII,iBAAiBpS,IAAIpK,SAAS;cACpDgc,OAAO5R;YACT,CAAC;AAED,gBAAItG,6BAAMmY,cAAc;AACtB,oBAAMG;YACR;AAEA,mBAAO,CAACC,cAAcD,YAAW;UACnC;QACF,GAAC;AAOD,cAAMrT,eACJjD,iBAAMG,SAAQ8C,eAAdjD,4BAA2B;UACzB8E,QAAQuR;eACJ;AAER,cAAMM,iBAAiB1T,aAAauO,KAAKI,UAAU3O,UAAU,IAAI;AAEjE,cAAM2T,mBAAmBzN,gBAAgBnJ,MAAMmL,UAAUqK,WAAW;AACpE,cAAMvW,UACJkK,gBAAgBnJ,MAAMX,IAAImW,aAAa,IAAI,IAAImB;AAKjD,cAAME,gBAAgBhR,cAAc,KAAK1N,OAAO8G,OAAO;AAEvD,cAAMiX,QAAQ,KAAK/d,MAAMuJ,QAAQ5B,KAAMhG,OAAMA,EAAEuF,OAAOJ,OAAO,IACzD,SACA;AAGJ,cAAM6X,aAAa,CAAC,EAClB9W,MAAMG,QAAQ4W,UACd7E,eAAelV,KAAMlD,OAAC;;AAAMkG,kBAAAA,MAAAA,MAAMG,QAAQrG,CAAC,MAAfkG,gBAAAA,IAA0BY;SAAO;AAG/D,cAAMzC,QAAuB0Y,gBACzB;UAAE,GAAGA;UAAeX;QAAM,IAC1B;UACE7W,IAAIJ;UACJY,SAASG,MAAMX;UACf+C,QAAQoT;UACR3M,UAAUxB,UAAU,CAAC,KAAKW,UAAU4O,gBAAgB,CAAC;UACrDI,WAAWC,KAAKC,IAAG;UACnBpS,QAAQ,CAAA;UACRwR,aAAazX;UACboC,QAAQ6V,aAAa,YAAY;UACjC5V,aAAa;UACbiW,YAAY;UACZlf,OAAO4G;UACPuY,aAAavB,YAAY3Y,KAAK;UAC9BiE,aAAayF,QAAQG,QAAO;UAC5BsQ,cAAcxY;UACdT,SAASS;UACTyY,iBAAiB,IAAIC,gBAAe;UACpCC,YAAY;UACZtB;UACAjT;UACAwU,SAAS;UACT7W,SAAS;;AAKfzC,cAAM2G,SAAS5J,iBAAiBiD,MAAM2G,QAAQuR,cAAc;AAE5DlY,cAAMmY,cAAcA;AAEpB5U,gBAAQ+G,KAAKtK,KAAK;MACpB,CAAC;AAED,aAAOuD;;AAGTgW,uCAAerY,QAAe;;AAC5BwG,gCAAc,KAAK1N,OAAOkH,EAAE,MAA5BwG,mBAA+ByR,oBAA/BzR,mBAAgD8R;;AAGlDC,yCAAgBA,MAAM;;AACpB,iBAAKzf,MAAMkK,mBAAX,mBAA2BkG,QAASpK,WAAU;AAC5C,aAAKuZ,YAAYvZ,MAAMkB,EAAE;MAC3B;;AAGFwF,yCAA8C7G,UAAS;AACrD,YAAM6Z,QAAQA,CACZpK,OAEI,CAAA,GACJ/L,YACmB;;AACnB,cAAMe,OAAO,KAAKiC;AAClB,cAAMoT,eACH,WAAK3f,MAAMkK,kBAAkB,KAAKlK,MAAMuJ,SAASqW,GAAG,EAAE,MAAtD,mBAAyDjT,WAC1DrC,KAAKqC;AACP,cAAMkT,eAAevK,KAAKhL,QAAQA,KAAKoG;AAEvC,YAAIA,WAAW,KAAKwM,oBAAoB2C,cAAe,GAAEvK,KAAKvF,MAAM,EAAG,EAAC;AAExE,cAAM+P,cAAc,KAAK3C,YAAY0C,cAAcF,UAAU;AAC7D,cAAMI,iBAAiBxW,mCAAS8F,OAC7B1N,OAAMme,2CAAanY,KAAM2O,OAAMA,EAAE5O,YAAY/F,EAAE+F;AAGlD,cAAMsY,aAAa;UAAE,IAAG9d,UAAK4d,WAAW,MAAhB5d,mBAAmB+H;;AAE3C,YAAIgW,cACD3K,KAAKrL,UAAU,UAAU,OACtB+V,aACA1d,iBAAiBgT,KAAKrL,QAAS+V,UAAU;AAE/C,YAAIC,YAAY;AACd1W,6CACIkH,IAAK9O,OAAM,KAAKue,gBAAgBve,EAAE+F,OAAO,EAAGM,QAAQmY,iBACrD9Q,OAAOC,SACPc,QAASnL,QAAO;AACfgb,yBAAa;cAAE,GAAGA;cAAa,GAAGhb,GAAIgb,UAAW;;UACnD;QACJ;AAEAvP,mBAAWM,gBAAgBN,UAAUuP,cAAc,CAAA,CAAE;AAErD,cAAMG,oBACJL,iDACItP,IACCzK,WACC,KAAKka,gBAAgBla,MAAM0B,OAAO,EAAGM,QAAQoY,oBAC7C,CAAA,GAEHC,OACAhR,OAAOC,aAAY,CAAA;AAExB,cAAMgR,qBACJP,iDACItP,IACCzK,WACC,KAAKka,gBAAgBla,MAAM0B,OAAO,EAAGM,QAAQsY,qBAC7C,CAAA,GAEHD,OACAhR,OAAOC,aAAY,CAAA;AAGxB,cAAMiR,qBAAoBH,qDAAkBhe,UACxCge,qDAAkBxd,OAChB,CAACI,MAAME,SAASA,KAAKF,IAAI,GACzB2c,cAEFA;AAGJ,cAAMa,aACJlL,KAAK3I,WAAW,OACZ4T,oBACAjL,KAAK3I,SACHrK,iBAAiBgT,KAAK3I,QAAQ4T,iBAAiB,KAAK,CAAA,KACpDH,qDAAkBhe,UAChBme,oBACA,CAAA;AAGV,cAAME,sBAAqBH,uDAAmBle,UAC1Cke,kBAAkB1d,OAAO,CAACI,MAAME,SAASA,KAAKF,IAAI,GAAGwd,UAAU,IAC/DA;AAEJ,cAAM7T,SAAS5J,iBAAiB4c,YAAYc,kBAAkB;AAE9D,cAAM9G,YAAY,KAAK3R,QAAQ0Y,gBAAgB/T,MAAM;AAErD,cAAMC,OACJ0I,KAAK1I,SAAS,OACVtC,KAAKsC,OACL0I,KAAK1I,OACHtK,iBAAiBgT,KAAK1I,MAAOtC,KAAKsC,IAAI,IACtCtC,KAAKsC;AAEb,cAAM+T,UAAU/T,OAAQ,IAAGA,IAAK,KAAI;AAEpC,YAAIgU,YACFtL,KAAKtV,UAAU,OACXsK,KAAKtK,QACLsV,KAAKtV,QACHsC,iBAAiBgT,KAAKtV,OAAOsK,KAAKtK,KAAK,IACvCsK,KAAKtK;AAEb4gB,oBAAY7d,iBAAiBuH,KAAKtK,OAAO4gB,SAAS;AAElD,eAAO;UACLlQ;UACA/D;UACAgN;UACA3Z,OAAO4gB;UACPhU;UACAC,MAAO,GAAE6D,QAAS,GAAEiJ,SAAU,GAAEgH,OAAQ;UACxCE,gBAAgBvL,KAAKuL;;;AAIzB,YAAMC,mBAAmBA,CACvBxL,OAAyB,CAAA,GACzByL,eACG;;AACH,YAAI7d,OAAOwc,MAAMpK,IAAI;AACrB,YAAI0L,aAAaD,aAAarB,MAAMqB,UAAU,IAAIra;AAElD,YAAI,CAACsa,YAAY;AACf,cAAI/W,SAAS,CAAA;AAEb,cAAIgX,aAAY,UAAKjZ,QAAQkZ,eAAb,mBAAyBvZ,KAAMhG,OAAM;AACnD,kBAAMqE,QAAQoL,cAAc,KAAKvB,UAAU3M,KAAKwN,UAAU;cACxDX,IAAIpO,EAAE2I;cACNR,eAAe;cACfsI,OAAO;YACT,CAAC;AAED,gBAAIpM,OAAO;AACTiE,uBAASjE;AACT,qBAAO;YACT;AAEA,mBAAO;UACT;AAEA,cAAIib,WAAW;AACbA,wBAAY;cACV,GAAGA;cACH3W,MAAM0G,gBAAgBiQ,UAAU3W,MAAML,MAAM;;AAE9C8W,yBAAaE;AACbD,yBAAatB,MAAMqB,UAAU;UAC/B;QACF;AAEA,cAAMI,cAAc,KAAKhE,YAAYja,KAAKwN,UAAUxN,KAAKyJ,MAAM;AAC/D,cAAMyU,gBAAgBJ,aAClB,KAAK7D,YAAY6D,WAAWtQ,UAAUsQ,WAAWrU,MAAM,IACvDjG;AACJ,cAAM2a,cAAcL,aAChBtB,MAAMqB,YAAYK,aAAa,IAC/B1a;AAEJ,cAAM4a,QAAQ5B,MAAMpK,MAAM6L,WAAW;AAErC,YAAIE,aAAa;AACfC,gBAAM7J,iBAAiB4J;QACzB;AAEA,eAAOC;;AAGT,UAAIzb,KAAK+O,MAAM;AACb,eAAOkM,iBAAiBjb,MAAM;UAC5B,GAAGpD,KAAKoD,MAAM,CAAC,MAAM,CAAC;UACtB,GAAGA,KAAK+O;QACV,CAAC;MACH;AAEA,aAAOkM,iBAAiBjb,IAAI;;AAG9BiH,0CAAiB,OAAO;MACtBkI;MACA,GAAG9R;IACmC,MAAM;AAC5C,UAAI,KAAKkX;AAAiBlD,qBAAa,KAAKkD,eAAe;AAE3D,YAAMmH,YAAY,KAAKhV,eAAeM,SAAS3J,KAAK2J;AAIpD,UAAI,CAAC0U,aAAa,CAACre,KAAKqD,SAAS;AAC/B,YAAI;UAAEkR;UAAgB,GAAG+J;QAAY,IAAIte;AAEzC,YAAIuU,gBAAgB;AAClB+J,wBAAc;YACZ,GAAG/J;YACHzX,OAAO;cACL,GAAGyX,eAAezX;cAClBgd,WAAWtW;cACXqW,gBAAgB;gBACd,GAAGyE;gBACH7U,QAAQ6U,YAAY7H;gBACpB3Z,OAAO;kBACL,GAAGwhB,YAAYxhB;kBACfgd,WAAWtW;kBACXqW,gBAAgBrW;kBAChB5D,KAAK4D;gBACP;cACF;YACF;;AAGF,cACE8a,YAAYX,kBACZ,KAAK7Y,QAAQ6Y,kBACb,OACA;AACAW,wBAAYxhB,MAAMgd,YAAY,KAAK/C;UACrC;QACF;AAEA,cAAMjO,QAAQA,MAAM;AAClB,eAAKK,QAAQnJ,KAAKqD,UAAU,YAAY,MAAM,EAC5Cib,YAAY3U,MACZ2U,YAAYxhB,KACd;;AAGF,YAAIgV,mBAAmB,MAAM;AAC3B,eAAKrJ,qBAAqBK,KAAK;QACjC,OAAO;AACLA,gBAAK;QACP;MACF;AAEA,WAAKmO,kBAAkBjX,KAAK+R,eAAe;AAE3C,aAAO,KAAKoF;;AAGdoH,kDAAyBA,CAAC;MACxBlb;MACA0O;MACAD;MACA,GAAGjL;QACyC,CAAA,MAAO;AACnD,YAAML,WAAW,KAAKgD,cAAc3C,IAAW;AAC/C,aAAO,KAAK+C,eAAe;QACzB,GAAGpD;QACHsL;QACAzO;QACA0O;MACF,CAAC;;AAGHyM,oCAAmCA,CAAC;MAAEpX;MAAMyF,KAAK;MAAI,GAAGhG;IAAK,MAAM;AAMjE,YAAM1F,WAAWkX,OAAOxL,EAAE;AAC1B,YAAM4R,aAAa,OAAOrX,SAAS,cAAcA,OAAOiR,OAAOjR,IAAI;AACnE,UAAIsX;AAEJ,UAAI;AACF,YAAIrM,IAAK,GAAElR,QAAS,EAAC;AACrBud,qBAAa;MACf,SAAStL,GAAG;MAAA;AAEZ1O,gBACE,CAACga,YACD,4DACF;AAEA,aAAO,KAAKH,uBAAuB;QACjC,GAAG1X;QACHO,MAAMqX;QACN5R,IAAI1L;MACN,CAAC;;AAGHwd,uCAAc,OAAO;MACnBnF;MACAnT;MACAd;IAKF,MAA6B;;AAC3B,UAAIqZ;AACJ,UAAIC;AAEJ,YAAMC,cAAehc,WAAyB;;AAE5C,cAAMic,aAAYC,MAAA,KAAKliB,MAAMkK,mBAAX,gBAAAgY,IAA2Bva,KAC1ChG,OAAMA,EAAEuF,OAAOlB,MAAMkB;AAGxB,cAAMib,YAAY,KAAKniB,MAAMuJ,QAAQ5B,KAAMhG,OAAMA,EAAEuF,OAAOlB,MAAMkB,EAAE;AAElE,cAAMkb,aAAaH,YACf,mBACAE,YACE,YACA;AAEN,aAAKrW,QAAQvL,SAAUyG,OAAC;;AAAM;YAC5B,GAAGA;YACH,CAACob,UAAU,IAAGpb,MAAAA,EAAEob,UAAU,MAAZpb,gBAAAA,IAAeyJ,IAAK9O,OAChCA,EAAEuF,OAAOlB,MAAMkB,KAAKlB,QAAQrE;UAEhC;SAAE;;AAIJ,UAAI;AACF,iBAAS,CAACoD,OAAOiB,KAAK,KAAKuD,QAAQ8Y,QAAO,GAAI;AAC5C,gBAAMpE,cAAc1U,QAAQxE,QAAQ,CAAC;AACrC,gBAAM8C,QAAQ,KAAKqY,gBAAgBla,MAAM0B,OAAO;AAChD,gBAAMyX,kBAAkB,IAAIC,gBAAe;AAE3C,gBAAMkD,yBAAyBA,CAACnW,KAAUoW,SAAiB;;AACzDpW,gBAAIqW,aAAaD;AACjBR,iCAAqBA,sBAAsBhd;AAE3C,gBAAIkU,WAAW9M,GAAG,GAAG;AACnB,oBAAMA;YACR;AAEA,gBAAI;AACFtE,eAAAA,OAAAA,MAAAA,MAAMG,SAAQya,YAAd5a,gBAAAA,IAAAA,KAAAA,KAAwBsE;qBACjBuW,iBAAiB;AACxBvW,oBAAMuW;AAEN,kBAAIzJ,WAAWyJ,eAAe,GAAG;AAC/B,sBAAMA;cACR;YACF;AAEAnZ,oBAAQxE,KAAK,IAAIiB,QAAQ;cACvB,GAAGA;cACHlG,OAAOqM;cACPrD,QAAQ;cACR+V,WAAWC,KAAKC,IAAG;cACnBI,iBAAiB,IAAIC,gBAAe;;;AAIxC,cAAI;AACF,gBAAIpZ,MAAMiZ,aAAa;AACrBqD,qCAAuBtc,MAAMiZ,aAAa,cAAc;YAC1D;AAEA,gBAAIjZ,MAAMmY,aAAa;AACrBmE,qCAAuBtc,MAAMmY,aAAa,iBAAiB;YAC7D;AAEA,kBAAMwE,iBACJ1E,2CAAahY,YAAW,KAAK+B,QAAQ/B,WAAW,CAAA;AAElD,kBAAM2c,oBACH,QAAM/a,iBAAMG,SAAQ6a,eAAdhb,4BAA2B;cAChC8E,QAAQ3G,MAAM2G;cACdwS;cACAlV,QAAQjE,MAAMiE;cACdxB,SAAS,CAAC,CAACA;cACXxC,SAAS0c;cACTjZ,UAAU,KAAK1J,MAAM0J;;cAErBgY,UAAW7b,UACT,KAAK6b,SAAS;gBAAE,GAAG7b;gBAAMyE,MAAMtE,MAAM0K;cAAS,CAAQ;cACxDhE,eAAe,KAAKA;cACpBqR,OAAOtV,UAAU,YAAYzC,MAAM+X;mBAC7B,CAAA;AAEV,gBAAI9E,WAAW2J,iBAAiB,GAAG;AACjC,oBAAMA;YACR;AAEA,kBAAM3c,UAAU;cACd,GAAG0c;cACH,GAAGC;;AAGLrZ,oBAAQxE,KAAK,IAAIiB,QAAQ;cACvB,GAAGA;cACHkZ,cAAcnc,iBACZiD,MAAMkZ,cACN0D,iBACF;cACA3c,SAASlD,iBAAiBiD,MAAMC,SAASA,OAAO;cAChDkZ;;mBAEKhT,KAAK;AACZmW,mCAAuBnW,KAAK,aAAa;AACzC;UACF;QACF;eACOA,KAAK;AACZ,YAAI8M,WAAW9M,GAAG,GAAG;AACnB,cAAI,CAAC1D;AAAS,iBAAKiZ,SAASvV,GAAU;AACtC,iBAAO5C;QACT;AAEA,cAAM4C;MACR;AAEA,YAAM2W,uBAAuBvZ,QAAQqB,MAAM,GAAGmX,kBAAkB;AAChE,YAAMgB,gBAAgC,CAAA;AAEtCD,2BAAqB1S,QAAQ,CAACpK,OAAOjB,UAAU;AAC7Cge,sBAAczS,KACZ,IAAI7B,QAAc,OAAOG,YAAY;AACnC,gBAAMoU,qBAAqBD,cAAche,QAAQ,CAAC;AAClD,gBAAM8C,QAAQ,KAAKqY,gBAAgBla,MAAM0B,OAAO;AAEhD,gBAAM4a,yBAA0BnW,SAAa;AAC3C,gBAAI8M,WAAW9M,GAAG,GAAG;AACnB,kBAAI,CAAC1D,SAAS;AACZ,qBAAKiZ,SAASvV,GAAU;cAC1B;AACA,qBAAO;YACT;AACA,mBAAO;;AAGT,cAAInD;AAEJO,kBAAQxE,KAAK,IAAIiB,QAAQ;YACvB,GAAGA;YACH+C,aAAa;;AAGf,cAAIka,iBAAiB;AACrB,gBAAMC,YACJrb,MAAMG,QAAQkb,aAAa,KAAKlb,QAAQmb;AAC1C,gBAAMC,eACJvb,MAAMG,QAAQob,gBAAgB,KAAKpb,QAAQqb;AAC7C,gBAAMC,gBACJ,CAAC7a,WACDya,cACCrb,MAAMG,QAAQC,oBACb,KAAKD,QAAQE;AAEjB,gBAAMqb,gBAAiC;YACrCtZ,QAAQjE,MAAMiE;YACduZ,MAAMxd,MAAM8E;YACZrC,SAAS,CAAC,CAACA;YACXua;YACA7D,iBAAiBnZ,MAAMmZ;YACvBlZ,SAASD,MAAMC;YACfyD,UAAU,KAAK1J,MAAM0J;YACrBgY,UAAW7b,UACT,KAAK6b,SAAS;cAAE,GAAG7b;cAAMyE,MAAMtE,MAAM0K;YAAS,CAAQ;YACxDqN,OAAOtV,UAAU,YAAYzC,MAAM+X;;AAGrC,gBAAM0F,QAAQ,YAAY;;AACxB,gBAAIzd,MAAMgZ,YAAY;AACpBhW,6BAAc0E,MAAAA,cAAc,KAAK1N,OAAOgG,MAAMkB,EAAE,MAAlCwG,gBAAAA,IAAqC1E;YACrD,OAAO;AAIL,kBAAIhD,MAAMqZ,cAAcrZ,MAAM8C,WAAW,WAAW;AAClD8F,wBAAO;cACT;AAGArF,sBAAQxE,KAAK,IAAIiB,QAAQ;gBACvB,GAAGA;gBACHgZ,YAAY;gBACZK,YAAYrZ,MAAMqZ,aAAa;;AAGjC,oBAAMqE,oBAAoBjV,QAAQkV,IAChC5J,eAAetJ,IAAI,OAAOxD,SAAS;AACjC,sBAAMzE,YAAYX,MAAMG,QAAQiF,IAAI;AAEpC,oBAAKzE,uCAAmBC,SAAS;AAC/B,wBAAOD,UAAkBC,QAAO;gBAClC;cACF,CAAC,CACH;AAEA,oBAAMmb,iBAAgB/b,MAAAA,MAAAA,MAAMG,SAAQ4W,WAAd/W,wBAAAA,KAAuB0b;AAE7Cva,4BAAcyF,QAAQkV,IAAI,CACxBD,mBACAE,aAAa,CACd,EAAEvV,KAAM1M,OAAMA,EAAE,CAAC,CAAC;YACrB;AAEA4H,oBAAQxE,KAAK,IAAIiB,QAAQ;cACvB,GAAGA;cACHgD;;AAGFgZ,wBAAYhc,KAAK;AAEjB,gBAAI;AACF,oBAAMgF,aAAa,MAAMhC;AACzB,kBAAK8Y,gBAAgBpF,YAAW;AAAK,uBAAO,MAAMoF;AAElD,kBAAI7I,WAAWjO,UAAU,GAAG;AAC1B,oBAAIsX,uBAAuBtX,UAAU;AAAG;cAC1C;AAEA,kBAAIiY,kBAAkBG,cAAc;AAClC,sBAAM,IAAI3U,QAASI,OAAMC,WAAWD,GAAGuU,YAAY,CAAC;cACtD;AAEA,kBAAKtB,gBAAgBpF,YAAW;AAAK,uBAAO,MAAMoF;AAElDvY,sBAAQxE,KAAK,IAAIiB,QAAQ;gBACvB,GAAGA;gBACHlG,OAAO4G;gBACPoC,QAAQ;gBACRkW,YAAY;gBACZH,WAAWC,KAAKC,IAAG;gBACnB/T;gBACAhC,aAAatC;;qBAER5G,OAAO;AACd,kBAAKgiB,gBAAgBpF,YAAW;AAAK,uBAAO,MAAMoF;AAClD,kBAAIQ,uBAAuBxiB,KAAK;AAAG;AAEnC,kBAAI;AACF+H,kCAAMG,SAAQya,YAAd5a,4BAAwB/H;uBACjB+jB,cAAc;AACrB/jB,wBAAQ+jB;AACR,oBAAIvB,uBAAuBuB,YAAY;AAAG;cAC5C;AAEAta,sBAAQxE,KAAK,IAAIiB,QAAQ;gBACvB,GAAGA;gBACHlG;gBACAgJ,QAAQ;gBACRkW,YAAY;;YAEhB;AAEAgD,wBAAYhc,KAAK;;AAInB,gBAAM8d,MAAMhF,KAAKC,IAAG,IAAK/Y,MAAM6Y;AAE/B,cAAIkF,WAAWtb,UACXZ,MAAMG,QAAQgc,oBACd,KAAKhc,QAAQic,2BACb,MACApc,MAAMG,QAAQkc,aAAa,KAAKlc,QAAQmc,oBAAoB;AAGhE,cAAIC;AAEJ,gBAAMC,qBAAqBxc,MAAMG,QAAQoc;AAIzCA,yBACE,OAAOC,uBAAuB,aAC1BA,mBAAmBd,aAAa,IAChCc;AAEN9a,kBAAQxE,KAAK,IAAIiB,QAAQ;YACvB,GAAGA;YACHyC,SACE,CAAC,CAACA,WAAW,CAAC,KAAKzI,MAAMuJ,QAAQ5B,KAAMhG,OAAMA,EAAEuF,OAAOlB,MAAMkB,EAAE;;AAGlE,cAAIlB,MAAM8C,WAAW,WAAW;AAG9B,gBAAIwa,eAAe;AACjB,kBAAI7U,QAASI,OAAMC,WAAWD,GAAGqU,SAAS,CAAC,EAAE7U,KAAK,YAAY;AAC5D,oBAAKyT,gBAAgBpF,YAAW;AAAK,yBAAOoF;AAE5CmB,iCAAiB;AACjB1Z,wBAAQxE,KAAK,IAAIiB,QAAQ;kBACvB,GAAGA;kBACH+C,aAAa;;AAGfiZ,4BAAYhc,KAAK;AACjB4I,wBAAO;cACT,CAAC;YACH;AAGA,kBAAM6U,MAAK;UACb,WAAWzd,MAAMsZ,YAAY8E,gBAAgBN,MAAMC,WAAW;AAE5DN,kBAAK;UACP;AAEA7U,kBAAO;QACT,CAAC,CACH;MACF,CAAC;AAED,YAAMH,QAAQkV,IAAIZ,aAAa;AAC/B,aAAOxZ;;AAGT+a,sCAAaA,MAAM;AACjB,YAAMA,aAAc3iB,QAAY;QAC9B,GAAGA;QACH2d,SAAS;MACX;AAEA,WAAKxT,QAAQvL,SAAUyG,OAAC;;AAAM;UAC5B,GAAGA;UACHuC,SAASvC,EAAEuC,QAAQkH,IAAI6T,UAAU;UACjC3W,eAAe3G,EAAE2G,cAAc8C,IAAI6T,UAAU;UAC7Cpa,iBAAgBlD,OAAEkD,mBAAFlD,mBAAkByJ,IAAI6T;QACxC;OAAE;AAEF,WAAKpY,KAAI;;AAGXA,gCAAO,YAA2B;AAChC,YAAM8B,UAAU,IAAIS,QAAc,OAAOG,SAAS2V,WAAW;AAC3D,cAAMrhB,OAAO,KAAKqJ;AAClB,cAAMiY,eAAe,KAAKxkB,MAAMqH;AAChC,cAAMod,gBAAgBD,aAAc3X,SAAS3J,KAAK2J;AAClD,YAAIiV;AAGJ,aAAKrC,cAAa;AAElB,aAAKzS,KAAK;UACRC,MAAM;UACNC,cAAcsX;UACdrX,YAAYjK;UACZkK,aAAaqX;QACf,CAAC;AAED,YAAIva;AACJ,cAAMwa,kBAAkB,KAAK1kB,MAAMuJ;AAEnC,aAAKuC,QAAQ6Y,MAAM,MAAM;AACvB,eAAKC,WAAU;AAGf1a,2BAAiB,KAAKiT,YAAYja,KAAKwN,UAAUxN,KAAKyJ,QAAQ;YAC5DkY,OAAO;UACT,CAAC;AAID,eAAK/Y,QAAQvL,SAAUyG,QAAO;YAC5B,GAAGA;YACH+F,WAAW;YACXrD,UAAUxG;YACVgH;YACAyD,eAAe3G,EAAE2G,cAAc0B,OAAQ1N,OAAM;AAC3C,qBAAO,CAACuI,eAAevC,KAAM2O,OAAMA,EAAEpP,OAAOvF,EAAEuF,EAAE;aACjD;UACH,EAAE;QACJ,CAAC;AAED,YAAI;AACF,cAAI;AAEF,kBAAM,KAAK2a,YAAY;cACrBtY,SAASW;cACTwS,aAAaA,MAAM,KAAKA,YAAY1O,OAAO;YAC7C,CAAC;mBACM7B,KAAK;UAEZ;AAIF,cAAK2V,gBAAgB,KAAKpF,YAAY1O,OAAO,GAAI;AAC/C,mBAAO8T;UACT;AAEA,gBAAMgD,iBAAiBJ,gBAAgBrV,OACpCrJ,WAAU,CAACkE,eAAevC,KAAMhG,OAAMA,EAAEuF,OAAOlB,MAAMkB,EAAE,CAC1D;AACA,gBAAM6d,kBAAkB7a,eAAemF,OACpCrJ,WAAU,CAAC0e,gBAAgB/c,KAAMhG,OAAMA,EAAEuF,OAAOlB,MAAMkB,EAAE,CAC3D;AACA,gBAAM6Y,iBAAiB2E,gBAAgBrV,OAAQrJ,WAC7CkE,eAAevC,KAAMhG,OAAMA,EAAEuF,OAAOlB,MAAMkB,EAAE,CAC9C;AAIA,eAAK4E,QAAQ6Y,MAAM,MAAM;AACvB,iBAAK7Y,QAAQvL,SAAUyG,QAAO;cAC5B,GAAGA;cACH+F,WAAW;cACXxD,SAASvC,EAAEkD;cACXA,gBAAgBxD;cAChBiH,eAAe,CACb,GAAG3G,EAAE2G,eACL,GAAGmX,eAAezV,OAAQ1N,OAAMA,EAAEmH,WAAW,OAAO,CAAC;YAEzD,EAAE;AACF,iBAAK8b,WAAU;WAChB;AAIC,WACE,CAACE,gBAAgB,SAAS,GAC1B,CAACC,iBAAiB,SAAS,GAC3B,CAAChF,gBAAgB,QAAQ,CAAC,EAE5B3P,QAAQ,CAAC,CAAC7G,SAASyb,IAAI,MAAM;AAC7Bzb,oBAAQ6G,QAASpK,WAAU;;AACzB,+BAAKka,gBAAgBla,MAAM0B,OAAO,EAAGM,SAAQgd,UAA7C,4BAAqDhf;YACvD,CAAC;UACH,CAAC;AAED,eAAKgH,KAAK;YACRC,MAAM;YACNC,cAAcsX;YACdrX,YAAYjK;YACZkK,aAAaqX;UACf,CAAC;AAED7V,kBAAO;iBACAzC,KAAK;AAEZ,cAAK2V,gBAAgB,KAAKpF,YAAY1O,OAAO,GAAI;AAC/C,mBAAO8T;UACT;AAEAyC,iBAAOpY,GAAG;QACZ;MACF,CAAC;AAED,WAAKkO,oBAAoBrM;AAEzB,aAAO,KAAKqM;;AAGduK,sCAAaA,MAAM;AAEjB,WAAK9Y,QAAQvL,SAAUyG,OAAM;AAC3B,eAAO;UACL,GAAGA;UACH2G,eAAe3G,EAAE2G,cAAc0B,OAAQ1N,OAAM;AAC3C,kBAAMkG,QAAQ,KAAKqY,gBAAgBve,EAAE+F,OAAO;AAE5C,gBAAI,CAACG,MAAMG,QAAQ4W,QAAQ;AACzB,qBAAO;YACT;AAIA,kBAAMqG,UACHtjB,EAAE8G,UACCZ,MAAMG,QAAQkd,iBAAiB,KAAKld,QAAQmd,uBAC5Ctd,MAAMG,QAAQid,UAAU,KAAKjd,QAAQod,kBACzC,IAAI,KAAK;AAEX,mBAAOzjB,EAAEmH,WAAW,WAAWgW,KAAKC,IAAG,IAAKpd,EAAEkd,YAAYoG;WAC3D;;MAEL,CAAC;;AAGHrO,wCAAe,OACbyO,eAAsC,KAAKrlB,MAAM0J,aAC9C;;AACH,UAAIxG,OAAO,KAAKwJ,cAAc2Y,YAAmB;AAEjD,UAAI9b,UAAU,KAAK4T,YAAYja,KAAKwN,UAAUxN,KAAKyJ,QAAQ;QACzDqR,cAAc;MAChB,CAAC;AAED,YAAMsH,iBAAiB9hB,OAAO+hB,aAC5B,MACE,GAAG,KAAKvlB,MAAMuJ,SACd,GAAI,KAAKvJ,MAAMkK,kBAAkB,CAAA,GACjC,GAAG,KAAKlK,MAAM2N,aAAa,MAH7B,mBAIG8C,IAAK9O,OAAM,CAACA,EAAEuF,IAAI,IAAI,EAC3B;AAEA,WAAK4E,QAAQ6Y,MAAM,MAAM;AACvBpb,gBAAQ6G,QAASpK,WAAU;AACzB,cAAI,CAACsf,eAAetf,MAAMkB,EAAE,GAAG;AAC7B,iBAAK4E,QAAQvL,SAAUyG,QAAO;cAC5B,GAAGA;cACH2G,eAAe,CAAC,GAAI3G,EAAE2G,eAAuB3H,KAAK;YACpD,EAAE;UACJ;QACF,CAAC;MACH,CAAC;AAEDuD,gBAAU,MAAM,KAAKsY,YAAY;QAC/BtY;QACAd,SAAS;QACTiU,aAAaA,MAAMhW;MACrB,CAAC;AAED,aAAO6C;;AAGTI,sCAAuCA,CAACD,UAAU7D,SAAS;AACzD6D,iBAAW;QACT,GAAGA;QACHqG,IAAIrG,SAASqG,KACT,KAAKmN,oBAAqBxT,SAASY,QAAQ,IAAeZ,SAASqG,EAAE,IACrErJ;;AAGN,YAAMxD,OAAO,KAAKwJ,cAAchD,QAAe;AAE/C,WAAI7D,6BAAMgE,YAAW,KAAK7J,MAAM8I,WAAW,WAAW;AACpD,eAAO;MACT;AAEA,YAAM0c,gBAAe3f,6BAAMgE,WACvB,KAAK0C,iBACL,KAAKvM,MAAMqH;AAEf,UAAI,CAACme,cAAc;AACjB,eAAO;MACT;AAEA,YAAMxf,QAAQoL,cAAc,KAAKvB,UAAU2V,aAAa9U,UAAU;QAChE,GAAG7K;QACHkK,IAAI7M,KAAKwN;MACX,CAAC;AAED,UAAI,CAAC1K,OAAO;AACV,eAAO;MACT;AAEA,UAAIA,WAAUH,6BAAMuQ,kBAAiB,OAAO;AAC1C,eAAO7R,UAAUihB,aAAa7Y,QAAQzJ,KAAKyJ,QAAQ,IAAI,IAAI3G,QAAQ;MACrE;AAEA,aAAOA;;AAGTyf,sCAAa,OAAOC,SAAoD;AACtE,WAAKlL,aAAalK,KAAKoV,IAAI;;AAG7B3W,yCAAgBA,CAAIjM,KAAU6iB,YAAwC;AACpE,UAAI,OAAO1jB,aAAa,aAAa;AACnC,cAAM2jB,SAAS,OAAO9iB,QAAQ,WAAWA,MAAMuW,KAAKI,UAAU3W,GAAG;AAEjE,aAAK2iB,WAAW,YAAY;AAC1B,gBAAMve,KAAM,qBAAoB0e,MAAO;AACvC,gBAAMtX,OACJ,OAAOqX,YAAY,aAAa,MAAOA,QAAO,IAAaA;AAC7D,iBAAQ,eAAcze,EAAG,wDAAuDb,WAC9Euf,MACF,CAAE,QAAOvM,KAAKI,UAAUnL,IAAI,CAAE;;gDAEUpH,EAAG;;;;QAI7C,CAAC;AAED,eAAO,MAAM,KAAKyH,YAAe7L,GAAG;MACtC;AAEA,aAAO,MAAM4D;;AAGfiI,uCAAwC7L,SAAa;AACnD,UAAI,OAAOb,aAAa,aAAa;AACnC,cAAM2jB,SAAS,OAAO9iB,QAAQ,WAAWA,MAAMuW,KAAKI,UAAU3W,GAAG;AAEjE,eAAOqD,OAAQ,qBAAoByf,MAAO,EAAC;MAC7C;AAEA,aAAOlf;;AAGTmf,qCAAYA,MAAwB;AAClC,aAAO;QACL7lB,OAAO;UACL8lB,mBAAmB,KAAK9lB,MAAMuJ,QAAQkH,IAAK9O,OACzCc,KAAKd,GAAG,CAAC,MAAM,UAAU,aAAa,YAAY,CAAC,CACrD;QACF;;;AAIJokB,mCAAU,OAAOC,4BAA2C;;AAC1D,UAAIC,OAAOD;AAEX,UAAI,OAAO/jB,aAAa,aAAa;AACnCgkB,eAAO9f,OAAOsH;MAChB;AAEA7F,gBACEqe,MACA,uIACF;AAEA,YAAMC,MAAMD;AACZ,WAAKE,iBAAiBD,IAAIE;AAC1B,uBAAKpe,SAAQ+d,YAAb,4BAAuBG,IAAIE;AAC3B,YAAMC,kBAAkBH,IAAItf,OAAO5G;AAEnC,UAAIuJ,UAAU,KAAK4T,YACjB,KAAKnd,MAAM0J,SAASgH,UACpB,KAAK1Q,MAAM0J,SAASiD,MACtB,EAAE8D,IAAKzK,WAAU;AACf,cAAMsgB,kBAAkBD,gBAAgBP,kBAAkBne,KACvDhG,OAAMA,EAAEuF,OAAOlB,MAAMkB,EACxB;AAEAU,kBACE0e,iBACC,oEAAmEtgB,MAAMkB,EAAG,GAC/E;AAEA,YAAIof,iBAAiB;AACnB,iBAAO;YACL,GAAGtgB;YACH,GAAGsgB;;QAEP;AACA,eAAOtgB;MACT,CAAC;AAED,WAAK8F,QAAQvL,SAAUyG,OAAM;AAC3B,eAAO;UACL,GAAGA;UACHuC;;MAEJ,CAAC;;AAz2CD,SAAK6B,OAAO;MACVqK,qBAAqB;MACrB0N,kBAAkB;MAClBE,qBAAqB;MACrBpd,SAASS;MACT,GAAGsB;MACH0Y,kBAAiB1Y,mCAAS0Y,oBAAmBnH;MAC7CsD,cAAa7U,mCAAS6U,gBAAe1D;IACvC,CAAC;EACH;EA+CA,IAAInZ,QAAQ;AACV,WAAO,KAAK8L,QAAQ9L;EACtB;EA8LA,IAAIkgB,kBAAkB;AACpB,WAAO,KAAKpY;EACd;;;;;;AAunCF;AAKO,SAASye,OAGdthB,IAAsBnC,KAAY;AAClC,SAAO,UAAUwC,SAA4D;AAC3E,UAAMkhB,WAAW,MAAMvhB,GAAE;AACzB,WAAOuhB,SAAS1jB,OAAO,SAAS,EAAE,GAAGwC,IAAI;;AAE7C;AAEO,IAAMiZ,mBAAN,cAA+BkI,MAAM;AAAA;AAErC,IAAM3I,iBAAN,cAA6B2I,MAAM;AAAA;AAEnC,SAAS1L,sBACdrR,UACkB;AAClB,SAAO;IACLqD,WAAW;IACXrB,iBAAiB;IACjB5C,QAAQ;IACRzB,kBAAkB;MAAE,GAAGqC;;IACvBA;IACAH,SAAS,CAAA;IACTW,gBAAgB,CAAA;IAChByD,eAAe,CAAA;IACf+Y,aAAa5H,KAAKC,IAAG;;AAEzB;ACpoDA,IAAM7Y,mBACJ,OAAOC,WAAW,cAAoBD,wBAAwBE;AAMhE,IAAMugB,YAAY;AAClB,IAAMC,YAAY;AAElB,IAAIC,uBAAuB,oBAAIC,QAAO;AAatC,IAAMC,kBAAkB,OAAO5gB,WAAW,eAAeA,OAAO6gB;AAEhE,IAAIC,QAAeF,mBACd,MAAM;AACL,QAAMG,aAAa;AAEnB,QAAMlnB,QAAoBqZ,KAAKC,MAC7BnT,OAAO6gB,eAAeG,QAAQD,UAAU,KAAK,MAC/C,KAAK;IAAEE,QAAQ,CAAA;IAAIlkB,MAAM,CAAA;;AAEzB,SAAO;IACLlD;IACAqnB,KAAM9kB,aAAY;AAChB0kB,YAAMjnB,QAAQsC,iBAAiBC,SAAS0kB,MAAMjnB,KAAK;AACnDmG,aAAO6gB,eAAeM,QAAQJ,YAAY7N,KAAKI,UAAUwN,MAAMjnB,KAAK,CAAC;IACvE;;AAEJ,GAAC,IACA0G;AAML,IAAM6gB,gBAAiB7d,cAA6BA,SAAS1J,MAAM8C;AAE5D,SAAS0kB,qBAAqBxf,SAAoC;AACvE,QAAMpB,SAASC,UAAS;AAExBX,EAAAA,iBAAgB,MAAM;AACpB,UAAMuhB,UAASzf,mCAASyf,WAAUF;AAElC,UAAM;MAAElb;IAAQ,IAAIlG;AACpB,QAAIkG,QAAQqb,mBAAmB;AAC7Brb,cAAQqb,oBAAoB;IAC9B;AAEA,UAAMC,WAAYC,WAAiB;AACjC,UAAIf,qBAAqBgB,IAAID,MAAMtT,MAAM;AAAG;AAC5CuS,2BAAqBtK,IAAIqL,MAAMtT,MAAM;AAErC,UAAIwT,kBAAkB;AAEtB,UAAIF,MAAMtT,WAAWrS,YAAY2lB,MAAMtT,WAAWnO,QAAQ;AACxD2hB,0BAAkBnB;MACpB,OAAO;AACL,cAAMoB,SAAUH,MAAMtT,OAAmB0T,aACvC,4BACF;AAEA,YAAID,QAAQ;AACVD,4BAAmB,gCAA+BC,MAAO;QAC3D,OAAO;AACLD,4BAAkBG,eAAeL,MAAMtT,MAAM;QAC/C;MACF;AAEA,UAAI,CAAC2S,MAAMjnB,MAAMkD,KAAK4kB,eAAe,GAAG;AACtCb,cAAMI,IAAKa,QAAO;UAChB,GAAGA;UACHhlB,MAAM;YACJ,GAAGglB,EAAEhlB;YACL,CAAC4kB,eAAe,GAAG;cACjBK,SAASC;cACTC,SAASD;YACX;UACF;QACF,EAAE;MACJ;;AAGF,QAAI,OAAOnmB,aAAa,aAAa;AACnCA,eAASqmB,iBAAiB,UAAUX,UAAU,IAAI;IACpD;AAEA,UAAMY,oBAAoB3hB,OAAO0F,UAAU,gBAAiBsb,WAAU;AACpE,UAAIA,MAAMxa,aAAa;AACrB,cAAMob,aAAaf,OAAOG,MAAM1a,YAAY;AAC5C,mBAAW4a,mBAAmBb,MAAMjnB,MAAMkD,MAAM;AAC9C,gBAAMulB,QAAQxB,MAAMjnB,MAAMkD,KAAK4kB,eAAe;AAC9C,cAAIA,oBAAoBnB,WAAW;AACjC8B,kBAAMN,UAAUhiB,OAAOgiB,WAAW;AAClCM,kBAAMJ,UAAUliB,OAAOkiB,WAAW;qBACzBP,iBAAiB;AAC1B,kBAAMY,UAAUzmB,SAASoL,cAAcya,eAAe;AACtDW,kBAAMN,WAAUO,mCAASC,eAAc;AACvCF,kBAAMJ,WAAUK,mCAASE,cAAa;UACxC;AAEA3B,gBAAMI,IAAKa,OAAM;AACf,kBAAMhlB,OAAO;cAAE,GAAGglB,EAAEhlB;;AACpB,mBAAOA,KAAK4kB,eAAe;AAE3B,mBAAO;cACL,GAAGI;cACHhlB;cACAkkB,QAAQ;gBACN,GAAGc,EAAEd;gBACL,CAAC,CAACoB,YAAYV,eAAe,EAAEvY,KAAKqX,SAAS,CAAC,GAAG6B;cACnD;;UAEJ,CAAC;QACH;MACF;IACF,CAAC;AAED,UAAMI,kBAAkBjiB,OAAO0F,UAAU,cAAesb,WAAU;AAChE,UAAIA,MAAMxa,aAAa;AACrB,YAAI,CAACxG,OAAOuT,iBAAiB;AAC3B;QACF;AAEAvT,eAAOuT,kBAAkB;AAEzB,cAAMsN,WAASzf,mCAASyf,WAAUF;AAElC,cAAMiB,aAAaf,QAAOG,MAAMza,UAAU;AAC1C,YAAI2b,iBAAiB;AAErB,mBAAWC,YAAY9B,MAAMjnB,MAAMonB,QAAQ;AACzC,gBAAMqB,QAAQxB,MAAMjnB,MAAMonB,OAAO2B,QAAQ;AACzC,gBAAM,CAACjmB,KAAKglB,eAAe,IAAIiB,SAASlY,MAAM+V,SAAS;AACvD,cAAI9jB,QAAQ0lB,YAAY;AACtB,gBAAIV,oBAAoBnB,WAAW;AACjCmC,+BAAiB;AACjB3iB,qBAAO6iB,SAASP,MAAMN,SAASM,MAAMJ,OAAO;uBACnCP,iBAAiB;AAC1B,oBAAMY,UAAUzmB,SAASoL,cAAcya,eAAe;AACtD,kBAAIY,SAAS;AACXA,wBAAQC,aAAaF,MAAMN;AAC3BO,wBAAQE,YAAYH,MAAMJ;cAC5B;YACF;UACF;QACF;AAEA,YAAI,CAACS,gBAAgB;AACnB3iB,iBAAO6iB,SAAS,GAAG,CAAC;QACtB;AAEA/B,cAAMI,IAAKa,QAAO;UAAE,GAAGA;UAAGhlB,MAAM,CAAA;QAAG,EAAE;AACrC2jB,+BAAuB,oBAAIC,QAAO;MACpC;IACF,CAAC;AAED,WAAO,MAAM;AACX7kB,eAASgnB,oBAAoB,UAAUtB,QAAQ;AAC/CY,wBAAiB;AACjBM,sBAAe;;KAEhB,CAAA,CAAE;AACP;AAEO,SAASK,kBAAkB5pB,OAAiC;AACjEkoB,uBAAqBloB,KAAK;AAC1B,SAAO;AACT;AAEO,SAAS6pB,4BACdnhB,SAYA;;AACA,QAAMpB,SAASC,UAAS;AACxB,QAAM4gB,UAASzf,mCAASyf,WAAUF;AAElC,MAAIO,kBAAkB;AAEtB,MAAI9f,QAAQd,IAAI;AACd4gB,sBAAmB,gCAA+B9f,QAAQd,EAAG;EAC/D,OAAO;AACL,UAAMwhB,WAAU1gB,aAAQohB,eAARphB;AAChB,QAAI,CAAC0gB,SAAS;AACZ;IACF;AACAZ,sBAAkBG,eAAeS,OAAO;EAC1C;AAEA,QAAMF,aAAaf,OAAO7gB,OAAO2F,cAAc;AAC/C,QAAMwc,WAAW,CAACP,YAAYV,eAAe,EAAEvY,KAAKqX,SAAS;AAC7D,SAAOK,MAAMjnB,MAAMonB,OAAO2B,QAAQ;AACpC;AAEA,SAASd,eAAe3a,IAAiB;AACvC,MAAIkC,OAAO,CAAA,GACT9M;AACF,SAAQA,SAAS4K,GAAG+b,YAAa;AAC/B7Z,SAAKoC,QACF,GAAEtE,GAAGgc,OAAQ,cACX,CAAA,EAAGC,QAAgBjlB,KAAK5B,OAAO7C,UAAUyN,EAAE,IAAI,CACjD,GACH;AACAA,SAAK5K;EACP;AACA,SAAQ,GAAE8M,KAAKD,KAAK,KAAK,CAAE,GAAE4C,YAAW;AAC1C;AChOO,SAASqX,WACdC,WACAC,YAA2B,MACrB;AACN,QAAM;IAAErd;MAAYxF,UAAS;AAE7BgF,EAAMzF,gBAAU,MAAM;AACpB,QAAI,CAACsjB;AAAW;AAChB,WAAOrd,QAAQsd,MAAMF,SAAS;EAChC,CAAC;AACH;AAEO,SAASG,MAAM;EAAEC;EAASH;EAAW7pB;AAAsB,GAAG;AACnE2pB,aAAWK,SAASH,SAAS;AAC7B,SAAQ7pB,YAAY;AACtB;ACXO,SAASiqB,YAGdC,aAAuC;AACvC,QAAM;IAAErI;MAAa7a,UAAS;AAC9B,QAAMuK,iBAAgBtL,SAAS;IAC7ByE,QAAQ;IACRxE,QAASiB,OAAMA,EAAE0J;EACnB,CAAC;AACD,SAAa9G,kBAOT/D,UACG;AACH,WAAO6b,SAAS;MACdpX,OAAMzE,6BAAMkK,MAAKqB,iBAAgB1K;MACjC,GAAGqjB;MACH,GAAIlkB;IACN,CAAC;KAEH,CAAA,CACF;AACF;AAiBO,SAASmkB,SAMd1qB,OAA0E;AAC1E,QAAM;IAAEoiB;MAAa7a,UAAS;AAC9B,QAAMb,QAAQF,SAAS;IAAEyE,QAAQ;EAAM,CAAC;AAExCsB,EAAMzF,gBAAU,MAAM;AACpBsb,aAAS;MACPpX,MAAMhL,MAAMyQ,KAAK/J,MAAM0K,WAAWhK;MAClC,GAAGpH;IACL,CAAQ;KACP,CAAA,CAAE;AAEL,SAAO;AACT;",
  "names": ["React", "useState", "useEffect", "useLayoutEffect", "error", "React", "useRef", "useEffect", "useSyncExternalStoreWithSelector", "pushStateEvent", "popStateEvent", "beforeUnloadEvent", "beforeUnloadListener", "event", "preventDefault", "returnValue", "stopBlocking", "removeEventListener", "capture", "createHistory", "opts", "location", "getLocation", "subscribers", "Set", "blockers", "onUpdate", "forEach", "subscriber", "tryNavigation", "task", "document", "length", "blocker", "allowed", "onBlocked", "subscribe", "cb", "add", "delete", "push", "path", "state", "assignKey", "pushState", "replace", "replaceState", "go", "index", "back", "forward", "createHref", "str", "block", "addEventListener", "filter", "b", "flush", "destroy", "notify", "key", "createRandomKey", "createBrowserHistory", "win", "window", "undefined", "parseLocation", "parseHref", "pathname", "search", "hash", "history", "currentLocation", "rollbackLocation", "next", "tracking", "scheduled", "untrack", "fn", "isPush", "href", "queueHistoryAction", "type", "destHref", "Promise", "resolve", "then", "onPushPop", "originalPushState", "originalReplaceState", "n", "res", "apply", "arguments", "createHashHistory", "hashHref", "split", "slice", "join", "createMemoryHistory", "initialEntries", "entries", "initialIndex", "currentState", "Math", "min", "max", "hashIndex", "indexOf", "searchIndex", "substring", "random", "toString", "isProduction", "CatchBoundary", "props", "errorComponent", "ErrorComponent", "createElement", "CatchBoundaryImpl", "getResetKey", "onCatch", "children", "error", "Component", "state", "getDerivedStateFromProps", "resetKey", "getDerivedStateFromError", "componentDidUpdate", "prevProps", "prevState", "setState", "componentDidCatch", "console", "render", "show", "setShow", "useState", "process", "style", "padding", "maxWidth", "display", "alignItems", "gap", "fontSize", "appearance", "border", "fontWeight", "borderRadius", "onClick", "d", "height", "color", "overflow", "message", "isServer", "document", "last", "arr", "length", "isFunction", "functionalUpdate", "updater", "previous", "pick", "parent", "keys", "reduce", "obj", "key", "replaceEqualDeep", "prev", "_next", "next", "array", "Array", "isArray", "isPlainObject", "prevSize", "Object", "nextItems", "nextSize", "copy", "equalItems", "i", "o", "hasObjectPrototype", "ctor", "constructor", "prot", "prototype", "hasOwnProperty", "toString", "call", "deepEqual", "a", "b", "partial", "aKeys", "bKeys", "some", "item", "index", "useStableCallback", "fn", "fnRef", "useRef", "current", "ref", "args", "shallow", "objA", "objB", "is", "keysA", "useRouteContext", "opts", "useMatch", "select", "match", "context", "useLayoutEffect", "window", "useEffect", "escapeJSON", "jsonString", "replace", "matchContext", "createContext", "undefined", "Matches", "router", "useRouter", "matchId", "useRouterState", "s", "getRenderedMatches", "id", "Provider", "value", "resolvedLocation", "warning", "Match", "SafeFragment", "Fragment", "routeId", "find", "invariant", "route", "routesById", "PendingComponent", "options", "pendingComponent", "defaultPendingComponent", "pendingElement", "routeErrorComponent", "defaultErrorComponent", "ResolvedSuspenseBoundary", "wrapInSuspense", "component", "preload", "Suspense", "ResolvedCatchBoundary", "fallback", "MatchInner", "status", "showPending", "loadPromise", "Comp", "defaultComponent", "Outlet", "memo", "useContext", "childMatchId", "matches", "findIndex", "useMatchRoute", "location", "matchRoute", "useCallback", "pending", "caseSensitive", "rest", "MatchRoute", "params", "pendingMatches", "nearestMatchId", "nearestMatchRouteId", "matchRouteId", "from", "strict", "matchSelection", "useMatches", "useParentMatches", "contextMatchId", "slice", "useLoaderDeps", "loaderDeps", "useLoaderData", "loaderData", "routerContext", "__TSR_ROUTER_CONTEXT__", "RouterProvider", "update", "InnerWrap", "provider", "Transitioner", "Wrap", "routerState", "isTransitioning", "startReactTransition", "useTransition", "React", "__store", "tryLoad", "apply", "cb", "load", "err", "unsub", "history", "subscribe", "latestLocation", "parseLocation", "nextLocation", "buildLocation", "search", "hash", "href", "commitLocation", "isLoading", "emit", "type", "fromLocation", "toLocation", "pathChanged", "querySelector", "el", "getElementById", "scrollIntoView", "__TSR_DEHYDRATED__", "getRouteMatch", "cachedMatches", "useStore", "resolvedContext", "defer", "_promise", "promise", "__deferredState", "uid", "Math", "random", "then", "data", "catch", "isDehydratedDeferred", "Promise", "useAwaited", "hydrateData", "resolve", "r", "setTimeout", "dehydrateData", "Await", "awaited", "joinPaths", "paths", "cleanPath", "filter", "Boolean", "join", "path", "trimPathLeft", "trimPathRight", "trimPath", "resolvePath", "basepath", "base", "to", "RegExp", "baseSegments", "parsePathname", "toSegments", "forEach", "toSegment", "push", "pop", "joined", "map", "pathname", "segments", "substring", "split", "part", "charAt", "interpolatePath", "leaveWildcards", "interpolatedPathSegments", "segment", "matchPathname", "currentPathname", "matchLocation", "pathParams", "matchByPath", "removeBasepath", "routeSegments", "startsWith", "unshift", "isMatch", "max", "baseSegment", "routeSegment", "isLastBaseSegment", "isLastRouteSegment", "toLowerCase", "fuzzy", "useParams", "useSearch", "rootRouteId", "RouteApi", "Route", "init", "originalIndex", "isRoot", "parentRoute", "getParentRoute", "customId", "fullPath", "addChildren", "assign", "$$typeof", "Symbol", "for", "rootRouteWithContext", "RootRoute", "createRouteMask", "NotFoundRoute", "FileRoute", "createRoute", "lazyRouteComponent", "importer", "exportName", "lazyComp", "lazy", "moduleExports", "comp", "default", "preloadWarning", "useLinkProps", "target", "activeProps", "className", "inactiveProps", "activeOptions", "disabled", "mask", "userPreload", "preloadDelay", "userPreloadDelay", "startTransition", "resetScroll", "onFocus", "onMouseEnter", "onMouseLeave", "onTouchStart", "dest", "URL", "defaultPreload", "defaultPreloadDelay", "isActive", "currentPathSplit", "nextPathSplit", "pathIsFuzzyEqual", "every", "pathTest", "exact", "hashTest", "includeHash", "searchTest", "includeSearch", "handleClick", "e", "isCtrlEvent", "defaultPrevented", "button", "preventDefault", "handleFocus", "preloadRoute", "warn", "handleTouchStart", "handleEnter", "preloadTimeout", "handleLeave", "clearTimeout", "composeHandlers", "handlers", "persist", "handler", "resolvedActiveProps", "resolvedInactiveProps", "maskedLocation", "role", "Link", "forwardRef", "linkProps", "_extends", "metaKey", "altKey", "ctrlKey", "shiftKey", "encode", "pfx", "k", "tmp", "str", "encodeURIComponent", "toValue", "mix", "decodeURIComponent", "decode", "out", "shift", "concat", "redirect", "isRedirect", "throw", "defaultParseSearch", "parseSearchWith", "JSON", "parse", "defaultStringifySearch", "stringifySearchWith", "stringify", "parser", "searchStr", "query", "stringifyValue", "val", "componentTypes", "Router", "tempLocationKey", "round", "resetNextScroll", "navigateTimeout", "latestLoadPromise", "subscribers", "Set", "injectedHtml", "newOptions", "createBrowserHistory", "createMemoryHistory", "routeTree", "buildRouteTree", "Store", "getInitialRouterState", "onUpdate", "routesByPath", "notFoundRoute", "recurseRoutes", "childRoutes", "childRoute", "existingRoute", "String", "trimmedFullPath", "endsWith", "scoredRoutes", "values", "trimmed", "parsed", "scores", "child", "flatRoutes", "sort", "minLength", "min", "rank", "eventType", "listener", "add", "delete", "routerEvent", "checkLatest", "previousLocation", "parsedSearch", "parseSearch", "reverse", "__tempLocation", "__tempKey", "parsedTempLocation", "resolvePathWithBase", "matchRoutes", "locationSearch", "routeParams", "foundRoute", "matchedParams", "routeCursor", "matchedRoutes", "parseErrors", "parsedParamsError", "parseParams", "parsedParams", "PathParamError", "cause", "throwOnError", "parentMatch", "preMatchSearch", "searchError", "parentSearch", "validator", "validateSearch", "SearchParamError", "loaderDepsHash", "interpolatedPath", "existingMatch", "hasLoaders", "loader", "updatedAt", "Date", "now", "isFetching", "paramsError", "routeContext", "abortController", "AbortController", "fetchCount", "invalid", "cancelMatch", "abort", "cancelMatches", "build", "fromSearch", "at", "fromPathname", "fromMatches", "stayingMatches", "prevParams", "nextParams", "looseRoutesById", "stringifyParams", "preSearchFilters", "flat", "postSearchFilters", "preFilteredSearch", "destSearch", "postFilteredSearch", "stringifySearch", "hashStr", "nextState", "unmaskOnReload", "buildWithMatches", "maskedDest", "maskedNext", "foundMask", "routeMasks", "nextMatches", "maskedMatches", "maskedFinal", "final", "isSameUrl", "nextHistory", "buildAndCommitLocation", "navigate", "fromString", "isExternal", "loadMatches", "latestPromise", "firstBadMatchIndex", "updateMatch", "isPending", "_a", "isMatched", "matchesKey", "entries", "handleErrorAndRedirect", "code", "routerCode", "onError", "errorHandlerErr", "parentContext", "beforeLoadContext", "beforeLoad", "validResolvedMatches", "matchPromises", "parentMatchPromise", "didShowPending", "pendingMs", "defaultPendingMs", "pendingMinMs", "defaultPendingMinMs", "shouldPending", "loaderContext", "deps", "fetch", "componentsPromise", "all", "loaderPromise", "onErrorError", "age", "staleAge", "preloadStaleTime", "defaultPreloadStaleTime", "staleTime", "defaultStaleTime", "shouldReload", "shouldReloadOption", "invalidate", "reject", "prevLocation", "pathDidChange", "previousMatches", "batch", "cleanCache", "debug", "exitingMatches", "enteringMatches", "hook", "gcTime", "preloadGcTime", "defaultPreloadGcTime", "defaultGcTime", "navigateOpts", "loadedMatchIds", "fromEntries", "baseLocation", "injectHtml", "html", "getData", "strKey", "dehydrate", "dehydratedMatches", "hydrate", "__do_not_use_server_ctx", "_ctx", "ctx", "dehydratedData", "payload", "dehydratedState", "dehydratedMatch", "lazyFn", "imported", "Error", "lastUpdated", "windowKey", "delimiter", "weakScrolledElements", "WeakSet", "sessionsStorage", "sessionStorage", "cache", "storageKey", "getItem", "cached", "set", "setItem", "defaultGetKey", "useScrollRestoration", "getKey", "scrollRestoration", "onScroll", "event", "has", "elementSelector", "attrId", "getAttribute", "getCssSelector", "c", "scrollX", "NaN", "scrollY", "addEventListener", "unsubOnBeforeLoad", "restoreKey", "entry", "element", "scrollLeft", "scrollTop", "unsubOnResolved", "windowRestored", "cacheKey", "scrollTo", "removeEventListener", "ScrollRestoration", "useElementScrollRestoration", "getElement", "parentNode", "tagName", "indexOf", "useBlocker", "blockerFn", "condition", "block", "Block", "blocker", "useNavigate", "defaultOpts", "Navigate"]
}
